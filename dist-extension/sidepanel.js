function xB(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();function dw(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function vB(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var Yb={exports:{}},Qu={};var D$;function wB(){if(D$)return Qu;D$=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,r,i){var o=null;if(i!==void 0&&(o=""+i),r.key!==void 0&&(o=""+r.key),"key"in r){i={};for(var l in r)l!=="key"&&(i[l]=r[l])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:o,ref:r!==void 0?r:null,props:i}}return Qu.Fragment=e,Qu.jsx=t,Qu.jsxs=t,Qu}var O$;function SB(){return O$||(O$=1,Yb.exports=wB()),Yb.exports}var oe=SB(),Jb={exports:{}},Xe={};var M$;function CB(){if(M$)return Xe;M$=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),o=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function y(F){return F===null||typeof F!="object"?null:(F=m&&F[m]||F["@@iterator"],typeof F=="function"?F:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function S(F,V,Q){this.props=F,this.context=V,this.refs=w,this.updater=Q||b}S.prototype.isReactComponent={},S.prototype.setState=function(F,V){if(typeof F!="object"&&typeof F!="function"&&F!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,F,V,"setState")},S.prototype.forceUpdate=function(F){this.updater.enqueueForceUpdate(this,F,"forceUpdate")};function T(){}T.prototype=S.prototype;function k(F,V,Q){this.props=F,this.context=V,this.refs=w,this.updater=Q||b}var $=k.prototype=new T;$.constructor=k,x($,S.prototype),$.isPureReactComponent=!0;var E=Array.isArray;function N(){}var _={H:null,A:null,T:null,S:null},R=Object.prototype.hasOwnProperty;function D(F,V,Q){var re=Q.ref;return{$$typeof:n,type:F,key:V,ref:re!==void 0?re:null,props:Q}}function M(F,V){return D(F.type,V,F.props)}function A(F){return typeof F=="object"&&F!==null&&F.$$typeof===n}function z(F){var V={"=":"=0",":":"=2"};return"$"+F.replace(/[=:]/g,function(Q){return V[Q]})}var W=/\/+/g;function Y(F,V){return typeof F=="object"&&F!==null&&F.key!=null?z(""+F.key):V.toString(36)}function K(F){switch(F.status){case"fulfilled":return F.value;case"rejected":throw F.reason;default:switch(typeof F.status=="string"?F.then(N,N):(F.status="pending",F.then(function(V){F.status==="pending"&&(F.status="fulfilled",F.value=V)},function(V){F.status==="pending"&&(F.status="rejected",F.reason=V)})),F.status){case"fulfilled":return F.value;case"rejected":throw F.reason}}throw F}function P(F,V,Q,re,he){var ye=typeof F;(ye==="undefined"||ye==="boolean")&&(F=null);var we=!1;if(F===null)we=!0;else switch(ye){case"bigint":case"string":case"number":we=!0;break;case"object":switch(F.$$typeof){case n:case e:we=!0;break;case d:return we=F._init,P(we(F._payload),V,Q,re,he)}}if(we)return he=he(F),we=re===""?"."+Y(F,0):re,E(he)?(Q="",we!=null&&(Q=we.replace(W,"$&/")+"/"),P(he,V,Q,"",function(Pe){return Pe})):he!=null&&(A(he)&&(he=M(he,Q+(he.key==null||F&&F.key===he.key?"":(""+he.key).replace(W,"$&/")+"/")+we)),V.push(he)),1;we=0;var Ie=re===""?".":re+":";if(E(F))for(var Ce=0;Ce<F.length;Ce++)re=F[Ce],ye=Ie+Y(re,Ce),we+=P(re,V,Q,ye,he);else if(Ce=y(F),typeof Ce=="function")for(F=Ce.call(F),Ce=0;!(re=F.next()).done;)re=re.value,ye=Ie+Y(re,Ce++),we+=P(re,V,Q,ye,he);else if(ye==="object"){if(typeof F.then=="function")return P(K(F),V,Q,re,he);throw V=String(F),Error("Objects are not valid as a React child (found: "+(V==="[object Object]"?"object with keys {"+Object.keys(F).join(", ")+"}":V)+"). If you meant to render a collection of children, use an array instead.")}return we}function B(F,V,Q){if(F==null)return F;var re=[],he=0;return P(F,re,"","",function(ye){return V.call(Q,ye,he++)}),re}function G(F){if(F._status===-1){var V=F._result;V=V(),V.then(function(Q){(F._status===0||F._status===-1)&&(F._status=1,F._result=Q)},function(Q){(F._status===0||F._status===-1)&&(F._status=2,F._result=Q)}),F._status===-1&&(F._status=0,F._result=V)}if(F._status===1)return F._result.default;throw F._result}var ee=typeof reportError=="function"?reportError:function(F){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var V=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof F=="object"&&F!==null&&typeof F.message=="string"?String(F.message):String(F),error:F});if(!window.dispatchEvent(V))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",F);return}console.error(F)},Z={map:B,forEach:function(F,V,Q){B(F,function(){V.apply(this,arguments)},Q)},count:function(F){var V=0;return B(F,function(){V++}),V},toArray:function(F){return B(F,function(V){return V})||[]},only:function(F){if(!A(F))throw Error("React.Children.only expected to receive a single React element child.");return F}};return Xe.Activity=p,Xe.Children=Z,Xe.Component=S,Xe.Fragment=t,Xe.Profiler=r,Xe.PureComponent=k,Xe.StrictMode=s,Xe.Suspense=c,Xe.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=_,Xe.__COMPILER_RUNTIME={__proto__:null,c:function(F){return _.H.useMemoCache(F)}},Xe.cache=function(F){return function(){return F.apply(null,arguments)}},Xe.cacheSignal=function(){return null},Xe.cloneElement=function(F,V,Q){if(F==null)throw Error("The argument must be a React element, but you passed "+F+".");var re=x({},F.props),he=F.key;if(V!=null)for(ye in V.key!==void 0&&(he=""+V.key),V)!R.call(V,ye)||ye==="key"||ye==="__self"||ye==="__source"||ye==="ref"&&V.ref===void 0||(re[ye]=V[ye]);var ye=arguments.length-2;if(ye===1)re.children=Q;else if(1<ye){for(var we=Array(ye),Ie=0;Ie<ye;Ie++)we[Ie]=arguments[Ie+2];re.children=we}return D(F.type,he,re)},Xe.createContext=function(F){return F={$$typeof:o,_currentValue:F,_currentValue2:F,_threadCount:0,Provider:null,Consumer:null},F.Provider=F,F.Consumer={$$typeof:i,_context:F},F},Xe.createElement=function(F,V,Q){var re,he={},ye=null;if(V!=null)for(re in V.key!==void 0&&(ye=""+V.key),V)R.call(V,re)&&re!=="key"&&re!=="__self"&&re!=="__source"&&(he[re]=V[re]);var we=arguments.length-2;if(we===1)he.children=Q;else if(1<we){for(var Ie=Array(we),Ce=0;Ce<we;Ce++)Ie[Ce]=arguments[Ce+2];he.children=Ie}if(F&&F.defaultProps)for(re in we=F.defaultProps,we)he[re]===void 0&&(he[re]=we[re]);return D(F,ye,he)},Xe.createRef=function(){return{current:null}},Xe.forwardRef=function(F){return{$$typeof:l,render:F}},Xe.isValidElement=A,Xe.lazy=function(F){return{$$typeof:d,_payload:{_status:-1,_result:F},_init:G}},Xe.memo=function(F,V){return{$$typeof:h,type:F,compare:V===void 0?null:V}},Xe.startTransition=function(F){var V=_.T,Q={};_.T=Q;try{var re=F(),he=_.S;he!==null&&he(Q,re),typeof re=="object"&&re!==null&&typeof re.then=="function"&&re.then(N,ee)}catch(ye){ee(ye)}finally{V!==null&&Q.types!==null&&(V.types=Q.types),_.T=V}},Xe.unstable_useCacheRefresh=function(){return _.H.useCacheRefresh()},Xe.use=function(F){return _.H.use(F)},Xe.useActionState=function(F,V,Q){return _.H.useActionState(F,V,Q)},Xe.useCallback=function(F,V){return _.H.useCallback(F,V)},Xe.useContext=function(F){return _.H.useContext(F)},Xe.useDebugValue=function(){},Xe.useDeferredValue=function(F,V){return _.H.useDeferredValue(F,V)},Xe.useEffect=function(F,V){return _.H.useEffect(F,V)},Xe.useEffectEvent=function(F){return _.H.useEffectEvent(F)},Xe.useId=function(){return _.H.useId()},Xe.useImperativeHandle=function(F,V,Q){return _.H.useImperativeHandle(F,V,Q)},Xe.useInsertionEffect=function(F,V){return _.H.useInsertionEffect(F,V)},Xe.useLayoutEffect=function(F,V){return _.H.useLayoutEffect(F,V)},Xe.useMemo=function(F,V){return _.H.useMemo(F,V)},Xe.useOptimistic=function(F,V){return _.H.useOptimistic(F,V)},Xe.useReducer=function(F,V,Q){return _.H.useReducer(F,V,Q)},Xe.useRef=function(F){return _.H.useRef(F)},Xe.useState=function(F){return _.H.useState(F)},Xe.useSyncExternalStore=function(F,V,Q){return _.H.useSyncExternalStore(F,V,Q)},Xe.useTransition=function(){return _.H.useTransition()},Xe.version="19.2.3",Xe}var F$;function fw(){return F$||(F$=1,Jb.exports=CB()),Jb.exports}var Se=fw();const TB=dw(Se);var Zb={exports:{}},eh={},Qb={exports:{}},ex={};var L$;function kB(){return L$||(L$=1,(function(n){function e(P,B){var G=P.length;P.push(B);e:for(;0<G;){var ee=G-1>>>1,Z=P[ee];if(0<r(Z,B))P[ee]=B,P[G]=Z,G=ee;else break e}}function t(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var B=P[0],G=P.pop();if(G!==B){P[0]=G;e:for(var ee=0,Z=P.length,F=Z>>>1;ee<F;){var V=2*(ee+1)-1,Q=P[V],re=V+1,he=P[re];if(0>r(Q,G))re<Z&&0>r(he,Q)?(P[ee]=he,P[re]=G,ee=re):(P[ee]=Q,P[V]=G,ee=V);else if(re<Z&&0>r(he,G))P[ee]=he,P[re]=G,ee=re;else break e}}return B}function r(P,B){var G=P.sortIndex-B.sortIndex;return G!==0?G:P.id-B.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();n.unstable_now=function(){return o.now()-l}}var c=[],h=[],d=1,p=null,m=3,y=!1,b=!1,x=!1,w=!1,S=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,k=typeof setImmediate<"u"?setImmediate:null;function $(P){for(var B=t(h);B!==null;){if(B.callback===null)s(h);else if(B.startTime<=P)s(h),B.sortIndex=B.expirationTime,e(c,B);else break;B=t(h)}}function E(P){if(x=!1,$(P),!b)if(t(c)!==null)b=!0,N||(N=!0,z());else{var B=t(h);B!==null&&K(E,B.startTime-P)}}var N=!1,_=-1,R=5,D=-1;function M(){return w?!0:!(n.unstable_now()-D<R)}function A(){if(w=!1,N){var P=n.unstable_now();D=P;var B=!0;try{e:{b=!1,x&&(x=!1,T(_),_=-1),y=!0;var G=m;try{t:{for($(P),p=t(c);p!==null&&!(p.expirationTime>P&&M());){var ee=p.callback;if(typeof ee=="function"){p.callback=null,m=p.priorityLevel;var Z=ee(p.expirationTime<=P);if(P=n.unstable_now(),typeof Z=="function"){p.callback=Z,$(P),B=!0;break t}p===t(c)&&s(c),$(P)}else s(c);p=t(c)}if(p!==null)B=!0;else{var F=t(h);F!==null&&K(E,F.startTime-P),B=!1}}break e}finally{p=null,m=G,y=!1}B=void 0}}finally{B?z():N=!1}}}var z;if(typeof k=="function")z=function(){k(A)};else if(typeof MessageChannel<"u"){var W=new MessageChannel,Y=W.port2;W.port1.onmessage=A,z=function(){Y.postMessage(null)}}else z=function(){S(A,0)};function K(P,B){_=S(function(){P(n.unstable_now())},B)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(P){switch(m){case 1:case 2:case 3:var B=3;break;default:B=m}var G=m;m=B;try{return P()}finally{m=G}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(P,B){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var G=m;m=P;try{return B()}finally{m=G}},n.unstable_scheduleCallback=function(P,B,G){var ee=n.unstable_now();switch(typeof G=="object"&&G!==null?(G=G.delay,G=typeof G=="number"&&0<G?ee+G:ee):G=ee,P){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=G+Z,P={id:d++,callback:B,priorityLevel:P,startTime:G,expirationTime:Z,sortIndex:-1},G>ee?(P.sortIndex=G,e(h,P),t(c)===null&&P===t(h)&&(x?(T(_),_=-1):x=!0,K(E,G-ee))):(P.sortIndex=Z,e(c,P),b||y||(b=!0,N||(N=!0,z()))),P},n.unstable_shouldYield=M,n.unstable_wrapCallback=function(P){var B=m;return function(){var G=m;m=B;try{return P.apply(this,arguments)}finally{m=G}}}})(ex)),ex}var P$;function $B(){return P$||(P$=1,Qb.exports=kB()),Qb.exports}var tx={exports:{}},Zn={};var z$;function EB(){if(z$)return Zn;z$=1;var n=fw();function e(c){var h="https://react.dev/errors/"+c;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+c+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(c,h,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:c,containerInfo:h,implementation:d}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function l(c,h){if(c==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return Zn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Zn.createPortal=function(c,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(e(299));return i(c,h,null,d)},Zn.flushSync=function(c){var h=o.T,d=s.p;try{if(o.T=null,s.p=2,c)return c()}finally{o.T=h,s.p=d,s.d.f()}},Zn.preconnect=function(c,h){typeof c=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(c,h))},Zn.prefetchDNS=function(c){typeof c=="string"&&s.d.D(c)},Zn.preinit=function(c,h){if(typeof c=="string"&&h&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(c,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(c,{crossOrigin:p,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},Zn.preinitModule=function(c,h){if(typeof c=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=l(h.as,h.crossOrigin);s.d.M(c,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(c)},Zn.preload=function(c,h){if(typeof c=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin);s.d.L(c,d,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},Zn.preloadModule=function(c,h){if(typeof c=="string")if(h){var d=l(h.as,h.crossOrigin);s.d.m(c,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(c)},Zn.requestFormReset=function(c){s.d.r(c)},Zn.unstable_batchedUpdates=function(c,h){return c(h)},Zn.useFormState=function(c,h,d){return o.H.useFormState(c,h,d)},Zn.useFormStatus=function(){return o.H.useHostTransitionStatus()},Zn.version="19.2.3",Zn}var B$;function IB(){if(B$)return tx.exports;B$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),tx.exports=EB(),tx.exports}var V$;function NB(){if(V$)return eh;V$=1;var n=$B(),e=fw(),t=IB();function s(a){var u="https://react.dev/errors/"+a;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)u+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+a+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function i(a){var u=a,f=a;if(a.alternate)for(;u.return;)u=u.return;else{a=u;do u=a,(u.flags&4098)!==0&&(f=u.return),a=u.return;while(a)}return u.tag===3?f:null}function o(a){if(a.tag===13){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function l(a){if(a.tag===31){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function c(a){if(i(a)!==a)throw Error(s(188))}function h(a){var u=a.alternate;if(!u){if(u=i(a),u===null)throw Error(s(188));return u!==a?null:a}for(var f=a,g=u;;){var v=f.return;if(v===null)break;var C=v.alternate;if(C===null){if(g=v.return,g!==null){f=g;continue}break}if(v.child===C.child){for(C=v.child;C;){if(C===f)return c(v),a;if(C===g)return c(v),u;C=C.sibling}throw Error(s(188))}if(f.return!==g.return)f=v,g=C;else{for(var I=!1,O=v.child;O;){if(O===f){I=!0,f=v,g=C;break}if(O===g){I=!0,g=v,f=C;break}O=O.sibling}if(!I){for(O=C.child;O;){if(O===f){I=!0,f=C,g=v;break}if(O===g){I=!0,g=C,f=v;break}O=O.sibling}if(!I)throw Error(s(189))}}if(f.alternate!==g)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?a:u}function d(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a;for(a=a.child;a!==null;){if(u=d(a),u!==null)return u;a=a.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),k=Symbol.for("react.context"),$=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),R=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),M=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function z(a){return a===null||typeof a!="object"?null:(a=A&&a[A]||a["@@iterator"],typeof a=="function"?a:null)}var W=Symbol.for("react.client.reference");function Y(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===W?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case x:return"Fragment";case S:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case N:return"SuspenseList";case D:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case b:return"Portal";case k:return a.displayName||"Context";case T:return(a._context.displayName||"Context")+".Consumer";case $:var u=a.render;return a=a.displayName,a||(a=u.displayName||u.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case _:return u=a.displayName||null,u!==null?u:Y(a.type)||"Memo";case R:u=a._payload,a=a._init;try{return Y(a(u))}catch{}}return null}var K=Array.isArray,P=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,B=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,G={pending:!1,data:null,method:null,action:null},ee=[],Z=-1;function F(a){return{current:a}}function V(a){0>Z||(a.current=ee[Z],ee[Z]=null,Z--)}function Q(a,u){Z++,ee[Z]=a.current,a.current=u}var re=F(null),he=F(null),ye=F(null),we=F(null);function Ie(a,u){switch(Q(ye,u),Q(he,a),Q(re,null),u.nodeType){case 9:case 11:a=(a=u.documentElement)&&(a=a.namespaceURI)?n$(a):0;break;default:if(a=u.tagName,u=u.namespaceURI)u=n$(u),a=s$(u,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}V(re),Q(re,a)}function Ce(){V(re),V(he),V(ye)}function Pe(a){a.memoizedState!==null&&Q(we,a);var u=re.current,f=s$(u,a.type);u!==f&&(Q(he,a),Q(re,f))}function Te(a){he.current===a&&(V(re),V(he)),we.current===a&&(V(we),Xu._currentValue=G)}var ze,Ke;function Qe(a){if(ze===void 0)try{throw Error()}catch(f){var u=f.stack.trim().match(/\n( *(at )?)/);ze=u&&u[1]||"",Ke=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ze+a+Ke}var We=!1;function qe(a,u){if(!a||We)return"";We=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(u){var be=function(){throw Error()};if(Object.defineProperty(be.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(be,[])}catch(de){var ue=de}Reflect.construct(a,[],be)}else{try{be.call()}catch(de){ue=de}a.call(be.prototype)}}else{try{throw Error()}catch(de){ue=de}(be=a())&&typeof be.catch=="function"&&be.catch(function(){})}}catch(de){if(de&&ue&&typeof de.stack=="string")return[de.stack,ue.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var v=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");v&&v.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var C=g.DetermineComponentFrameRoot(),I=C[0],O=C[1];if(I&&O){var j=I.split(`
`),le=O.split(`
`);for(v=g=0;g<j.length&&!j[g].includes("DetermineComponentFrameRoot");)g++;for(;v<le.length&&!le[v].includes("DetermineComponentFrameRoot");)v++;if(g===j.length||v===le.length)for(g=j.length-1,v=le.length-1;1<=g&&0<=v&&j[g]!==le[v];)v--;for(;1<=g&&0<=v;g--,v--)if(j[g]!==le[v]){if(g!==1||v!==1)do if(g--,v--,0>v||j[g]!==le[v]){var me=`
`+j[g].replace(" at new "," at ");return a.displayName&&me.includes("<anonymous>")&&(me=me.replace("<anonymous>",a.displayName)),me}while(1<=g&&0<=v);break}}}finally{We=!1,Error.prepareStackTrace=f}return(f=a?a.displayName||a.name:"")?Qe(f):""}function wt(a,u){switch(a.tag){case 26:case 27:case 5:return Qe(a.type);case 16:return Qe("Lazy");case 13:return a.child!==u&&u!==null?Qe("Suspense Fallback"):Qe("Suspense");case 19:return Qe("SuspenseList");case 0:case 15:return qe(a.type,!1);case 11:return qe(a.type.render,!1);case 1:return qe(a.type,!0);case 31:return Qe("Activity");default:return""}}function pt(a){try{var u="",f=null;do u+=wt(a,f),f=a,a=a.return;while(a);return u}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var Ds=Object.prototype.hasOwnProperty,Kt=n.unstable_scheduleCallback,Zs=n.unstable_cancelCallback,as=n.unstable_shouldYield,xi=n.unstable_requestPaint,Lt=n.unstable_now,Tr=n.unstable_getCurrentPriorityLevel,kr=n.unstable_ImmediatePriority,$r=n.unstable_UserBlockingPriority,Os=n.unstable_NormalPriority,ta=n.unstable_LowPriority,gl=n.unstable_IdlePriority,au=n.log,L0=n.unstable_setDisableYieldValue,qr=null,ls=null;function Kr(a){if(typeof au=="function"&&L0(a),ls&&typeof ls.setStrictMode=="function")try{ls.setStrictMode(qr,a)}catch{}}var Ms=Math.clz32?Math.clz32:iP,sP=Math.log,rP=Math.LN2;function iP(a){return a>>>=0,a===0?32:31-(sP(a)/rP|0)|0}var wf=256,Sf=262144,Cf=4194304;function na(a){var u=a&42;if(u!==0)return u;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function Tf(a,u,f){var g=a.pendingLanes;if(g===0)return 0;var v=0,C=a.suspendedLanes,I=a.pingedLanes;a=a.warmLanes;var O=g&134217727;return O!==0?(g=O&~C,g!==0?v=na(g):(I&=O,I!==0?v=na(I):f||(f=O&~a,f!==0&&(v=na(f))))):(O=g&~C,O!==0?v=na(O):I!==0?v=na(I):f||(f=g&~a,f!==0&&(v=na(f)))),v===0?0:u!==0&&u!==v&&(u&C)===0&&(C=v&-v,f=u&-u,C>=f||C===32&&(f&4194048)!==0)?u:v}function lu(a,u){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&u)===0}function oP(a,u){switch(a){case 1:case 2:case 4:case 8:case 64:return u+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function LC(){var a=Cf;return Cf<<=1,(Cf&62914560)===0&&(Cf=4194304),a}function P0(a){for(var u=[],f=0;31>f;f++)u.push(a);return u}function cu(a,u){a.pendingLanes|=u,u!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function aP(a,u,f,g,v,C){var I=a.pendingLanes;a.pendingLanes=f,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=f,a.entangledLanes&=f,a.errorRecoveryDisabledLanes&=f,a.shellSuspendCounter=0;var O=a.entanglements,j=a.expirationTimes,le=a.hiddenUpdates;for(f=I&~f;0<f;){var me=31-Ms(f),be=1<<me;O[me]=0,j[me]=-1;var ue=le[me];if(ue!==null)for(le[me]=null,me=0;me<ue.length;me++){var de=ue[me];de!==null&&(de.lane&=-536870913)}f&=~be}g!==0&&PC(a,g,0),C!==0&&v===0&&a.tag!==0&&(a.suspendedLanes|=C&~(I&~u))}function PC(a,u,f){a.pendingLanes|=u,a.suspendedLanes&=~u;var g=31-Ms(u);a.entangledLanes|=u,a.entanglements[g]=a.entanglements[g]|1073741824|f&261930}function zC(a,u){var f=a.entangledLanes|=u;for(a=a.entanglements;f;){var g=31-Ms(f),v=1<<g;v&u|a[g]&u&&(a[g]|=u),f&=~v}}function BC(a,u){var f=u&-u;return f=(f&42)!==0?1:z0(f),(f&(a.suspendedLanes|u))!==0?0:f}function z0(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function B0(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function VC(){var a=B.p;return a!==0?a:(a=window.event,a===void 0?32:$$(a.type))}function UC(a,u){var f=B.p;try{return B.p=a,u()}finally{B.p=f}}var Qi=Math.random().toString(36).slice(2),Pn="__reactFiber$"+Qi,xs="__reactProps$"+Qi,yl="__reactContainer$"+Qi,V0="__reactEvents$"+Qi,lP="__reactListeners$"+Qi,cP="__reactHandles$"+Qi,jC="__reactResources$"+Qi,uu="__reactMarker$"+Qi;function U0(a){delete a[Pn],delete a[xs],delete a[V0],delete a[lP],delete a[cP]}function bl(a){var u=a[Pn];if(u)return u;for(var f=a.parentNode;f;){if(u=f[yl]||f[Pn]){if(f=u.alternate,u.child!==null||f!==null&&f.child!==null)for(a=u$(a);a!==null;){if(f=a[Pn])return f;a=u$(a)}return u}a=f,f=a.parentNode}return null}function xl(a){if(a=a[Pn]||a[yl]){var u=a.tag;if(u===5||u===6||u===13||u===31||u===26||u===27||u===3)return a}return null}function hu(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a.stateNode;throw Error(s(33))}function vl(a){var u=a[jC];return u||(u=a[jC]={hoistableStyles:new Map,hoistableScripts:new Map}),u}function _n(a){a[uu]=!0}var GC=new Set,WC={};function sa(a,u){wl(a,u),wl(a+"Capture",u)}function wl(a,u){for(WC[a]=u,a=0;a<u.length;a++)GC.add(u[a])}var uP=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),HC={},qC={};function hP(a){return Ds.call(qC,a)?!0:Ds.call(HC,a)?!1:uP.test(a)?qC[a]=!0:(HC[a]=!0,!1)}function kf(a,u,f){if(hP(u))if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":a.removeAttribute(u);return;case"boolean":var g=u.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){a.removeAttribute(u);return}}a.setAttribute(u,""+f)}}function $f(a,u,f){if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(u);return}a.setAttribute(u,""+f)}}function vi(a,u,f,g){if(g===null)a.removeAttribute(f);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(f);return}a.setAttributeNS(u,f,""+g)}}function Qs(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function KC(a){var u=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(u==="checkbox"||u==="radio")}function dP(a,u,f){var g=Object.getOwnPropertyDescriptor(a.constructor.prototype,u);if(!a.hasOwnProperty(u)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var v=g.get,C=g.set;return Object.defineProperty(a,u,{configurable:!0,get:function(){return v.call(this)},set:function(I){f=""+I,C.call(this,I)}}),Object.defineProperty(a,u,{enumerable:g.enumerable}),{getValue:function(){return f},setValue:function(I){f=""+I},stopTracking:function(){a._valueTracker=null,delete a[u]}}}}function j0(a){if(!a._valueTracker){var u=KC(a)?"checked":"value";a._valueTracker=dP(a,u,""+a[u])}}function XC(a){if(!a)return!1;var u=a._valueTracker;if(!u)return!0;var f=u.getValue(),g="";return a&&(g=KC(a)?a.checked?"true":"false":a.value),a=g,a!==f?(u.setValue(a),!0):!1}function Ef(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var fP=/[\n"\\]/g;function er(a){return a.replace(fP,function(u){return"\\"+u.charCodeAt(0).toString(16)+" "})}function G0(a,u,f,g,v,C,I,O){a.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?a.type=I:a.removeAttribute("type"),u!=null?I==="number"?(u===0&&a.value===""||a.value!=u)&&(a.value=""+Qs(u)):a.value!==""+Qs(u)&&(a.value=""+Qs(u)):I!=="submit"&&I!=="reset"||a.removeAttribute("value"),u!=null?W0(a,I,Qs(u)):f!=null?W0(a,I,Qs(f)):g!=null&&a.removeAttribute("value"),v==null&&C!=null&&(a.defaultChecked=!!C),v!=null&&(a.checked=v&&typeof v!="function"&&typeof v!="symbol"),O!=null&&typeof O!="function"&&typeof O!="symbol"&&typeof O!="boolean"?a.name=""+Qs(O):a.removeAttribute("name")}function YC(a,u,f,g,v,C,I,O){if(C!=null&&typeof C!="function"&&typeof C!="symbol"&&typeof C!="boolean"&&(a.type=C),u!=null||f!=null){if(!(C!=="submit"&&C!=="reset"||u!=null)){j0(a);return}f=f!=null?""+Qs(f):"",u=u!=null?""+Qs(u):f,O||u===a.value||(a.value=u),a.defaultValue=u}g=g??v,g=typeof g!="function"&&typeof g!="symbol"&&!!g,a.checked=O?a.checked:!!g,a.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(a.name=I),j0(a)}function W0(a,u,f){u==="number"&&Ef(a.ownerDocument)===a||a.defaultValue===""+f||(a.defaultValue=""+f)}function Sl(a,u,f,g){if(a=a.options,u){u={};for(var v=0;v<f.length;v++)u["$"+f[v]]=!0;for(f=0;f<a.length;f++)v=u.hasOwnProperty("$"+a[f].value),a[f].selected!==v&&(a[f].selected=v),v&&g&&(a[f].defaultSelected=!0)}else{for(f=""+Qs(f),u=null,v=0;v<a.length;v++){if(a[v].value===f){a[v].selected=!0,g&&(a[v].defaultSelected=!0);return}u!==null||a[v].disabled||(u=a[v])}u!==null&&(u.selected=!0)}}function JC(a,u,f){if(u!=null&&(u=""+Qs(u),u!==a.value&&(a.value=u),f==null)){a.defaultValue!==u&&(a.defaultValue=u);return}a.defaultValue=f!=null?""+Qs(f):""}function ZC(a,u,f,g){if(u==null){if(g!=null){if(f!=null)throw Error(s(92));if(K(g)){if(1<g.length)throw Error(s(93));g=g[0]}f=g}f==null&&(f=""),u=f}f=Qs(u),a.defaultValue=f,g=a.textContent,g===f&&g!==""&&g!==null&&(a.value=g),j0(a)}function Cl(a,u){if(u){var f=a.firstChild;if(f&&f===a.lastChild&&f.nodeType===3){f.nodeValue=u;return}}a.textContent=u}var pP=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function QC(a,u,f){var g=u.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?g?a.setProperty(u,""):u==="float"?a.cssFloat="":a[u]="":g?a.setProperty(u,f):typeof f!="number"||f===0||pP.has(u)?u==="float"?a.cssFloat=f:a[u]=(""+f).trim():a[u]=f+"px"}function eT(a,u,f){if(u!=null&&typeof u!="object")throw Error(s(62));if(a=a.style,f!=null){for(var g in f)!f.hasOwnProperty(g)||u!=null&&u.hasOwnProperty(g)||(g.indexOf("--")===0?a.setProperty(g,""):g==="float"?a.cssFloat="":a[g]="");for(var v in u)g=u[v],u.hasOwnProperty(v)&&f[v]!==g&&QC(a,v,g)}else for(var C in u)u.hasOwnProperty(C)&&QC(a,C,u[C])}function H0(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var mP=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),gP=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function If(a){return gP.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function wi(){}var q0=null;function K0(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var Tl=null,kl=null;function tT(a){var u=xl(a);if(u&&(a=u.stateNode)){var f=a[xs]||null;e:switch(a=u.stateNode,u.type){case"input":if(G0(a,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),u=f.name,f.type==="radio"&&u!=null){for(f=a;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+er(""+u)+'"][type="radio"]'),u=0;u<f.length;u++){var g=f[u];if(g!==a&&g.form===a.form){var v=g[xs]||null;if(!v)throw Error(s(90));G0(g,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name)}}for(u=0;u<f.length;u++)g=f[u],g.form===a.form&&XC(g)}break e;case"textarea":JC(a,f.value,f.defaultValue);break e;case"select":u=f.value,u!=null&&Sl(a,!!f.multiple,u,!1)}}}var X0=!1;function nT(a,u,f){if(X0)return a(u,f);X0=!0;try{var g=a(u);return g}finally{if(X0=!1,(Tl!==null||kl!==null)&&(mp(),Tl&&(u=Tl,a=kl,kl=Tl=null,tT(u),a)))for(u=0;u<a.length;u++)tT(a[u])}}function du(a,u){var f=a.stateNode;if(f===null)return null;var g=f[xs]||null;if(g===null)return null;f=g[u];e:switch(u){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(a=a.type,g=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!g;break e;default:a=!1}if(a)return null;if(f&&typeof f!="function")throw Error(s(231,u,typeof f));return f}var Si=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Y0=!1;if(Si)try{var fu={};Object.defineProperty(fu,"passive",{get:function(){Y0=!0}}),window.addEventListener("test",fu,fu),window.removeEventListener("test",fu,fu)}catch{Y0=!1}var eo=null,J0=null,Nf=null;function sT(){if(Nf)return Nf;var a,u=J0,f=u.length,g,v="value"in eo?eo.value:eo.textContent,C=v.length;for(a=0;a<f&&u[a]===v[a];a++);var I=f-a;for(g=1;g<=I&&u[f-g]===v[C-g];g++);return Nf=v.slice(a,1<g?1-g:void 0)}function Af(a){var u=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&u===13&&(a=13)):a=u,a===10&&(a=13),32<=a||a===13?a:0}function _f(){return!0}function rT(){return!1}function vs(a){function u(f,g,v,C,I){this._reactName=f,this._targetInst=v,this.type=g,this.nativeEvent=C,this.target=I,this.currentTarget=null;for(var O in a)a.hasOwnProperty(O)&&(f=a[O],this[O]=f?f(C):C[O]);return this.isDefaultPrevented=(C.defaultPrevented!=null?C.defaultPrevented:C.returnValue===!1)?_f:rT,this.isPropagationStopped=rT,this}return p(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=_f)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=_f)},persist:function(){},isPersistent:_f}),u}var ra={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Rf=vs(ra),pu=p({},ra,{view:0,detail:0}),yP=vs(pu),Z0,Q0,mu,Df=p({},pu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ty,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==mu&&(mu&&a.type==="mousemove"?(Z0=a.screenX-mu.screenX,Q0=a.screenY-mu.screenY):Q0=Z0=0,mu=a),Z0)},movementY:function(a){return"movementY"in a?a.movementY:Q0}}),iT=vs(Df),bP=p({},Df,{dataTransfer:0}),xP=vs(bP),vP=p({},pu,{relatedTarget:0}),ey=vs(vP),wP=p({},ra,{animationName:0,elapsedTime:0,pseudoElement:0}),SP=vs(wP),CP=p({},ra,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),TP=vs(CP),kP=p({},ra,{data:0}),oT=vs(kP),$P={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},EP={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},IP={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function NP(a){var u=this.nativeEvent;return u.getModifierState?u.getModifierState(a):(a=IP[a])?!!u[a]:!1}function ty(){return NP}var AP=p({},pu,{key:function(a){if(a.key){var u=$P[a.key]||a.key;if(u!=="Unidentified")return u}return a.type==="keypress"?(a=Af(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?EP[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ty,charCode:function(a){return a.type==="keypress"?Af(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?Af(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),_P=vs(AP),RP=p({},Df,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),aT=vs(RP),DP=p({},pu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ty}),OP=vs(DP),MP=p({},ra,{propertyName:0,elapsedTime:0,pseudoElement:0}),FP=vs(MP),LP=p({},Df,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),PP=vs(LP),zP=p({},ra,{newState:0,oldState:0}),BP=vs(zP),VP=[9,13,27,32],ny=Si&&"CompositionEvent"in window,gu=null;Si&&"documentMode"in document&&(gu=document.documentMode);var UP=Si&&"TextEvent"in window&&!gu,lT=Si&&(!ny||gu&&8<gu&&11>=gu),cT=" ",uT=!1;function hT(a,u){switch(a){case"keyup":return VP.indexOf(u.keyCode)!==-1;case"keydown":return u.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function dT(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var $l=!1;function jP(a,u){switch(a){case"compositionend":return dT(u);case"keypress":return u.which!==32?null:(uT=!0,cT);case"textInput":return a=u.data,a===cT&&uT?null:a;default:return null}}function GP(a,u){if($l)return a==="compositionend"||!ny&&hT(a,u)?(a=sT(),Nf=J0=eo=null,$l=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(u.ctrlKey||u.altKey||u.metaKey)||u.ctrlKey&&u.altKey){if(u.char&&1<u.char.length)return u.char;if(u.which)return String.fromCharCode(u.which)}return null;case"compositionend":return lT&&u.locale!=="ko"?null:u.data;default:return null}}var WP={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function fT(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u==="input"?!!WP[a.type]:u==="textarea"}function pT(a,u,f,g){Tl?kl?kl.push(g):kl=[g]:Tl=g,u=Sp(u,"onChange"),0<u.length&&(f=new Rf("onChange","change",null,f,g),a.push({event:f,listeners:u}))}var yu=null,bu=null;function HP(a){Y2(a,0)}function Of(a){var u=hu(a);if(XC(u))return a}function mT(a,u){if(a==="change")return u}var gT=!1;if(Si){var sy;if(Si){var ry="oninput"in document;if(!ry){var yT=document.createElement("div");yT.setAttribute("oninput","return;"),ry=typeof yT.oninput=="function"}sy=ry}else sy=!1;gT=sy&&(!document.documentMode||9<document.documentMode)}function bT(){yu&&(yu.detachEvent("onpropertychange",xT),bu=yu=null)}function xT(a){if(a.propertyName==="value"&&Of(bu)){var u=[];pT(u,bu,a,K0(a)),nT(HP,u)}}function qP(a,u,f){a==="focusin"?(bT(),yu=u,bu=f,yu.attachEvent("onpropertychange",xT)):a==="focusout"&&bT()}function KP(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Of(bu)}function XP(a,u){if(a==="click")return Of(u)}function YP(a,u){if(a==="input"||a==="change")return Of(u)}function JP(a,u){return a===u&&(a!==0||1/a===1/u)||a!==a&&u!==u}var Fs=typeof Object.is=="function"?Object.is:JP;function xu(a,u){if(Fs(a,u))return!0;if(typeof a!="object"||a===null||typeof u!="object"||u===null)return!1;var f=Object.keys(a),g=Object.keys(u);if(f.length!==g.length)return!1;for(g=0;g<f.length;g++){var v=f[g];if(!Ds.call(u,v)||!Fs(a[v],u[v]))return!1}return!0}function vT(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function wT(a,u){var f=vT(a);a=0;for(var g;f;){if(f.nodeType===3){if(g=a+f.textContent.length,a<=u&&g>=u)return{node:f,offset:u-a};a=g}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=vT(f)}}function ST(a,u){return a&&u?a===u?!0:a&&a.nodeType===3?!1:u&&u.nodeType===3?ST(a,u.parentNode):"contains"in a?a.contains(u):a.compareDocumentPosition?!!(a.compareDocumentPosition(u)&16):!1:!1}function CT(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var u=Ef(a.document);u instanceof a.HTMLIFrameElement;){try{var f=typeof u.contentWindow.location.href=="string"}catch{f=!1}if(f)a=u.contentWindow;else break;u=Ef(a.document)}return u}function iy(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u&&(u==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||u==="textarea"||a.contentEditable==="true")}var ZP=Si&&"documentMode"in document&&11>=document.documentMode,El=null,oy=null,vu=null,ay=!1;function TT(a,u,f){var g=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;ay||El==null||El!==Ef(g)||(g=El,"selectionStart"in g&&iy(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),vu&&xu(vu,g)||(vu=g,g=Sp(oy,"onSelect"),0<g.length&&(u=new Rf("onSelect","select",null,u,f),a.push({event:u,listeners:g}),u.target=El)))}function ia(a,u){var f={};return f[a.toLowerCase()]=u.toLowerCase(),f["Webkit"+a]="webkit"+u,f["Moz"+a]="moz"+u,f}var Il={animationend:ia("Animation","AnimationEnd"),animationiteration:ia("Animation","AnimationIteration"),animationstart:ia("Animation","AnimationStart"),transitionrun:ia("Transition","TransitionRun"),transitionstart:ia("Transition","TransitionStart"),transitioncancel:ia("Transition","TransitionCancel"),transitionend:ia("Transition","TransitionEnd")},ly={},kT={};Si&&(kT=document.createElement("div").style,"AnimationEvent"in window||(delete Il.animationend.animation,delete Il.animationiteration.animation,delete Il.animationstart.animation),"TransitionEvent"in window||delete Il.transitionend.transition);function oa(a){if(ly[a])return ly[a];if(!Il[a])return a;var u=Il[a],f;for(f in u)if(u.hasOwnProperty(f)&&f in kT)return ly[a]=u[f];return a}var $T=oa("animationend"),ET=oa("animationiteration"),IT=oa("animationstart"),QP=oa("transitionrun"),ez=oa("transitionstart"),tz=oa("transitioncancel"),NT=oa("transitionend"),AT=new Map,cy="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");cy.push("scrollEnd");function Er(a,u){AT.set(a,u),sa(u,[a])}var Mf=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var u=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(u))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},tr=[],Nl=0,uy=0;function Ff(){for(var a=Nl,u=uy=Nl=0;u<a;){var f=tr[u];tr[u++]=null;var g=tr[u];tr[u++]=null;var v=tr[u];tr[u++]=null;var C=tr[u];if(tr[u++]=null,g!==null&&v!==null){var I=g.pending;I===null?v.next=v:(v.next=I.next,I.next=v),g.pending=v}C!==0&&_T(f,v,C)}}function Lf(a,u,f,g){tr[Nl++]=a,tr[Nl++]=u,tr[Nl++]=f,tr[Nl++]=g,uy|=g,a.lanes|=g,a=a.alternate,a!==null&&(a.lanes|=g)}function hy(a,u,f,g){return Lf(a,u,f,g),Pf(a)}function aa(a,u){return Lf(a,null,null,u),Pf(a)}function _T(a,u,f){a.lanes|=f;var g=a.alternate;g!==null&&(g.lanes|=f);for(var v=!1,C=a.return;C!==null;)C.childLanes|=f,g=C.alternate,g!==null&&(g.childLanes|=f),C.tag===22&&(a=C.stateNode,a===null||a._visibility&1||(v=!0)),a=C,C=C.return;return a.tag===3?(C=a.stateNode,v&&u!==null&&(v=31-Ms(f),a=C.hiddenUpdates,g=a[v],g===null?a[v]=[u]:g.push(u),u.lane=f|536870912),C):null}function Pf(a){if(50<Uu)throw Uu=0,vb=null,Error(s(185));for(var u=a.return;u!==null;)a=u,u=a.return;return a.tag===3?a.stateNode:null}var Al={};function nz(a,u,f,g){this.tag=a,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=u,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ls(a,u,f,g){return new nz(a,u,f,g)}function dy(a){return a=a.prototype,!(!a||!a.isReactComponent)}function Ci(a,u){var f=a.alternate;return f===null?(f=Ls(a.tag,u,a.key,a.mode),f.elementType=a.elementType,f.type=a.type,f.stateNode=a.stateNode,f.alternate=a,a.alternate=f):(f.pendingProps=u,f.type=a.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=a.flags&65011712,f.childLanes=a.childLanes,f.lanes=a.lanes,f.child=a.child,f.memoizedProps=a.memoizedProps,f.memoizedState=a.memoizedState,f.updateQueue=a.updateQueue,u=a.dependencies,f.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext},f.sibling=a.sibling,f.index=a.index,f.ref=a.ref,f.refCleanup=a.refCleanup,f}function RT(a,u){a.flags&=65011714;var f=a.alternate;return f===null?(a.childLanes=0,a.lanes=u,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=f.childLanes,a.lanes=f.lanes,a.child=f.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=f.memoizedProps,a.memoizedState=f.memoizedState,a.updateQueue=f.updateQueue,a.type=f.type,u=f.dependencies,a.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),a}function zf(a,u,f,g,v,C){var I=0;if(g=a,typeof a=="function")dy(a)&&(I=1);else if(typeof a=="string")I=aB(a,f,re.current)?26:a==="html"||a==="head"||a==="body"?27:5;else e:switch(a){case D:return a=Ls(31,f,u,v),a.elementType=D,a.lanes=C,a;case x:return la(f.children,v,C,u);case w:I=8,v|=24;break;case S:return a=Ls(12,f,u,v|2),a.elementType=S,a.lanes=C,a;case E:return a=Ls(13,f,u,v),a.elementType=E,a.lanes=C,a;case N:return a=Ls(19,f,u,v),a.elementType=N,a.lanes=C,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case k:I=10;break e;case T:I=9;break e;case $:I=11;break e;case _:I=14;break e;case R:I=16,g=null;break e}I=29,f=Error(s(130,a===null?"null":typeof a,"")),g=null}return u=Ls(I,f,u,v),u.elementType=a,u.type=g,u.lanes=C,u}function la(a,u,f,g){return a=Ls(7,a,g,u),a.lanes=f,a}function fy(a,u,f){return a=Ls(6,a,null,u),a.lanes=f,a}function DT(a){var u=Ls(18,null,null,0);return u.stateNode=a,u}function py(a,u,f){return u=Ls(4,a.children!==null?a.children:[],a.key,u),u.lanes=f,u.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},u}var OT=new WeakMap;function nr(a,u){if(typeof a=="object"&&a!==null){var f=OT.get(a);return f!==void 0?f:(u={value:a,source:u,stack:pt(u)},OT.set(a,u),u)}return{value:a,source:u,stack:pt(u)}}var _l=[],Rl=0,Bf=null,wu=0,sr=[],rr=0,to=null,Xr=1,Yr="";function Ti(a,u){_l[Rl++]=wu,_l[Rl++]=Bf,Bf=a,wu=u}function MT(a,u,f){sr[rr++]=Xr,sr[rr++]=Yr,sr[rr++]=to,to=a;var g=Xr;a=Yr;var v=32-Ms(g)-1;g&=~(1<<v),f+=1;var C=32-Ms(u)+v;if(30<C){var I=v-v%5;C=(g&(1<<I)-1).toString(32),g>>=I,v-=I,Xr=1<<32-Ms(u)+v|f<<v|g,Yr=C+a}else Xr=1<<C|f<<v|g,Yr=a}function my(a){a.return!==null&&(Ti(a,1),MT(a,1,0))}function gy(a){for(;a===Bf;)Bf=_l[--Rl],_l[Rl]=null,wu=_l[--Rl],_l[Rl]=null;for(;a===to;)to=sr[--rr],sr[rr]=null,Yr=sr[--rr],sr[rr]=null,Xr=sr[--rr],sr[rr]=null}function FT(a,u){sr[rr++]=Xr,sr[rr++]=Yr,sr[rr++]=to,Xr=u.id,Yr=u.overflow,to=a}var zn=null,Pt=null,ct=!1,no=null,ir=!1,yy=Error(s(519));function so(a){var u=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Su(nr(u,a)),yy}function LT(a){var u=a.stateNode,f=a.type,g=a.memoizedProps;switch(u[Pn]=a,u[xs]=g,f){case"dialog":ot("cancel",u),ot("close",u);break;case"iframe":case"object":case"embed":ot("load",u);break;case"video":case"audio":for(f=0;f<Gu.length;f++)ot(Gu[f],u);break;case"source":ot("error",u);break;case"img":case"image":case"link":ot("error",u),ot("load",u);break;case"details":ot("toggle",u);break;case"input":ot("invalid",u),YC(u,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":ot("invalid",u);break;case"textarea":ot("invalid",u),ZC(u,g.value,g.defaultValue,g.children)}f=g.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||u.textContent===""+f||g.suppressHydrationWarning===!0||e$(u.textContent,f)?(g.popover!=null&&(ot("beforetoggle",u),ot("toggle",u)),g.onScroll!=null&&ot("scroll",u),g.onScrollEnd!=null&&ot("scrollend",u),g.onClick!=null&&(u.onclick=wi),u=!0):u=!1,u||so(a,!0)}function PT(a){for(zn=a.return;zn;)switch(zn.tag){case 5:case 31:case 13:ir=!1;return;case 27:case 3:ir=!0;return;default:zn=zn.return}}function Dl(a){if(a!==zn)return!1;if(!ct)return PT(a),ct=!0,!1;var u=a.tag,f;if((f=u!==3&&u!==27)&&((f=u===5)&&(f=a.type,f=!(f!=="form"&&f!=="button")||Mb(a.type,a.memoizedProps)),f=!f),f&&Pt&&so(a),PT(a),u===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Pt=c$(a)}else if(u===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Pt=c$(a)}else u===27?(u=Pt,bo(a.type)?(a=Bb,Bb=null,Pt=a):Pt=u):Pt=zn?ar(a.stateNode.nextSibling):null;return!0}function ca(){Pt=zn=null,ct=!1}function by(){var a=no;return a!==null&&(Ts===null?Ts=a:Ts.push.apply(Ts,a),no=null),a}function Su(a){no===null?no=[a]:no.push(a)}var xy=F(null),ua=null,ki=null;function ro(a,u,f){Q(xy,u._currentValue),u._currentValue=f}function $i(a){a._currentValue=xy.current,V(xy)}function vy(a,u,f){for(;a!==null;){var g=a.alternate;if((a.childLanes&u)!==u?(a.childLanes|=u,g!==null&&(g.childLanes|=u)):g!==null&&(g.childLanes&u)!==u&&(g.childLanes|=u),a===f)break;a=a.return}}function wy(a,u,f,g){var v=a.child;for(v!==null&&(v.return=a);v!==null;){var C=v.dependencies;if(C!==null){var I=v.child;C=C.firstContext;e:for(;C!==null;){var O=C;C=v;for(var j=0;j<u.length;j++)if(O.context===u[j]){C.lanes|=f,O=C.alternate,O!==null&&(O.lanes|=f),vy(C.return,f,a),g||(I=null);break e}C=O.next}}else if(v.tag===18){if(I=v.return,I===null)throw Error(s(341));I.lanes|=f,C=I.alternate,C!==null&&(C.lanes|=f),vy(I,f,a),I=null}else I=v.child;if(I!==null)I.return=v;else for(I=v;I!==null;){if(I===a){I=null;break}if(v=I.sibling,v!==null){v.return=I.return,I=v;break}I=I.return}v=I}}function Ol(a,u,f,g){a=null;for(var v=u,C=!1;v!==null;){if(!C){if((v.flags&524288)!==0)C=!0;else if((v.flags&262144)!==0)break}if(v.tag===10){var I=v.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var O=v.type;Fs(v.pendingProps.value,I.value)||(a!==null?a.push(O):a=[O])}}else if(v===we.current){if(I=v.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==v.memoizedState.memoizedState&&(a!==null?a.push(Xu):a=[Xu])}v=v.return}a!==null&&wy(u,a,f,g),u.flags|=262144}function Vf(a){for(a=a.firstContext;a!==null;){if(!Fs(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function ha(a){ua=a,ki=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function Bn(a){return zT(ua,a)}function Uf(a,u){return ua===null&&ha(a),zT(a,u)}function zT(a,u){var f=u._currentValue;if(u={context:u,memoizedValue:f,next:null},ki===null){if(a===null)throw Error(s(308));ki=u,a.dependencies={lanes:0,firstContext:u},a.flags|=524288}else ki=ki.next=u;return f}var sz=typeof AbortController<"u"?AbortController:function(){var a=[],u=this.signal={aborted:!1,addEventListener:function(f,g){a.push(g)}};this.abort=function(){u.aborted=!0,a.forEach(function(f){return f()})}},rz=n.unstable_scheduleCallback,iz=n.unstable_NormalPriority,un={$$typeof:k,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Sy(){return{controller:new sz,data:new Map,refCount:0}}function Cu(a){a.refCount--,a.refCount===0&&rz(iz,function(){a.controller.abort()})}var Tu=null,Cy=0,Ml=0,Fl=null;function oz(a,u){if(Tu===null){var f=Tu=[];Cy=0,Ml=$b(),Fl={status:"pending",value:void 0,then:function(g){f.push(g)}}}return Cy++,u.then(BT,BT),u}function BT(){if(--Cy===0&&Tu!==null){Fl!==null&&(Fl.status="fulfilled");var a=Tu;Tu=null,Ml=0,Fl=null;for(var u=0;u<a.length;u++)(0,a[u])()}}function az(a,u){var f=[],g={status:"pending",value:null,reason:null,then:function(v){f.push(v)}};return a.then(function(){g.status="fulfilled",g.value=u;for(var v=0;v<f.length;v++)(0,f[v])(u)},function(v){for(g.status="rejected",g.reason=v,v=0;v<f.length;v++)(0,f[v])(void 0)}),g}var VT=P.S;P.S=function(a,u){T2=Lt(),typeof u=="object"&&u!==null&&typeof u.then=="function"&&oz(a,u),VT!==null&&VT(a,u)};var da=F(null);function Ty(){var a=da.current;return a!==null?a:_t.pooledCache}function jf(a,u){u===null?Q(da,da.current):Q(da,u.pool)}function UT(){var a=Ty();return a===null?null:{parent:un._currentValue,pool:a}}var Ll=Error(s(460)),ky=Error(s(474)),Gf=Error(s(542)),Wf={then:function(){}};function jT(a){return a=a.status,a==="fulfilled"||a==="rejected"}function GT(a,u,f){switch(f=a[f],f===void 0?a.push(u):f!==u&&(u.then(wi,wi),u=f),u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,HT(a),a;default:if(typeof u.status=="string")u.then(wi,wi);else{if(a=_t,a!==null&&100<a.shellSuspendCounter)throw Error(s(482));a=u,a.status="pending",a.then(function(g){if(u.status==="pending"){var v=u;v.status="fulfilled",v.value=g}},function(g){if(u.status==="pending"){var v=u;v.status="rejected",v.reason=g}})}switch(u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,HT(a),a}throw pa=u,Ll}}function fa(a){try{var u=a._init;return u(a._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(pa=f,Ll):f}}var pa=null;function WT(){if(pa===null)throw Error(s(459));var a=pa;return pa=null,a}function HT(a){if(a===Ll||a===Gf)throw Error(s(483))}var Pl=null,ku=0;function Hf(a){var u=ku;return ku+=1,Pl===null&&(Pl=[]),GT(Pl,a,u)}function $u(a,u){u=u.props.ref,a.ref=u!==void 0?u:null}function qf(a,u){throw u.$$typeof===m?Error(s(525)):(a=Object.prototype.toString.call(u),Error(s(31,a==="[object Object]"?"object with keys {"+Object.keys(u).join(", ")+"}":a)))}function qT(a){function u(se,q){if(a){var ae=se.deletions;ae===null?(se.deletions=[q],se.flags|=16):ae.push(q)}}function f(se,q){if(!a)return null;for(;q!==null;)u(se,q),q=q.sibling;return null}function g(se){for(var q=new Map;se!==null;)se.key!==null?q.set(se.key,se):q.set(se.index,se),se=se.sibling;return q}function v(se,q){return se=Ci(se,q),se.index=0,se.sibling=null,se}function C(se,q,ae){return se.index=ae,a?(ae=se.alternate,ae!==null?(ae=ae.index,ae<q?(se.flags|=67108866,q):ae):(se.flags|=67108866,q)):(se.flags|=1048576,q)}function I(se){return a&&se.alternate===null&&(se.flags|=67108866),se}function O(se,q,ae,ge){return q===null||q.tag!==6?(q=fy(ae,se.mode,ge),q.return=se,q):(q=v(q,ae),q.return=se,q)}function j(se,q,ae,ge){var Fe=ae.type;return Fe===x?me(se,q,ae.props.children,ge,ae.key):q!==null&&(q.elementType===Fe||typeof Fe=="object"&&Fe!==null&&Fe.$$typeof===R&&fa(Fe)===q.type)?(q=v(q,ae.props),$u(q,ae),q.return=se,q):(q=zf(ae.type,ae.key,ae.props,null,se.mode,ge),$u(q,ae),q.return=se,q)}function le(se,q,ae,ge){return q===null||q.tag!==4||q.stateNode.containerInfo!==ae.containerInfo||q.stateNode.implementation!==ae.implementation?(q=py(ae,se.mode,ge),q.return=se,q):(q=v(q,ae.children||[]),q.return=se,q)}function me(se,q,ae,ge,Fe){return q===null||q.tag!==7?(q=la(ae,se.mode,ge,Fe),q.return=se,q):(q=v(q,ae),q.return=se,q)}function be(se,q,ae){if(typeof q=="string"&&q!==""||typeof q=="number"||typeof q=="bigint")return q=fy(""+q,se.mode,ae),q.return=se,q;if(typeof q=="object"&&q!==null){switch(q.$$typeof){case y:return ae=zf(q.type,q.key,q.props,null,se.mode,ae),$u(ae,q),ae.return=se,ae;case b:return q=py(q,se.mode,ae),q.return=se,q;case R:return q=fa(q),be(se,q,ae)}if(K(q)||z(q))return q=la(q,se.mode,ae,null),q.return=se,q;if(typeof q.then=="function")return be(se,Hf(q),ae);if(q.$$typeof===k)return be(se,Uf(se,q),ae);qf(se,q)}return null}function ue(se,q,ae,ge){var Fe=q!==null?q.key:null;if(typeof ae=="string"&&ae!==""||typeof ae=="number"||typeof ae=="bigint")return Fe!==null?null:O(se,q,""+ae,ge);if(typeof ae=="object"&&ae!==null){switch(ae.$$typeof){case y:return ae.key===Fe?j(se,q,ae,ge):null;case b:return ae.key===Fe?le(se,q,ae,ge):null;case R:return ae=fa(ae),ue(se,q,ae,ge)}if(K(ae)||z(ae))return Fe!==null?null:me(se,q,ae,ge,null);if(typeof ae.then=="function")return ue(se,q,Hf(ae),ge);if(ae.$$typeof===k)return ue(se,q,Uf(se,ae),ge);qf(se,ae)}return null}function de(se,q,ae,ge,Fe){if(typeof ge=="string"&&ge!==""||typeof ge=="number"||typeof ge=="bigint")return se=se.get(ae)||null,O(q,se,""+ge,Fe);if(typeof ge=="object"&&ge!==null){switch(ge.$$typeof){case y:return se=se.get(ge.key===null?ae:ge.key)||null,j(q,se,ge,Fe);case b:return se=se.get(ge.key===null?ae:ge.key)||null,le(q,se,ge,Fe);case R:return ge=fa(ge),de(se,q,ae,ge,Fe)}if(K(ge)||z(ge))return se=se.get(ae)||null,me(q,se,ge,Fe,null);if(typeof ge.then=="function")return de(se,q,ae,Hf(ge),Fe);if(ge.$$typeof===k)return de(se,q,ae,Uf(q,ge),Fe);qf(q,ge)}return null}function Ne(se,q,ae,ge){for(var Fe=null,mt=null,Re=q,et=q=0,lt=null;Re!==null&&et<ae.length;et++){Re.index>et?(lt=Re,Re=null):lt=Re.sibling;var gt=ue(se,Re,ae[et],ge);if(gt===null){Re===null&&(Re=lt);break}a&&Re&&gt.alternate===null&&u(se,Re),q=C(gt,q,et),mt===null?Fe=gt:mt.sibling=gt,mt=gt,Re=lt}if(et===ae.length)return f(se,Re),ct&&Ti(se,et),Fe;if(Re===null){for(;et<ae.length;et++)Re=be(se,ae[et],ge),Re!==null&&(q=C(Re,q,et),mt===null?Fe=Re:mt.sibling=Re,mt=Re);return ct&&Ti(se,et),Fe}for(Re=g(Re);et<ae.length;et++)lt=de(Re,se,et,ae[et],ge),lt!==null&&(a&&lt.alternate!==null&&Re.delete(lt.key===null?et:lt.key),q=C(lt,q,et),mt===null?Fe=lt:mt.sibling=lt,mt=lt);return a&&Re.forEach(function(Co){return u(se,Co)}),ct&&Ti(se,et),Fe}function Be(se,q,ae,ge){if(ae==null)throw Error(s(151));for(var Fe=null,mt=null,Re=q,et=q=0,lt=null,gt=ae.next();Re!==null&&!gt.done;et++,gt=ae.next()){Re.index>et?(lt=Re,Re=null):lt=Re.sibling;var Co=ue(se,Re,gt.value,ge);if(Co===null){Re===null&&(Re=lt);break}a&&Re&&Co.alternate===null&&u(se,Re),q=C(Co,q,et),mt===null?Fe=Co:mt.sibling=Co,mt=Co,Re=lt}if(gt.done)return f(se,Re),ct&&Ti(se,et),Fe;if(Re===null){for(;!gt.done;et++,gt=ae.next())gt=be(se,gt.value,ge),gt!==null&&(q=C(gt,q,et),mt===null?Fe=gt:mt.sibling=gt,mt=gt);return ct&&Ti(se,et),Fe}for(Re=g(Re);!gt.done;et++,gt=ae.next())gt=de(Re,se,et,gt.value,ge),gt!==null&&(a&&gt.alternate!==null&&Re.delete(gt.key===null?et:gt.key),q=C(gt,q,et),mt===null?Fe=gt:mt.sibling=gt,mt=gt);return a&&Re.forEach(function(bB){return u(se,bB)}),ct&&Ti(se,et),Fe}function Nt(se,q,ae,ge){if(typeof ae=="object"&&ae!==null&&ae.type===x&&ae.key===null&&(ae=ae.props.children),typeof ae=="object"&&ae!==null){switch(ae.$$typeof){case y:e:{for(var Fe=ae.key;q!==null;){if(q.key===Fe){if(Fe=ae.type,Fe===x){if(q.tag===7){f(se,q.sibling),ge=v(q,ae.props.children),ge.return=se,se=ge;break e}}else if(q.elementType===Fe||typeof Fe=="object"&&Fe!==null&&Fe.$$typeof===R&&fa(Fe)===q.type){f(se,q.sibling),ge=v(q,ae.props),$u(ge,ae),ge.return=se,se=ge;break e}f(se,q);break}else u(se,q);q=q.sibling}ae.type===x?(ge=la(ae.props.children,se.mode,ge,ae.key),ge.return=se,se=ge):(ge=zf(ae.type,ae.key,ae.props,null,se.mode,ge),$u(ge,ae),ge.return=se,se=ge)}return I(se);case b:e:{for(Fe=ae.key;q!==null;){if(q.key===Fe)if(q.tag===4&&q.stateNode.containerInfo===ae.containerInfo&&q.stateNode.implementation===ae.implementation){f(se,q.sibling),ge=v(q,ae.children||[]),ge.return=se,se=ge;break e}else{f(se,q);break}else u(se,q);q=q.sibling}ge=py(ae,se.mode,ge),ge.return=se,se=ge}return I(se);case R:return ae=fa(ae),Nt(se,q,ae,ge)}if(K(ae))return Ne(se,q,ae,ge);if(z(ae)){if(Fe=z(ae),typeof Fe!="function")throw Error(s(150));return ae=Fe.call(ae),Be(se,q,ae,ge)}if(typeof ae.then=="function")return Nt(se,q,Hf(ae),ge);if(ae.$$typeof===k)return Nt(se,q,Uf(se,ae),ge);qf(se,ae)}return typeof ae=="string"&&ae!==""||typeof ae=="number"||typeof ae=="bigint"?(ae=""+ae,q!==null&&q.tag===6?(f(se,q.sibling),ge=v(q,ae),ge.return=se,se=ge):(f(se,q),ge=fy(ae,se.mode,ge),ge.return=se,se=ge),I(se)):f(se,q)}return function(se,q,ae,ge){try{ku=0;var Fe=Nt(se,q,ae,ge);return Pl=null,Fe}catch(Re){if(Re===Ll||Re===Gf)throw Re;var mt=Ls(29,Re,null,se.mode);return mt.lanes=ge,mt.return=se,mt}}}var ma=qT(!0),KT=qT(!1),io=!1;function $y(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Ey(a,u){a=a.updateQueue,u.updateQueue===a&&(u.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function oo(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function ao(a,u,f){var g=a.updateQueue;if(g===null)return null;if(g=g.shared,(vt&2)!==0){var v=g.pending;return v===null?u.next=u:(u.next=v.next,v.next=u),g.pending=u,u=Pf(a),_T(a,null,f),u}return Lf(a,g,u,f),Pf(a)}function Eu(a,u,f){if(u=u.updateQueue,u!==null&&(u=u.shared,(f&4194048)!==0)){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,zC(a,f)}}function Iy(a,u){var f=a.updateQueue,g=a.alternate;if(g!==null&&(g=g.updateQueue,f===g)){var v=null,C=null;if(f=f.firstBaseUpdate,f!==null){do{var I={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};C===null?v=C=I:C=C.next=I,f=f.next}while(f!==null);C===null?v=C=u:C=C.next=u}else v=C=u;f={baseState:g.baseState,firstBaseUpdate:v,lastBaseUpdate:C,shared:g.shared,callbacks:g.callbacks},a.updateQueue=f;return}a=f.lastBaseUpdate,a===null?f.firstBaseUpdate=u:a.next=u,f.lastBaseUpdate=u}var Ny=!1;function Iu(){if(Ny){var a=Fl;if(a!==null)throw a}}function Nu(a,u,f,g){Ny=!1;var v=a.updateQueue;io=!1;var C=v.firstBaseUpdate,I=v.lastBaseUpdate,O=v.shared.pending;if(O!==null){v.shared.pending=null;var j=O,le=j.next;j.next=null,I===null?C=le:I.next=le,I=j;var me=a.alternate;me!==null&&(me=me.updateQueue,O=me.lastBaseUpdate,O!==I&&(O===null?me.firstBaseUpdate=le:O.next=le,me.lastBaseUpdate=j))}if(C!==null){var be=v.baseState;I=0,me=le=j=null,O=C;do{var ue=O.lane&-536870913,de=ue!==O.lane;if(de?(at&ue)===ue:(g&ue)===ue){ue!==0&&ue===Ml&&(Ny=!0),me!==null&&(me=me.next={lane:0,tag:O.tag,payload:O.payload,callback:null,next:null});e:{var Ne=a,Be=O;ue=u;var Nt=f;switch(Be.tag){case 1:if(Ne=Be.payload,typeof Ne=="function"){be=Ne.call(Nt,be,ue);break e}be=Ne;break e;case 3:Ne.flags=Ne.flags&-65537|128;case 0:if(Ne=Be.payload,ue=typeof Ne=="function"?Ne.call(Nt,be,ue):Ne,ue==null)break e;be=p({},be,ue);break e;case 2:io=!0}}ue=O.callback,ue!==null&&(a.flags|=64,de&&(a.flags|=8192),de=v.callbacks,de===null?v.callbacks=[ue]:de.push(ue))}else de={lane:ue,tag:O.tag,payload:O.payload,callback:O.callback,next:null},me===null?(le=me=de,j=be):me=me.next=de,I|=ue;if(O=O.next,O===null){if(O=v.shared.pending,O===null)break;de=O,O=de.next,de.next=null,v.lastBaseUpdate=de,v.shared.pending=null}}while(!0);me===null&&(j=be),v.baseState=j,v.firstBaseUpdate=le,v.lastBaseUpdate=me,C===null&&(v.shared.lanes=0),fo|=I,a.lanes=I,a.memoizedState=be}}function XT(a,u){if(typeof a!="function")throw Error(s(191,a));a.call(u)}function YT(a,u){var f=a.callbacks;if(f!==null)for(a.callbacks=null,a=0;a<f.length;a++)XT(f[a],u)}var zl=F(null),Kf=F(0);function JT(a,u){a=Mi,Q(Kf,a),Q(zl,u),Mi=a|u.baseLanes}function Ay(){Q(Kf,Mi),Q(zl,zl.current)}function _y(){Mi=Kf.current,V(zl),V(Kf)}var Ps=F(null),or=null;function lo(a){var u=a.alternate;Q(on,on.current&1),Q(Ps,a),or===null&&(u===null||zl.current!==null||u.memoizedState!==null)&&(or=a)}function Ry(a){Q(on,on.current),Q(Ps,a),or===null&&(or=a)}function ZT(a){a.tag===22?(Q(on,on.current),Q(Ps,a),or===null&&(or=a)):co()}function co(){Q(on,on.current),Q(Ps,Ps.current)}function zs(a){V(Ps),or===a&&(or=null),V(on)}var on=F(0);function Xf(a){for(var u=a;u!==null;){if(u.tag===13){var f=u.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||Pb(f)||zb(f)))return u}else if(u.tag===19&&(u.memoizedProps.revealOrder==="forwards"||u.memoizedProps.revealOrder==="backwards"||u.memoizedProps.revealOrder==="unstable_legacy-backwards"||u.memoizedProps.revealOrder==="together")){if((u.flags&128)!==0)return u}else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return null;u=u.return}u.sibling.return=u.return,u=u.sibling}return null}var Ei=0,Je=null,Et=null,hn=null,Yf=!1,Bl=!1,ga=!1,Jf=0,Au=0,Vl=null,lz=0;function Xt(){throw Error(s(321))}function Dy(a,u){if(u===null)return!1;for(var f=0;f<u.length&&f<a.length;f++)if(!Fs(a[f],u[f]))return!1;return!0}function Oy(a,u,f,g,v,C){return Ei=C,Je=u,u.memoizedState=null,u.updateQueue=null,u.lanes=0,P.H=a===null||a.memoizedState===null?Mk:Xy,ga=!1,C=f(g,v),ga=!1,Bl&&(C=ek(u,f,g,v)),QT(a),C}function QT(a){P.H=Du;var u=Et!==null&&Et.next!==null;if(Ei=0,hn=Et=Je=null,Yf=!1,Au=0,Vl=null,u)throw Error(s(300));a===null||dn||(a=a.dependencies,a!==null&&Vf(a)&&(dn=!0))}function ek(a,u,f,g){Je=a;var v=0;do{if(Bl&&(Vl=null),Au=0,Bl=!1,25<=v)throw Error(s(301));if(v+=1,hn=Et=null,a.updateQueue!=null){var C=a.updateQueue;C.lastEffect=null,C.events=null,C.stores=null,C.memoCache!=null&&(C.memoCache.index=0)}P.H=Fk,C=u(f,g)}while(Bl);return C}function cz(){var a=P.H,u=a.useState()[0];return u=typeof u.then=="function"?_u(u):u,a=a.useState()[0],(Et!==null?Et.memoizedState:null)!==a&&(Je.flags|=1024),u}function My(){var a=Jf!==0;return Jf=0,a}function Fy(a,u,f){u.updateQueue=a.updateQueue,u.flags&=-2053,a.lanes&=~f}function Ly(a){if(Yf){for(a=a.memoizedState;a!==null;){var u=a.queue;u!==null&&(u.pending=null),a=a.next}Yf=!1}Ei=0,hn=Et=Je=null,Bl=!1,Au=Jf=0,Vl=null}function cs(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return hn===null?Je.memoizedState=hn=a:hn=hn.next=a,hn}function an(){if(Et===null){var a=Je.alternate;a=a!==null?a.memoizedState:null}else a=Et.next;var u=hn===null?Je.memoizedState:hn.next;if(u!==null)hn=u,Et=a;else{if(a===null)throw Je.alternate===null?Error(s(467)):Error(s(310));Et=a,a={memoizedState:Et.memoizedState,baseState:Et.baseState,baseQueue:Et.baseQueue,queue:Et.queue,next:null},hn===null?Je.memoizedState=hn=a:hn=hn.next=a}return hn}function Zf(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function _u(a){var u=Au;return Au+=1,Vl===null&&(Vl=[]),a=GT(Vl,a,u),u=Je,(hn===null?u.memoizedState:hn.next)===null&&(u=u.alternate,P.H=u===null||u.memoizedState===null?Mk:Xy),a}function Qf(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return _u(a);if(a.$$typeof===k)return Bn(a)}throw Error(s(438,String(a)))}function Py(a){var u=null,f=Je.updateQueue;if(f!==null&&(u=f.memoCache),u==null){var g=Je.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(u={data:g.data.map(function(v){return v.slice()}),index:0})))}if(u==null&&(u={data:[],index:0}),f===null&&(f=Zf(),Je.updateQueue=f),f.memoCache=u,f=u.data[u.index],f===void 0)for(f=u.data[u.index]=Array(a),g=0;g<a;g++)f[g]=M;return u.index++,f}function Ii(a,u){return typeof u=="function"?u(a):u}function ep(a){var u=an();return zy(u,Et,a)}function zy(a,u,f){var g=a.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=f;var v=a.baseQueue,C=g.pending;if(C!==null){if(v!==null){var I=v.next;v.next=C.next,C.next=I}u.baseQueue=v=C,g.pending=null}if(C=a.baseState,v===null)a.memoizedState=C;else{u=v.next;var O=I=null,j=null,le=u,me=!1;do{var be=le.lane&-536870913;if(be!==le.lane?(at&be)===be:(Ei&be)===be){var ue=le.revertLane;if(ue===0)j!==null&&(j=j.next={lane:0,revertLane:0,gesture:null,action:le.action,hasEagerState:le.hasEagerState,eagerState:le.eagerState,next:null}),be===Ml&&(me=!0);else if((Ei&ue)===ue){le=le.next,ue===Ml&&(me=!0);continue}else be={lane:0,revertLane:le.revertLane,gesture:null,action:le.action,hasEagerState:le.hasEagerState,eagerState:le.eagerState,next:null},j===null?(O=j=be,I=C):j=j.next=be,Je.lanes|=ue,fo|=ue;be=le.action,ga&&f(C,be),C=le.hasEagerState?le.eagerState:f(C,be)}else ue={lane:be,revertLane:le.revertLane,gesture:le.gesture,action:le.action,hasEagerState:le.hasEagerState,eagerState:le.eagerState,next:null},j===null?(O=j=ue,I=C):j=j.next=ue,Je.lanes|=be,fo|=be;le=le.next}while(le!==null&&le!==u);if(j===null?I=C:j.next=O,!Fs(C,a.memoizedState)&&(dn=!0,me&&(f=Fl,f!==null)))throw f;a.memoizedState=C,a.baseState=I,a.baseQueue=j,g.lastRenderedState=C}return v===null&&(g.lanes=0),[a.memoizedState,g.dispatch]}function By(a){var u=an(),f=u.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=a;var g=f.dispatch,v=f.pending,C=u.memoizedState;if(v!==null){f.pending=null;var I=v=v.next;do C=a(C,I.action),I=I.next;while(I!==v);Fs(C,u.memoizedState)||(dn=!0),u.memoizedState=C,u.baseQueue===null&&(u.baseState=C),f.lastRenderedState=C}return[C,g]}function tk(a,u,f){var g=Je,v=an(),C=ct;if(C){if(f===void 0)throw Error(s(407));f=f()}else f=u();var I=!Fs((Et||v).memoizedState,f);if(I&&(v.memoizedState=f,dn=!0),v=v.queue,jy(rk.bind(null,g,v,a),[a]),v.getSnapshot!==u||I||hn!==null&&hn.memoizedState.tag&1){if(g.flags|=2048,Ul(9,{destroy:void 0},sk.bind(null,g,v,f,u),null),_t===null)throw Error(s(349));C||(Ei&127)!==0||nk(g,u,f)}return f}function nk(a,u,f){a.flags|=16384,a={getSnapshot:u,value:f},u=Je.updateQueue,u===null?(u=Zf(),Je.updateQueue=u,u.stores=[a]):(f=u.stores,f===null?u.stores=[a]:f.push(a))}function sk(a,u,f,g){u.value=f,u.getSnapshot=g,ik(u)&&ok(a)}function rk(a,u,f){return f(function(){ik(u)&&ok(a)})}function ik(a){var u=a.getSnapshot;a=a.value;try{var f=u();return!Fs(a,f)}catch{return!0}}function ok(a){var u=aa(a,2);u!==null&&ks(u,a,2)}function Vy(a){var u=cs();if(typeof a=="function"){var f=a;if(a=f(),ga){Kr(!0);try{f()}finally{Kr(!1)}}}return u.memoizedState=u.baseState=a,u.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ii,lastRenderedState:a},u}function ak(a,u,f,g){return a.baseState=f,zy(a,Et,typeof g=="function"?g:Ii)}function uz(a,u,f,g,v){if(sp(a))throw Error(s(485));if(a=u.action,a!==null){var C={payload:v,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){C.listeners.push(I)}};P.T!==null?f(!0):C.isTransition=!1,g(C),f=u.pending,f===null?(C.next=u.pending=C,lk(u,C)):(C.next=f.next,u.pending=f.next=C)}}function lk(a,u){var f=u.action,g=u.payload,v=a.state;if(u.isTransition){var C=P.T,I={};P.T=I;try{var O=f(v,g),j=P.S;j!==null&&j(I,O),ck(a,u,O)}catch(le){Uy(a,u,le)}finally{C!==null&&I.types!==null&&(C.types=I.types),P.T=C}}else try{C=f(v,g),ck(a,u,C)}catch(le){Uy(a,u,le)}}function ck(a,u,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(g){uk(a,u,g)},function(g){return Uy(a,u,g)}):uk(a,u,f)}function uk(a,u,f){u.status="fulfilled",u.value=f,hk(u),a.state=f,u=a.pending,u!==null&&(f=u.next,f===u?a.pending=null:(f=f.next,u.next=f,lk(a,f)))}function Uy(a,u,f){var g=a.pending;if(a.pending=null,g!==null){g=g.next;do u.status="rejected",u.reason=f,hk(u),u=u.next;while(u!==g)}a.action=null}function hk(a){a=a.listeners;for(var u=0;u<a.length;u++)(0,a[u])()}function dk(a,u){return u}function fk(a,u){if(ct){var f=_t.formState;if(f!==null){e:{var g=Je;if(ct){if(Pt){t:{for(var v=Pt,C=ir;v.nodeType!==8;){if(!C){v=null;break t}if(v=ar(v.nextSibling),v===null){v=null;break t}}C=v.data,v=C==="F!"||C==="F"?v:null}if(v){Pt=ar(v.nextSibling),g=v.data==="F!";break e}}so(g)}g=!1}g&&(u=f[0])}}return f=cs(),f.memoizedState=f.baseState=u,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:dk,lastRenderedState:u},f.queue=g,f=Rk.bind(null,Je,g),g.dispatch=f,g=Vy(!1),C=Ky.bind(null,Je,!1,g.queue),g=cs(),v={state:u,dispatch:null,action:a,pending:null},g.queue=v,f=uz.bind(null,Je,v,C,f),v.dispatch=f,g.memoizedState=a,[u,f,!1]}function pk(a){var u=an();return mk(u,Et,a)}function mk(a,u,f){if(u=zy(a,u,dk)[0],a=ep(Ii)[0],typeof u=="object"&&u!==null&&typeof u.then=="function")try{var g=_u(u)}catch(I){throw I===Ll?Gf:I}else g=u;u=an();var v=u.queue,C=v.dispatch;return f!==u.memoizedState&&(Je.flags|=2048,Ul(9,{destroy:void 0},hz.bind(null,v,f),null)),[g,C,a]}function hz(a,u){a.action=u}function gk(a){var u=an(),f=Et;if(f!==null)return mk(u,f,a);an(),u=u.memoizedState,f=an();var g=f.queue.dispatch;return f.memoizedState=a,[u,g,!1]}function Ul(a,u,f,g){return a={tag:a,create:f,deps:g,inst:u,next:null},u=Je.updateQueue,u===null&&(u=Zf(),Je.updateQueue=u),f=u.lastEffect,f===null?u.lastEffect=a.next=a:(g=f.next,f.next=a,a.next=g,u.lastEffect=a),a}function yk(){return an().memoizedState}function tp(a,u,f,g){var v=cs();Je.flags|=a,v.memoizedState=Ul(1|u,{destroy:void 0},f,g===void 0?null:g)}function np(a,u,f,g){var v=an();g=g===void 0?null:g;var C=v.memoizedState.inst;Et!==null&&g!==null&&Dy(g,Et.memoizedState.deps)?v.memoizedState=Ul(u,C,f,g):(Je.flags|=a,v.memoizedState=Ul(1|u,C,f,g))}function bk(a,u){tp(8390656,8,a,u)}function jy(a,u){np(2048,8,a,u)}function dz(a){Je.flags|=4;var u=Je.updateQueue;if(u===null)u=Zf(),Je.updateQueue=u,u.events=[a];else{var f=u.events;f===null?u.events=[a]:f.push(a)}}function xk(a){var u=an().memoizedState;return dz({ref:u,nextImpl:a}),function(){if((vt&2)!==0)throw Error(s(440));return u.impl.apply(void 0,arguments)}}function vk(a,u){return np(4,2,a,u)}function wk(a,u){return np(4,4,a,u)}function Sk(a,u){if(typeof u=="function"){a=a();var f=u(a);return function(){typeof f=="function"?f():u(null)}}if(u!=null)return a=a(),u.current=a,function(){u.current=null}}function Ck(a,u,f){f=f!=null?f.concat([a]):null,np(4,4,Sk.bind(null,u,a),f)}function Gy(){}function Tk(a,u){var f=an();u=u===void 0?null:u;var g=f.memoizedState;return u!==null&&Dy(u,g[1])?g[0]:(f.memoizedState=[a,u],a)}function kk(a,u){var f=an();u=u===void 0?null:u;var g=f.memoizedState;if(u!==null&&Dy(u,g[1]))return g[0];if(g=a(),ga){Kr(!0);try{a()}finally{Kr(!1)}}return f.memoizedState=[g,u],g}function Wy(a,u,f){return f===void 0||(Ei&1073741824)!==0&&(at&261930)===0?a.memoizedState=u:(a.memoizedState=f,a=$2(),Je.lanes|=a,fo|=a,f)}function $k(a,u,f,g){return Fs(f,u)?f:zl.current!==null?(a=Wy(a,f,g),Fs(a,u)||(dn=!0),a):(Ei&42)===0||(Ei&1073741824)!==0&&(at&261930)===0?(dn=!0,a.memoizedState=f):(a=$2(),Je.lanes|=a,fo|=a,u)}function Ek(a,u,f,g,v){var C=B.p;B.p=C!==0&&8>C?C:8;var I=P.T,O={};P.T=O,Ky(a,!1,u,f);try{var j=v(),le=P.S;if(le!==null&&le(O,j),j!==null&&typeof j=="object"&&typeof j.then=="function"){var me=az(j,g);Ru(a,u,me,Us(a))}else Ru(a,u,g,Us(a))}catch(be){Ru(a,u,{then:function(){},status:"rejected",reason:be},Us())}finally{B.p=C,I!==null&&O.types!==null&&(I.types=O.types),P.T=I}}function fz(){}function Hy(a,u,f,g){if(a.tag!==5)throw Error(s(476));var v=Ik(a).queue;Ek(a,v,u,G,f===null?fz:function(){return Nk(a),f(g)})}function Ik(a){var u=a.memoizedState;if(u!==null)return u;u={memoizedState:G,baseState:G,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ii,lastRenderedState:G},next:null};var f={};return u.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ii,lastRenderedState:f},next:null},a.memoizedState=u,a=a.alternate,a!==null&&(a.memoizedState=u),u}function Nk(a){var u=Ik(a);u.next===null&&(u=a.alternate.memoizedState),Ru(a,u.next.queue,{},Us())}function qy(){return Bn(Xu)}function Ak(){return an().memoizedState}function _k(){return an().memoizedState}function pz(a){for(var u=a.return;u!==null;){switch(u.tag){case 24:case 3:var f=Us();a=oo(f);var g=ao(u,a,f);g!==null&&(ks(g,u,f),Eu(g,u,f)),u={cache:Sy()},a.payload=u;return}u=u.return}}function mz(a,u,f){var g=Us();f={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},sp(a)?Dk(u,f):(f=hy(a,u,f,g),f!==null&&(ks(f,a,g),Ok(f,u,g)))}function Rk(a,u,f){var g=Us();Ru(a,u,f,g)}function Ru(a,u,f,g){var v={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(sp(a))Dk(u,v);else{var C=a.alternate;if(a.lanes===0&&(C===null||C.lanes===0)&&(C=u.lastRenderedReducer,C!==null))try{var I=u.lastRenderedState,O=C(I,f);if(v.hasEagerState=!0,v.eagerState=O,Fs(O,I))return Lf(a,u,v,0),_t===null&&Ff(),!1}catch{}if(f=hy(a,u,v,g),f!==null)return ks(f,a,g),Ok(f,u,g),!0}return!1}function Ky(a,u,f,g){if(g={lane:2,revertLane:$b(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},sp(a)){if(u)throw Error(s(479))}else u=hy(a,f,g,2),u!==null&&ks(u,a,2)}function sp(a){var u=a.alternate;return a===Je||u!==null&&u===Je}function Dk(a,u){Bl=Yf=!0;var f=a.pending;f===null?u.next=u:(u.next=f.next,f.next=u),a.pending=u}function Ok(a,u,f){if((f&4194048)!==0){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,zC(a,f)}}var Du={readContext:Bn,use:Qf,useCallback:Xt,useContext:Xt,useEffect:Xt,useImperativeHandle:Xt,useLayoutEffect:Xt,useInsertionEffect:Xt,useMemo:Xt,useReducer:Xt,useRef:Xt,useState:Xt,useDebugValue:Xt,useDeferredValue:Xt,useTransition:Xt,useSyncExternalStore:Xt,useId:Xt,useHostTransitionStatus:Xt,useFormState:Xt,useActionState:Xt,useOptimistic:Xt,useMemoCache:Xt,useCacheRefresh:Xt};Du.useEffectEvent=Xt;var Mk={readContext:Bn,use:Qf,useCallback:function(a,u){return cs().memoizedState=[a,u===void 0?null:u],a},useContext:Bn,useEffect:bk,useImperativeHandle:function(a,u,f){f=f!=null?f.concat([a]):null,tp(4194308,4,Sk.bind(null,u,a),f)},useLayoutEffect:function(a,u){return tp(4194308,4,a,u)},useInsertionEffect:function(a,u){tp(4,2,a,u)},useMemo:function(a,u){var f=cs();u=u===void 0?null:u;var g=a();if(ga){Kr(!0);try{a()}finally{Kr(!1)}}return f.memoizedState=[g,u],g},useReducer:function(a,u,f){var g=cs();if(f!==void 0){var v=f(u);if(ga){Kr(!0);try{f(u)}finally{Kr(!1)}}}else v=u;return g.memoizedState=g.baseState=v,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:v},g.queue=a,a=a.dispatch=mz.bind(null,Je,a),[g.memoizedState,a]},useRef:function(a){var u=cs();return a={current:a},u.memoizedState=a},useState:function(a){a=Vy(a);var u=a.queue,f=Rk.bind(null,Je,u);return u.dispatch=f,[a.memoizedState,f]},useDebugValue:Gy,useDeferredValue:function(a,u){var f=cs();return Wy(f,a,u)},useTransition:function(){var a=Vy(!1);return a=Ek.bind(null,Je,a.queue,!0,!1),cs().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,u,f){var g=Je,v=cs();if(ct){if(f===void 0)throw Error(s(407));f=f()}else{if(f=u(),_t===null)throw Error(s(349));(at&127)!==0||nk(g,u,f)}v.memoizedState=f;var C={value:f,getSnapshot:u};return v.queue=C,bk(rk.bind(null,g,C,a),[a]),g.flags|=2048,Ul(9,{destroy:void 0},sk.bind(null,g,C,f,u),null),f},useId:function(){var a=cs(),u=_t.identifierPrefix;if(ct){var f=Yr,g=Xr;f=(g&~(1<<32-Ms(g)-1)).toString(32)+f,u="_"+u+"R_"+f,f=Jf++,0<f&&(u+="H"+f.toString(32)),u+="_"}else f=lz++,u="_"+u+"r_"+f.toString(32)+"_";return a.memoizedState=u},useHostTransitionStatus:qy,useFormState:fk,useActionState:fk,useOptimistic:function(a){var u=cs();u.memoizedState=u.baseState=a;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return u.queue=f,u=Ky.bind(null,Je,!0,f),f.dispatch=u,[a,u]},useMemoCache:Py,useCacheRefresh:function(){return cs().memoizedState=pz.bind(null,Je)},useEffectEvent:function(a){var u=cs(),f={impl:a};return u.memoizedState=f,function(){if((vt&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},Xy={readContext:Bn,use:Qf,useCallback:Tk,useContext:Bn,useEffect:jy,useImperativeHandle:Ck,useInsertionEffect:vk,useLayoutEffect:wk,useMemo:kk,useReducer:ep,useRef:yk,useState:function(){return ep(Ii)},useDebugValue:Gy,useDeferredValue:function(a,u){var f=an();return $k(f,Et.memoizedState,a,u)},useTransition:function(){var a=ep(Ii)[0],u=an().memoizedState;return[typeof a=="boolean"?a:_u(a),u]},useSyncExternalStore:tk,useId:Ak,useHostTransitionStatus:qy,useFormState:pk,useActionState:pk,useOptimistic:function(a,u){var f=an();return ak(f,Et,a,u)},useMemoCache:Py,useCacheRefresh:_k};Xy.useEffectEvent=xk;var Fk={readContext:Bn,use:Qf,useCallback:Tk,useContext:Bn,useEffect:jy,useImperativeHandle:Ck,useInsertionEffect:vk,useLayoutEffect:wk,useMemo:kk,useReducer:By,useRef:yk,useState:function(){return By(Ii)},useDebugValue:Gy,useDeferredValue:function(a,u){var f=an();return Et===null?Wy(f,a,u):$k(f,Et.memoizedState,a,u)},useTransition:function(){var a=By(Ii)[0],u=an().memoizedState;return[typeof a=="boolean"?a:_u(a),u]},useSyncExternalStore:tk,useId:Ak,useHostTransitionStatus:qy,useFormState:gk,useActionState:gk,useOptimistic:function(a,u){var f=an();return Et!==null?ak(f,Et,a,u):(f.baseState=a,[a,f.queue.dispatch])},useMemoCache:Py,useCacheRefresh:_k};Fk.useEffectEvent=xk;function Yy(a,u,f,g){u=a.memoizedState,f=f(g,u),f=f==null?u:p({},u,f),a.memoizedState=f,a.lanes===0&&(a.updateQueue.baseState=f)}var Jy={enqueueSetState:function(a,u,f){a=a._reactInternals;var g=Us(),v=oo(g);v.payload=u,f!=null&&(v.callback=f),u=ao(a,v,g),u!==null&&(ks(u,a,g),Eu(u,a,g))},enqueueReplaceState:function(a,u,f){a=a._reactInternals;var g=Us(),v=oo(g);v.tag=1,v.payload=u,f!=null&&(v.callback=f),u=ao(a,v,g),u!==null&&(ks(u,a,g),Eu(u,a,g))},enqueueForceUpdate:function(a,u){a=a._reactInternals;var f=Us(),g=oo(f);g.tag=2,u!=null&&(g.callback=u),u=ao(a,g,f),u!==null&&(ks(u,a,f),Eu(u,a,f))}};function Lk(a,u,f,g,v,C,I){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(g,C,I):u.prototype&&u.prototype.isPureReactComponent?!xu(f,g)||!xu(v,C):!0}function Pk(a,u,f,g){a=u.state,typeof u.componentWillReceiveProps=="function"&&u.componentWillReceiveProps(f,g),typeof u.UNSAFE_componentWillReceiveProps=="function"&&u.UNSAFE_componentWillReceiveProps(f,g),u.state!==a&&Jy.enqueueReplaceState(u,u.state,null)}function ya(a,u){var f=u;if("ref"in u){f={};for(var g in u)g!=="ref"&&(f[g]=u[g])}if(a=a.defaultProps){f===u&&(f=p({},f));for(var v in a)f[v]===void 0&&(f[v]=a[v])}return f}function zk(a){Mf(a)}function Bk(a){console.error(a)}function Vk(a){Mf(a)}function rp(a,u){try{var f=a.onUncaughtError;f(u.value,{componentStack:u.stack})}catch(g){setTimeout(function(){throw g})}}function Uk(a,u,f){try{var g=a.onCaughtError;g(f.value,{componentStack:f.stack,errorBoundary:u.tag===1?u.stateNode:null})}catch(v){setTimeout(function(){throw v})}}function Zy(a,u,f){return f=oo(f),f.tag=3,f.payload={element:null},f.callback=function(){rp(a,u)},f}function jk(a){return a=oo(a),a.tag=3,a}function Gk(a,u,f,g){var v=f.type.getDerivedStateFromError;if(typeof v=="function"){var C=g.value;a.payload=function(){return v(C)},a.callback=function(){Uk(u,f,g)}}var I=f.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(a.callback=function(){Uk(u,f,g),typeof v!="function"&&(po===null?po=new Set([this]):po.add(this));var O=g.stack;this.componentDidCatch(g.value,{componentStack:O!==null?O:""})})}function gz(a,u,f,g,v){if(f.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(u=f.alternate,u!==null&&Ol(u,f,v,!0),f=Ps.current,f!==null){switch(f.tag){case 31:case 13:return or===null?gp():f.alternate===null&&Yt===0&&(Yt=3),f.flags&=-257,f.flags|=65536,f.lanes=v,g===Wf?f.flags|=16384:(u=f.updateQueue,u===null?f.updateQueue=new Set([g]):u.add(g),Cb(a,g,v)),!1;case 22:return f.flags|=65536,g===Wf?f.flags|=16384:(u=f.updateQueue,u===null?(u={transitions:null,markerInstances:null,retryQueue:new Set([g])},f.updateQueue=u):(f=u.retryQueue,f===null?u.retryQueue=new Set([g]):f.add(g)),Cb(a,g,v)),!1}throw Error(s(435,f.tag))}return Cb(a,g,v),gp(),!1}if(ct)return u=Ps.current,u!==null?((u.flags&65536)===0&&(u.flags|=256),u.flags|=65536,u.lanes=v,g!==yy&&(a=Error(s(422),{cause:g}),Su(nr(a,f)))):(g!==yy&&(u=Error(s(423),{cause:g}),Su(nr(u,f))),a=a.current.alternate,a.flags|=65536,v&=-v,a.lanes|=v,g=nr(g,f),v=Zy(a.stateNode,g,v),Iy(a,v),Yt!==4&&(Yt=2)),!1;var C=Error(s(520),{cause:g});if(C=nr(C,f),Vu===null?Vu=[C]:Vu.push(C),Yt!==4&&(Yt=2),u===null)return!0;g=nr(g,f),f=u;do{switch(f.tag){case 3:return f.flags|=65536,a=v&-v,f.lanes|=a,a=Zy(f.stateNode,g,a),Iy(f,a),!1;case 1:if(u=f.type,C=f.stateNode,(f.flags&128)===0&&(typeof u.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(po===null||!po.has(C))))return f.flags|=65536,v&=-v,f.lanes|=v,v=jk(v),Gk(v,a,f,g),Iy(f,v),!1}f=f.return}while(f!==null);return!1}var Qy=Error(s(461)),dn=!1;function Vn(a,u,f,g){u.child=a===null?KT(u,null,f,g):ma(u,a.child,f,g)}function Wk(a,u,f,g,v){f=f.render;var C=u.ref;if("ref"in g){var I={};for(var O in g)O!=="ref"&&(I[O]=g[O])}else I=g;return ha(u),g=Oy(a,u,f,I,C,v),O=My(),a!==null&&!dn?(Fy(a,u,v),Ni(a,u,v)):(ct&&O&&my(u),u.flags|=1,Vn(a,u,g,v),u.child)}function Hk(a,u,f,g,v){if(a===null){var C=f.type;return typeof C=="function"&&!dy(C)&&C.defaultProps===void 0&&f.compare===null?(u.tag=15,u.type=C,qk(a,u,C,g,v)):(a=zf(f.type,null,g,u,u.mode,v),a.ref=u.ref,a.return=u,u.child=a)}if(C=a.child,!ab(a,v)){var I=C.memoizedProps;if(f=f.compare,f=f!==null?f:xu,f(I,g)&&a.ref===u.ref)return Ni(a,u,v)}return u.flags|=1,a=Ci(C,g),a.ref=u.ref,a.return=u,u.child=a}function qk(a,u,f,g,v){if(a!==null){var C=a.memoizedProps;if(xu(C,g)&&a.ref===u.ref)if(dn=!1,u.pendingProps=g=C,ab(a,v))(a.flags&131072)!==0&&(dn=!0);else return u.lanes=a.lanes,Ni(a,u,v)}return eb(a,u,f,g,v)}function Kk(a,u,f,g){var v=g.children,C=a!==null?a.memoizedState:null;if(a===null&&u.stateNode===null&&(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((u.flags&128)!==0){if(C=C!==null?C.baseLanes|f:f,a!==null){for(g=u.child=a.child,v=0;g!==null;)v=v|g.lanes|g.childLanes,g=g.sibling;g=v&~C}else g=0,u.child=null;return Xk(a,u,C,f,g)}if((f&536870912)!==0)u.memoizedState={baseLanes:0,cachePool:null},a!==null&&jf(u,C!==null?C.cachePool:null),C!==null?JT(u,C):Ay(),ZT(u);else return g=u.lanes=536870912,Xk(a,u,C!==null?C.baseLanes|f:f,f,g)}else C!==null?(jf(u,C.cachePool),JT(u,C),co(),u.memoizedState=null):(a!==null&&jf(u,null),Ay(),co());return Vn(a,u,v,f),u.child}function Ou(a,u){return a!==null&&a.tag===22||u.stateNode!==null||(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),u.sibling}function Xk(a,u,f,g,v){var C=Ty();return C=C===null?null:{parent:un._currentValue,pool:C},u.memoizedState={baseLanes:f,cachePool:C},a!==null&&jf(u,null),Ay(),ZT(u),a!==null&&Ol(a,u,g,!0),u.childLanes=v,null}function ip(a,u){return u=ap({mode:u.mode,children:u.children},a.mode),u.ref=a.ref,a.child=u,u.return=a,u}function Yk(a,u,f){return ma(u,a.child,null,f),a=ip(u,u.pendingProps),a.flags|=2,zs(u),u.memoizedState=null,a}function yz(a,u,f){var g=u.pendingProps,v=(u.flags&128)!==0;if(u.flags&=-129,a===null){if(ct){if(g.mode==="hidden")return a=ip(u,g),u.lanes=536870912,Ou(null,a);if(Ry(u),(a=Pt)?(a=l$(a,ir),a=a!==null&&a.data==="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:to!==null?{id:Xr,overflow:Yr}:null,retryLane:536870912,hydrationErrors:null},f=DT(a),f.return=u,u.child=f,zn=u,Pt=null)):a=null,a===null)throw so(u);return u.lanes=536870912,null}return ip(u,g)}var C=a.memoizedState;if(C!==null){var I=C.dehydrated;if(Ry(u),v)if(u.flags&256)u.flags&=-257,u=Yk(a,u,f);else if(u.memoizedState!==null)u.child=a.child,u.flags|=128,u=null;else throw Error(s(558));else if(dn||Ol(a,u,f,!1),v=(f&a.childLanes)!==0,dn||v){if(g=_t,g!==null&&(I=BC(g,f),I!==0&&I!==C.retryLane))throw C.retryLane=I,aa(a,I),ks(g,a,I),Qy;gp(),u=Yk(a,u,f)}else a=C.treeContext,Pt=ar(I.nextSibling),zn=u,ct=!0,no=null,ir=!1,a!==null&&FT(u,a),u=ip(u,g),u.flags|=4096;return u}return a=Ci(a.child,{mode:g.mode,children:g.children}),a.ref=u.ref,u.child=a,a.return=u,a}function op(a,u){var f=u.ref;if(f===null)a!==null&&a.ref!==null&&(u.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(a===null||a.ref!==f)&&(u.flags|=4194816)}}function eb(a,u,f,g,v){return ha(u),f=Oy(a,u,f,g,void 0,v),g=My(),a!==null&&!dn?(Fy(a,u,v),Ni(a,u,v)):(ct&&g&&my(u),u.flags|=1,Vn(a,u,f,v),u.child)}function Jk(a,u,f,g,v,C){return ha(u),u.updateQueue=null,f=ek(u,g,f,v),QT(a),g=My(),a!==null&&!dn?(Fy(a,u,C),Ni(a,u,C)):(ct&&g&&my(u),u.flags|=1,Vn(a,u,f,C),u.child)}function Zk(a,u,f,g,v){if(ha(u),u.stateNode===null){var C=Al,I=f.contextType;typeof I=="object"&&I!==null&&(C=Bn(I)),C=new f(g,C),u.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,C.updater=Jy,u.stateNode=C,C._reactInternals=u,C=u.stateNode,C.props=g,C.state=u.memoizedState,C.refs={},$y(u),I=f.contextType,C.context=typeof I=="object"&&I!==null?Bn(I):Al,C.state=u.memoizedState,I=f.getDerivedStateFromProps,typeof I=="function"&&(Yy(u,f,I,g),C.state=u.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(I=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),I!==C.state&&Jy.enqueueReplaceState(C,C.state,null),Nu(u,g,C,v),Iu(),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!0}else if(a===null){C=u.stateNode;var O=u.memoizedProps,j=ya(f,O);C.props=j;var le=C.context,me=f.contextType;I=Al,typeof me=="object"&&me!==null&&(I=Bn(me));var be=f.getDerivedStateFromProps;me=typeof be=="function"||typeof C.getSnapshotBeforeUpdate=="function",O=u.pendingProps!==O,me||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(O||le!==I)&&Pk(u,C,g,I),io=!1;var ue=u.memoizedState;C.state=ue,Nu(u,g,C,v),Iu(),le=u.memoizedState,O||ue!==le||io?(typeof be=="function"&&(Yy(u,f,be,g),le=u.memoizedState),(j=io||Lk(u,f,j,g,ue,le,I))?(me||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount()),typeof C.componentDidMount=="function"&&(u.flags|=4194308)):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),u.memoizedProps=g,u.memoizedState=le),C.props=g,C.state=le,C.context=I,g=j):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!1)}else{C=u.stateNode,Ey(a,u),I=u.memoizedProps,me=ya(f,I),C.props=me,be=u.pendingProps,ue=C.context,le=f.contextType,j=Al,typeof le=="object"&&le!==null&&(j=Bn(le)),O=f.getDerivedStateFromProps,(le=typeof O=="function"||typeof C.getSnapshotBeforeUpdate=="function")||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(I!==be||ue!==j)&&Pk(u,C,g,j),io=!1,ue=u.memoizedState,C.state=ue,Nu(u,g,C,v),Iu();var de=u.memoizedState;I!==be||ue!==de||io||a!==null&&a.dependencies!==null&&Vf(a.dependencies)?(typeof O=="function"&&(Yy(u,f,O,g),de=u.memoizedState),(me=io||Lk(u,f,me,g,ue,de,j)||a!==null&&a.dependencies!==null&&Vf(a.dependencies))?(le||typeof C.UNSAFE_componentWillUpdate!="function"&&typeof C.componentWillUpdate!="function"||(typeof C.componentWillUpdate=="function"&&C.componentWillUpdate(g,de,j),typeof C.UNSAFE_componentWillUpdate=="function"&&C.UNSAFE_componentWillUpdate(g,de,j)),typeof C.componentDidUpdate=="function"&&(u.flags|=4),typeof C.getSnapshotBeforeUpdate=="function"&&(u.flags|=1024)):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&ue===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&ue===a.memoizedState||(u.flags|=1024),u.memoizedProps=g,u.memoizedState=de),C.props=g,C.state=de,C.context=j,g=me):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&ue===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&ue===a.memoizedState||(u.flags|=1024),g=!1)}return C=g,op(a,u),g=(u.flags&128)!==0,C||g?(C=u.stateNode,f=g&&typeof f.getDerivedStateFromError!="function"?null:C.render(),u.flags|=1,a!==null&&g?(u.child=ma(u,a.child,null,v),u.child=ma(u,null,f,v)):Vn(a,u,f,v),u.memoizedState=C.state,a=u.child):a=Ni(a,u,v),a}function Qk(a,u,f,g){return ca(),u.flags|=256,Vn(a,u,f,g),u.child}var tb={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function nb(a){return{baseLanes:a,cachePool:UT()}}function sb(a,u,f){return a=a!==null?a.childLanes&~f:0,u&&(a|=Vs),a}function e2(a,u,f){var g=u.pendingProps,v=!1,C=(u.flags&128)!==0,I;if((I=C)||(I=a!==null&&a.memoizedState===null?!1:(on.current&2)!==0),I&&(v=!0,u.flags&=-129),I=(u.flags&32)!==0,u.flags&=-33,a===null){if(ct){if(v?lo(u):co(),(a=Pt)?(a=l$(a,ir),a=a!==null&&a.data!=="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:to!==null?{id:Xr,overflow:Yr}:null,retryLane:536870912,hydrationErrors:null},f=DT(a),f.return=u,u.child=f,zn=u,Pt=null)):a=null,a===null)throw so(u);return zb(a)?u.lanes=32:u.lanes=536870912,null}var O=g.children;return g=g.fallback,v?(co(),v=u.mode,O=ap({mode:"hidden",children:O},v),g=la(g,v,f,null),O.return=u,g.return=u,O.sibling=g,u.child=O,g=u.child,g.memoizedState=nb(f),g.childLanes=sb(a,I,f),u.memoizedState=tb,Ou(null,g)):(lo(u),rb(u,O))}var j=a.memoizedState;if(j!==null&&(O=j.dehydrated,O!==null)){if(C)u.flags&256?(lo(u),u.flags&=-257,u=ib(a,u,f)):u.memoizedState!==null?(co(),u.child=a.child,u.flags|=128,u=null):(co(),O=g.fallback,v=u.mode,g=ap({mode:"visible",children:g.children},v),O=la(O,v,f,null),O.flags|=2,g.return=u,O.return=u,g.sibling=O,u.child=g,ma(u,a.child,null,f),g=u.child,g.memoizedState=nb(f),g.childLanes=sb(a,I,f),u.memoizedState=tb,u=Ou(null,g));else if(lo(u),zb(O)){if(I=O.nextSibling&&O.nextSibling.dataset,I)var le=I.dgst;I=le,g=Error(s(419)),g.stack="",g.digest=I,Su({value:g,source:null,stack:null}),u=ib(a,u,f)}else if(dn||Ol(a,u,f,!1),I=(f&a.childLanes)!==0,dn||I){if(I=_t,I!==null&&(g=BC(I,f),g!==0&&g!==j.retryLane))throw j.retryLane=g,aa(a,g),ks(I,a,g),Qy;Pb(O)||gp(),u=ib(a,u,f)}else Pb(O)?(u.flags|=192,u.child=a.child,u=null):(a=j.treeContext,Pt=ar(O.nextSibling),zn=u,ct=!0,no=null,ir=!1,a!==null&&FT(u,a),u=rb(u,g.children),u.flags|=4096);return u}return v?(co(),O=g.fallback,v=u.mode,j=a.child,le=j.sibling,g=Ci(j,{mode:"hidden",children:g.children}),g.subtreeFlags=j.subtreeFlags&65011712,le!==null?O=Ci(le,O):(O=la(O,v,f,null),O.flags|=2),O.return=u,g.return=u,g.sibling=O,u.child=g,Ou(null,g),g=u.child,O=a.child.memoizedState,O===null?O=nb(f):(v=O.cachePool,v!==null?(j=un._currentValue,v=v.parent!==j?{parent:j,pool:j}:v):v=UT(),O={baseLanes:O.baseLanes|f,cachePool:v}),g.memoizedState=O,g.childLanes=sb(a,I,f),u.memoizedState=tb,Ou(a.child,g)):(lo(u),f=a.child,a=f.sibling,f=Ci(f,{mode:"visible",children:g.children}),f.return=u,f.sibling=null,a!==null&&(I=u.deletions,I===null?(u.deletions=[a],u.flags|=16):I.push(a)),u.child=f,u.memoizedState=null,f)}function rb(a,u){return u=ap({mode:"visible",children:u},a.mode),u.return=a,a.child=u}function ap(a,u){return a=Ls(22,a,null,u),a.lanes=0,a}function ib(a,u,f){return ma(u,a.child,null,f),a=rb(u,u.pendingProps.children),a.flags|=2,u.memoizedState=null,a}function t2(a,u,f){a.lanes|=u;var g=a.alternate;g!==null&&(g.lanes|=u),vy(a.return,u,f)}function ob(a,u,f,g,v,C){var I=a.memoizedState;I===null?a.memoizedState={isBackwards:u,rendering:null,renderingStartTime:0,last:g,tail:f,tailMode:v,treeForkCount:C}:(I.isBackwards=u,I.rendering=null,I.renderingStartTime=0,I.last=g,I.tail=f,I.tailMode=v,I.treeForkCount=C)}function n2(a,u,f){var g=u.pendingProps,v=g.revealOrder,C=g.tail;g=g.children;var I=on.current,O=(I&2)!==0;if(O?(I=I&1|2,u.flags|=128):I&=1,Q(on,I),Vn(a,u,g,f),g=ct?wu:0,!O&&a!==null&&(a.flags&128)!==0)e:for(a=u.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&t2(a,f,u);else if(a.tag===19)t2(a,f,u);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===u)break e;for(;a.sibling===null;){if(a.return===null||a.return===u)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(v){case"forwards":for(f=u.child,v=null;f!==null;)a=f.alternate,a!==null&&Xf(a)===null&&(v=f),f=f.sibling;f=v,f===null?(v=u.child,u.child=null):(v=f.sibling,f.sibling=null),ob(u,!1,v,f,C,g);break;case"backwards":case"unstable_legacy-backwards":for(f=null,v=u.child,u.child=null;v!==null;){if(a=v.alternate,a!==null&&Xf(a)===null){u.child=v;break}a=v.sibling,v.sibling=f,f=v,v=a}ob(u,!0,f,null,C,g);break;case"together":ob(u,!1,null,null,void 0,g);break;default:u.memoizedState=null}return u.child}function Ni(a,u,f){if(a!==null&&(u.dependencies=a.dependencies),fo|=u.lanes,(f&u.childLanes)===0)if(a!==null){if(Ol(a,u,f,!1),(f&u.childLanes)===0)return null}else return null;if(a!==null&&u.child!==a.child)throw Error(s(153));if(u.child!==null){for(a=u.child,f=Ci(a,a.pendingProps),u.child=f,f.return=u;a.sibling!==null;)a=a.sibling,f=f.sibling=Ci(a,a.pendingProps),f.return=u;f.sibling=null}return u.child}function ab(a,u){return(a.lanes&u)!==0?!0:(a=a.dependencies,!!(a!==null&&Vf(a)))}function bz(a,u,f){switch(u.tag){case 3:Ie(u,u.stateNode.containerInfo),ro(u,un,a.memoizedState.cache),ca();break;case 27:case 5:Pe(u);break;case 4:Ie(u,u.stateNode.containerInfo);break;case 10:ro(u,u.type,u.memoizedProps.value);break;case 31:if(u.memoizedState!==null)return u.flags|=128,Ry(u),null;break;case 13:var g=u.memoizedState;if(g!==null)return g.dehydrated!==null?(lo(u),u.flags|=128,null):(f&u.child.childLanes)!==0?e2(a,u,f):(lo(u),a=Ni(a,u,f),a!==null?a.sibling:null);lo(u);break;case 19:var v=(a.flags&128)!==0;if(g=(f&u.childLanes)!==0,g||(Ol(a,u,f,!1),g=(f&u.childLanes)!==0),v){if(g)return n2(a,u,f);u.flags|=128}if(v=u.memoizedState,v!==null&&(v.rendering=null,v.tail=null,v.lastEffect=null),Q(on,on.current),g)break;return null;case 22:return u.lanes=0,Kk(a,u,f,u.pendingProps);case 24:ro(u,un,a.memoizedState.cache)}return Ni(a,u,f)}function s2(a,u,f){if(a!==null)if(a.memoizedProps!==u.pendingProps)dn=!0;else{if(!ab(a,f)&&(u.flags&128)===0)return dn=!1,bz(a,u,f);dn=(a.flags&131072)!==0}else dn=!1,ct&&(u.flags&1048576)!==0&&MT(u,wu,u.index);switch(u.lanes=0,u.tag){case 16:e:{var g=u.pendingProps;if(a=fa(u.elementType),u.type=a,typeof a=="function")dy(a)?(g=ya(a,g),u.tag=1,u=Zk(null,u,a,g,f)):(u.tag=0,u=eb(null,u,a,g,f));else{if(a!=null){var v=a.$$typeof;if(v===$){u.tag=11,u=Wk(null,u,a,g,f);break e}else if(v===_){u.tag=14,u=Hk(null,u,a,g,f);break e}}throw u=Y(a)||a,Error(s(306,u,""))}}return u;case 0:return eb(a,u,u.type,u.pendingProps,f);case 1:return g=u.type,v=ya(g,u.pendingProps),Zk(a,u,g,v,f);case 3:e:{if(Ie(u,u.stateNode.containerInfo),a===null)throw Error(s(387));g=u.pendingProps;var C=u.memoizedState;v=C.element,Ey(a,u),Nu(u,g,null,f);var I=u.memoizedState;if(g=I.cache,ro(u,un,g),g!==C.cache&&wy(u,[un],f,!0),Iu(),g=I.element,C.isDehydrated)if(C={element:g,isDehydrated:!1,cache:I.cache},u.updateQueue.baseState=C,u.memoizedState=C,u.flags&256){u=Qk(a,u,g,f);break e}else if(g!==v){v=nr(Error(s(424)),u),Su(v),u=Qk(a,u,g,f);break e}else for(a=u.stateNode.containerInfo,a.nodeType===9?a=a.body:a=a.nodeName==="HTML"?a.ownerDocument.body:a,Pt=ar(a.firstChild),zn=u,ct=!0,no=null,ir=!0,f=KT(u,null,g,f),u.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(ca(),g===v){u=Ni(a,u,f);break e}Vn(a,u,g,f)}u=u.child}return u;case 26:return op(a,u),a===null?(f=p$(u.type,null,u.pendingProps,null))?u.memoizedState=f:ct||(f=u.type,a=u.pendingProps,g=Cp(ye.current).createElement(f),g[Pn]=u,g[xs]=a,Un(g,f,a),_n(g),u.stateNode=g):u.memoizedState=p$(u.type,a.memoizedProps,u.pendingProps,a.memoizedState),null;case 27:return Pe(u),a===null&&ct&&(g=u.stateNode=h$(u.type,u.pendingProps,ye.current),zn=u,ir=!0,v=Pt,bo(u.type)?(Bb=v,Pt=ar(g.firstChild)):Pt=v),Vn(a,u,u.pendingProps.children,f),op(a,u),a===null&&(u.flags|=4194304),u.child;case 5:return a===null&&ct&&((v=g=Pt)&&(g=Kz(g,u.type,u.pendingProps,ir),g!==null?(u.stateNode=g,zn=u,Pt=ar(g.firstChild),ir=!1,v=!0):v=!1),v||so(u)),Pe(u),v=u.type,C=u.pendingProps,I=a!==null?a.memoizedProps:null,g=C.children,Mb(v,C)?g=null:I!==null&&Mb(v,I)&&(u.flags|=32),u.memoizedState!==null&&(v=Oy(a,u,cz,null,null,f),Xu._currentValue=v),op(a,u),Vn(a,u,g,f),u.child;case 6:return a===null&&ct&&((a=f=Pt)&&(f=Xz(f,u.pendingProps,ir),f!==null?(u.stateNode=f,zn=u,Pt=null,a=!0):a=!1),a||so(u)),null;case 13:return e2(a,u,f);case 4:return Ie(u,u.stateNode.containerInfo),g=u.pendingProps,a===null?u.child=ma(u,null,g,f):Vn(a,u,g,f),u.child;case 11:return Wk(a,u,u.type,u.pendingProps,f);case 7:return Vn(a,u,u.pendingProps,f),u.child;case 8:return Vn(a,u,u.pendingProps.children,f),u.child;case 12:return Vn(a,u,u.pendingProps.children,f),u.child;case 10:return g=u.pendingProps,ro(u,u.type,g.value),Vn(a,u,g.children,f),u.child;case 9:return v=u.type._context,g=u.pendingProps.children,ha(u),v=Bn(v),g=g(v),u.flags|=1,Vn(a,u,g,f),u.child;case 14:return Hk(a,u,u.type,u.pendingProps,f);case 15:return qk(a,u,u.type,u.pendingProps,f);case 19:return n2(a,u,f);case 31:return yz(a,u,f);case 22:return Kk(a,u,f,u.pendingProps);case 24:return ha(u),g=Bn(un),a===null?(v=Ty(),v===null&&(v=_t,C=Sy(),v.pooledCache=C,C.refCount++,C!==null&&(v.pooledCacheLanes|=f),v=C),u.memoizedState={parent:g,cache:v},$y(u),ro(u,un,v)):((a.lanes&f)!==0&&(Ey(a,u),Nu(u,null,null,f),Iu()),v=a.memoizedState,C=u.memoizedState,v.parent!==g?(v={parent:g,cache:g},u.memoizedState=v,u.lanes===0&&(u.memoizedState=u.updateQueue.baseState=v),ro(u,un,g)):(g=C.cache,ro(u,un,g),g!==v.cache&&wy(u,[un],f,!0))),Vn(a,u,u.pendingProps.children,f),u.child;case 29:throw u.pendingProps}throw Error(s(156,u.tag))}function Ai(a){a.flags|=4}function lb(a,u,f,g,v){if((u=(a.mode&32)!==0)&&(u=!1),u){if(a.flags|=16777216,(v&335544128)===v)if(a.stateNode.complete)a.flags|=8192;else if(A2())a.flags|=8192;else throw pa=Wf,ky}else a.flags&=-16777217}function r2(a,u){if(u.type!=="stylesheet"||(u.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!x$(u))if(A2())a.flags|=8192;else throw pa=Wf,ky}function lp(a,u){u!==null&&(a.flags|=4),a.flags&16384&&(u=a.tag!==22?LC():536870912,a.lanes|=u,Hl|=u)}function Mu(a,u){if(!ct)switch(a.tailMode){case"hidden":u=a.tail;for(var f=null;u!==null;)u.alternate!==null&&(f=u),u=u.sibling;f===null?a.tail=null:f.sibling=null;break;case"collapsed":f=a.tail;for(var g=null;f!==null;)f.alternate!==null&&(g=f),f=f.sibling;g===null?u||a.tail===null?a.tail=null:a.tail.sibling=null:g.sibling=null}}function zt(a){var u=a.alternate!==null&&a.alternate.child===a.child,f=0,g=0;if(u)for(var v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags&65011712,g|=v.flags&65011712,v.return=a,v=v.sibling;else for(v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags,g|=v.flags,v.return=a,v=v.sibling;return a.subtreeFlags|=g,a.childLanes=f,u}function xz(a,u,f){var g=u.pendingProps;switch(gy(u),u.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return zt(u),null;case 1:return zt(u),null;case 3:return f=u.stateNode,g=null,a!==null&&(g=a.memoizedState.cache),u.memoizedState.cache!==g&&(u.flags|=2048),$i(un),Ce(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(a===null||a.child===null)&&(Dl(u)?Ai(u):a===null||a.memoizedState.isDehydrated&&(u.flags&256)===0||(u.flags|=1024,by())),zt(u),null;case 26:var v=u.type,C=u.memoizedState;return a===null?(Ai(u),C!==null?(zt(u),r2(u,C)):(zt(u),lb(u,v,null,g,f))):C?C!==a.memoizedState?(Ai(u),zt(u),r2(u,C)):(zt(u),u.flags&=-16777217):(a=a.memoizedProps,a!==g&&Ai(u),zt(u),lb(u,v,a,g,f)),null;case 27:if(Te(u),f=ye.current,v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Ai(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return zt(u),null}a=re.current,Dl(u)?LT(u):(a=h$(v,g,f),u.stateNode=a,Ai(u))}return zt(u),null;case 5:if(Te(u),v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Ai(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return zt(u),null}if(C=re.current,Dl(u))LT(u);else{var I=Cp(ye.current);switch(C){case 1:C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":C=I.createElement("div"),C.innerHTML="<script><\/script>",C=C.removeChild(C.firstChild);break;case"select":C=typeof g.is=="string"?I.createElement("select",{is:g.is}):I.createElement("select"),g.multiple?C.multiple=!0:g.size&&(C.size=g.size);break;default:C=typeof g.is=="string"?I.createElement(v,{is:g.is}):I.createElement(v)}}C[Pn]=u,C[xs]=g;e:for(I=u.child;I!==null;){if(I.tag===5||I.tag===6)C.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===u)break e;for(;I.sibling===null;){if(I.return===null||I.return===u)break e;I=I.return}I.sibling.return=I.return,I=I.sibling}u.stateNode=C;e:switch(Un(C,v,g),v){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break e;case"img":g=!0;break e;default:g=!1}g&&Ai(u)}}return zt(u),lb(u,u.type,a===null?null:a.memoizedProps,u.pendingProps,f),null;case 6:if(a&&u.stateNode!=null)a.memoizedProps!==g&&Ai(u);else{if(typeof g!="string"&&u.stateNode===null)throw Error(s(166));if(a=ye.current,Dl(u)){if(a=u.stateNode,f=u.memoizedProps,g=null,v=zn,v!==null)switch(v.tag){case 27:case 5:g=v.memoizedProps}a[Pn]=u,a=!!(a.nodeValue===f||g!==null&&g.suppressHydrationWarning===!0||e$(a.nodeValue,f)),a||so(u,!0)}else a=Cp(a).createTextNode(g),a[Pn]=u,u.stateNode=a}return zt(u),null;case 31:if(f=u.memoizedState,a===null||a.memoizedState!==null){if(g=Dl(u),f!==null){if(a===null){if(!g)throw Error(s(318));if(a=u.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(557));a[Pn]=u}else ca(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;zt(u),a=!1}else f=by(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=f),a=!0;if(!a)return u.flags&256?(zs(u),u):(zs(u),null);if((u.flags&128)!==0)throw Error(s(558))}return zt(u),null;case 13:if(g=u.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(v=Dl(u),g!==null&&g.dehydrated!==null){if(a===null){if(!v)throw Error(s(318));if(v=u.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(s(317));v[Pn]=u}else ca(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;zt(u),v=!1}else v=by(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=v),v=!0;if(!v)return u.flags&256?(zs(u),u):(zs(u),null)}return zs(u),(u.flags&128)!==0?(u.lanes=f,u):(f=g!==null,a=a!==null&&a.memoizedState!==null,f&&(g=u.child,v=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(v=g.alternate.memoizedState.cachePool.pool),C=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(C=g.memoizedState.cachePool.pool),C!==v&&(g.flags|=2048)),f!==a&&f&&(u.child.flags|=8192),lp(u,u.updateQueue),zt(u),null);case 4:return Ce(),a===null&&Ab(u.stateNode.containerInfo),zt(u),null;case 10:return $i(u.type),zt(u),null;case 19:if(V(on),g=u.memoizedState,g===null)return zt(u),null;if(v=(u.flags&128)!==0,C=g.rendering,C===null)if(v)Mu(g,!1);else{if(Yt!==0||a!==null&&(a.flags&128)!==0)for(a=u.child;a!==null;){if(C=Xf(a),C!==null){for(u.flags|=128,Mu(g,!1),a=C.updateQueue,u.updateQueue=a,lp(u,a),u.subtreeFlags=0,a=f,f=u.child;f!==null;)RT(f,a),f=f.sibling;return Q(on,on.current&1|2),ct&&Ti(u,g.treeForkCount),u.child}a=a.sibling}g.tail!==null&&Lt()>fp&&(u.flags|=128,v=!0,Mu(g,!1),u.lanes=4194304)}else{if(!v)if(a=Xf(C),a!==null){if(u.flags|=128,v=!0,a=a.updateQueue,u.updateQueue=a,lp(u,a),Mu(g,!0),g.tail===null&&g.tailMode==="hidden"&&!C.alternate&&!ct)return zt(u),null}else 2*Lt()-g.renderingStartTime>fp&&f!==536870912&&(u.flags|=128,v=!0,Mu(g,!1),u.lanes=4194304);g.isBackwards?(C.sibling=u.child,u.child=C):(a=g.last,a!==null?a.sibling=C:u.child=C,g.last=C)}return g.tail!==null?(a=g.tail,g.rendering=a,g.tail=a.sibling,g.renderingStartTime=Lt(),a.sibling=null,f=on.current,Q(on,v?f&1|2:f&1),ct&&Ti(u,g.treeForkCount),a):(zt(u),null);case 22:case 23:return zs(u),_y(),g=u.memoizedState!==null,a!==null?a.memoizedState!==null!==g&&(u.flags|=8192):g&&(u.flags|=8192),g?(f&536870912)!==0&&(u.flags&128)===0&&(zt(u),u.subtreeFlags&6&&(u.flags|=8192)):zt(u),f=u.updateQueue,f!==null&&lp(u,f.retryQueue),f=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),g=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(g=u.memoizedState.cachePool.pool),g!==f&&(u.flags|=2048),a!==null&&V(da),null;case 24:return f=null,a!==null&&(f=a.memoizedState.cache),u.memoizedState.cache!==f&&(u.flags|=2048),$i(un),zt(u),null;case 25:return null;case 30:return null}throw Error(s(156,u.tag))}function vz(a,u){switch(gy(u),u.tag){case 1:return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 3:return $i(un),Ce(),a=u.flags,(a&65536)!==0&&(a&128)===0?(u.flags=a&-65537|128,u):null;case 26:case 27:case 5:return Te(u),null;case 31:if(u.memoizedState!==null){if(zs(u),u.alternate===null)throw Error(s(340));ca()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 13:if(zs(u),a=u.memoizedState,a!==null&&a.dehydrated!==null){if(u.alternate===null)throw Error(s(340));ca()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 19:return V(on),null;case 4:return Ce(),null;case 10:return $i(u.type),null;case 22:case 23:return zs(u),_y(),a!==null&&V(da),a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 24:return $i(un),null;case 25:return null;default:return null}}function i2(a,u){switch(gy(u),u.tag){case 3:$i(un),Ce();break;case 26:case 27:case 5:Te(u);break;case 4:Ce();break;case 31:u.memoizedState!==null&&zs(u);break;case 13:zs(u);break;case 19:V(on);break;case 10:$i(u.type);break;case 22:case 23:zs(u),_y(),a!==null&&V(da);break;case 24:$i(un)}}function Fu(a,u){try{var f=u.updateQueue,g=f!==null?f.lastEffect:null;if(g!==null){var v=g.next;f=v;do{if((f.tag&a)===a){g=void 0;var C=f.create,I=f.inst;g=C(),I.destroy=g}f=f.next}while(f!==v)}}catch(O){kt(u,u.return,O)}}function uo(a,u,f){try{var g=u.updateQueue,v=g!==null?g.lastEffect:null;if(v!==null){var C=v.next;g=C;do{if((g.tag&a)===a){var I=g.inst,O=I.destroy;if(O!==void 0){I.destroy=void 0,v=u;var j=f,le=O;try{le()}catch(me){kt(v,j,me)}}}g=g.next}while(g!==C)}}catch(me){kt(u,u.return,me)}}function o2(a){var u=a.updateQueue;if(u!==null){var f=a.stateNode;try{YT(u,f)}catch(g){kt(a,a.return,g)}}}function a2(a,u,f){f.props=ya(a.type,a.memoizedProps),f.state=a.memoizedState;try{f.componentWillUnmount()}catch(g){kt(a,u,g)}}function Lu(a,u){try{var f=a.ref;if(f!==null){switch(a.tag){case 26:case 27:case 5:var g=a.stateNode;break;case 30:g=a.stateNode;break;default:g=a.stateNode}typeof f=="function"?a.refCleanup=f(g):f.current=g}}catch(v){kt(a,u,v)}}function Jr(a,u){var f=a.ref,g=a.refCleanup;if(f!==null)if(typeof g=="function")try{g()}catch(v){kt(a,u,v)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(v){kt(a,u,v)}else f.current=null}function l2(a){var u=a.type,f=a.memoizedProps,g=a.stateNode;try{e:switch(u){case"button":case"input":case"select":case"textarea":f.autoFocus&&g.focus();break e;case"img":f.src?g.src=f.src:f.srcSet&&(g.srcset=f.srcSet)}}catch(v){kt(a,a.return,v)}}function cb(a,u,f){try{var g=a.stateNode;Uz(g,a.type,f,u),g[xs]=u}catch(v){kt(a,a.return,v)}}function c2(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&bo(a.type)||a.tag===4}function ub(a){e:for(;;){for(;a.sibling===null;){if(a.return===null||c2(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&bo(a.type)||a.flags&2||a.child===null||a.tag===4)continue e;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function hb(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(a,u):(u=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,u.appendChild(a),f=f._reactRootContainer,f!=null||u.onclick!==null||(u.onclick=wi));else if(g!==4&&(g===27&&bo(a.type)&&(f=a.stateNode,u=null),a=a.child,a!==null))for(hb(a,u,f),a=a.sibling;a!==null;)hb(a,u,f),a=a.sibling}function cp(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?f.insertBefore(a,u):f.appendChild(a);else if(g!==4&&(g===27&&bo(a.type)&&(f=a.stateNode),a=a.child,a!==null))for(cp(a,u,f),a=a.sibling;a!==null;)cp(a,u,f),a=a.sibling}function u2(a){var u=a.stateNode,f=a.memoizedProps;try{for(var g=a.type,v=u.attributes;v.length;)u.removeAttributeNode(v[0]);Un(u,g,f),u[Pn]=a,u[xs]=f}catch(C){kt(a,a.return,C)}}var _i=!1,fn=!1,db=!1,h2=typeof WeakSet=="function"?WeakSet:Set,Rn=null;function wz(a,u){if(a=a.containerInfo,Db=Ap,a=CT(a),iy(a)){if("selectionStart"in a)var f={start:a.selectionStart,end:a.selectionEnd};else e:{f=(f=a.ownerDocument)&&f.defaultView||window;var g=f.getSelection&&f.getSelection();if(g&&g.rangeCount!==0){f=g.anchorNode;var v=g.anchorOffset,C=g.focusNode;g=g.focusOffset;try{f.nodeType,C.nodeType}catch{f=null;break e}var I=0,O=-1,j=-1,le=0,me=0,be=a,ue=null;t:for(;;){for(var de;be!==f||v!==0&&be.nodeType!==3||(O=I+v),be!==C||g!==0&&be.nodeType!==3||(j=I+g),be.nodeType===3&&(I+=be.nodeValue.length),(de=be.firstChild)!==null;)ue=be,be=de;for(;;){if(be===a)break t;if(ue===f&&++le===v&&(O=I),ue===C&&++me===g&&(j=I),(de=be.nextSibling)!==null)break;be=ue,ue=be.parentNode}be=de}f=O===-1||j===-1?null:{start:O,end:j}}else f=null}f=f||{start:0,end:0}}else f=null;for(Ob={focusedElem:a,selectionRange:f},Ap=!1,Rn=u;Rn!==null;)if(u=Rn,a=u.child,(u.subtreeFlags&1028)!==0&&a!==null)a.return=u,Rn=a;else for(;Rn!==null;){switch(u=Rn,C=u.alternate,a=u.flags,u.tag){case 0:if((a&4)!==0&&(a=u.updateQueue,a=a!==null?a.events:null,a!==null))for(f=0;f<a.length;f++)v=a[f],v.ref.impl=v.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&C!==null){a=void 0,f=u,v=C.memoizedProps,C=C.memoizedState,g=f.stateNode;try{var Ne=ya(f.type,v);a=g.getSnapshotBeforeUpdate(Ne,C),g.__reactInternalSnapshotBeforeUpdate=a}catch(Be){kt(f,f.return,Be)}}break;case 3:if((a&1024)!==0){if(a=u.stateNode.containerInfo,f=a.nodeType,f===9)Lb(a);else if(f===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":Lb(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(s(163))}if(a=u.sibling,a!==null){a.return=u.return,Rn=a;break}Rn=u.return}}function d2(a,u,f){var g=f.flags;switch(f.tag){case 0:case 11:case 15:Di(a,f),g&4&&Fu(5,f);break;case 1:if(Di(a,f),g&4)if(a=f.stateNode,u===null)try{a.componentDidMount()}catch(I){kt(f,f.return,I)}else{var v=ya(f.type,u.memoizedProps);u=u.memoizedState;try{a.componentDidUpdate(v,u,a.__reactInternalSnapshotBeforeUpdate)}catch(I){kt(f,f.return,I)}}g&64&&o2(f),g&512&&Lu(f,f.return);break;case 3:if(Di(a,f),g&64&&(a=f.updateQueue,a!==null)){if(u=null,f.child!==null)switch(f.child.tag){case 27:case 5:u=f.child.stateNode;break;case 1:u=f.child.stateNode}try{YT(a,u)}catch(I){kt(f,f.return,I)}}break;case 27:u===null&&g&4&&u2(f);case 26:case 5:Di(a,f),u===null&&g&4&&l2(f),g&512&&Lu(f,f.return);break;case 12:Di(a,f);break;case 31:Di(a,f),g&4&&m2(a,f);break;case 13:Di(a,f),g&4&&g2(a,f),g&64&&(a=f.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(f=Az.bind(null,f),Yz(a,f))));break;case 22:if(g=f.memoizedState!==null||_i,!g){u=u!==null&&u.memoizedState!==null||fn,v=_i;var C=fn;_i=g,(fn=u)&&!C?Oi(a,f,(f.subtreeFlags&8772)!==0):Di(a,f),_i=v,fn=C}break;case 30:break;default:Di(a,f)}}function f2(a){var u=a.alternate;u!==null&&(a.alternate=null,f2(u)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(u=a.stateNode,u!==null&&U0(u)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var Ut=null,ws=!1;function Ri(a,u,f){for(f=f.child;f!==null;)p2(a,u,f),f=f.sibling}function p2(a,u,f){if(ls&&typeof ls.onCommitFiberUnmount=="function")try{ls.onCommitFiberUnmount(qr,f)}catch{}switch(f.tag){case 26:fn||Jr(f,u),Ri(a,u,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:fn||Jr(f,u);var g=Ut,v=ws;bo(f.type)&&(Ut=f.stateNode,ws=!1),Ri(a,u,f),Hu(f.stateNode),Ut=g,ws=v;break;case 5:fn||Jr(f,u);case 6:if(g=Ut,v=ws,Ut=null,Ri(a,u,f),Ut=g,ws=v,Ut!==null)if(ws)try{(Ut.nodeType===9?Ut.body:Ut.nodeName==="HTML"?Ut.ownerDocument.body:Ut).removeChild(f.stateNode)}catch(C){kt(f,u,C)}else try{Ut.removeChild(f.stateNode)}catch(C){kt(f,u,C)}break;case 18:Ut!==null&&(ws?(a=Ut,o$(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,f.stateNode),ec(a)):o$(Ut,f.stateNode));break;case 4:g=Ut,v=ws,Ut=f.stateNode.containerInfo,ws=!0,Ri(a,u,f),Ut=g,ws=v;break;case 0:case 11:case 14:case 15:uo(2,f,u),fn||uo(4,f,u),Ri(a,u,f);break;case 1:fn||(Jr(f,u),g=f.stateNode,typeof g.componentWillUnmount=="function"&&a2(f,u,g)),Ri(a,u,f);break;case 21:Ri(a,u,f);break;case 22:fn=(g=fn)||f.memoizedState!==null,Ri(a,u,f),fn=g;break;default:Ri(a,u,f)}}function m2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{ec(a)}catch(f){kt(u,u.return,f)}}}function g2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{ec(a)}catch(f){kt(u,u.return,f)}}function Sz(a){switch(a.tag){case 31:case 13:case 19:var u=a.stateNode;return u===null&&(u=a.stateNode=new h2),u;case 22:return a=a.stateNode,u=a._retryCache,u===null&&(u=a._retryCache=new h2),u;default:throw Error(s(435,a.tag))}}function up(a,u){var f=Sz(a);u.forEach(function(g){if(!f.has(g)){f.add(g);var v=_z.bind(null,a,g);g.then(v,v)}})}function Ss(a,u){var f=u.deletions;if(f!==null)for(var g=0;g<f.length;g++){var v=f[g],C=a,I=u,O=I;e:for(;O!==null;){switch(O.tag){case 27:if(bo(O.type)){Ut=O.stateNode,ws=!1;break e}break;case 5:Ut=O.stateNode,ws=!1;break e;case 3:case 4:Ut=O.stateNode.containerInfo,ws=!0;break e}O=O.return}if(Ut===null)throw Error(s(160));p2(C,I,v),Ut=null,ws=!1,C=v.alternate,C!==null&&(C.return=null),v.return=null}if(u.subtreeFlags&13886)for(u=u.child;u!==null;)y2(u,a),u=u.sibling}var Ir=null;function y2(a,u){var f=a.alternate,g=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:Ss(u,a),Cs(a),g&4&&(uo(3,a,a.return),Fu(3,a),uo(5,a,a.return));break;case 1:Ss(u,a),Cs(a),g&512&&(fn||f===null||Jr(f,f.return)),g&64&&_i&&(a=a.updateQueue,a!==null&&(g=a.callbacks,g!==null&&(f=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=f===null?g:f.concat(g))));break;case 26:var v=Ir;if(Ss(u,a),Cs(a),g&512&&(fn||f===null||Jr(f,f.return)),g&4){var C=f!==null?f.memoizedState:null;if(g=a.memoizedState,f===null)if(g===null)if(a.stateNode===null){e:{g=a.type,f=a.memoizedProps,v=v.ownerDocument||v;t:switch(g){case"title":C=v.getElementsByTagName("title")[0],(!C||C[uu]||C[Pn]||C.namespaceURI==="http://www.w3.org/2000/svg"||C.hasAttribute("itemprop"))&&(C=v.createElement(g),v.head.insertBefore(C,v.querySelector("head > title"))),Un(C,g,f),C[Pn]=a,_n(C),g=C;break e;case"link":var I=y$("link","href",v).get(g+(f.href||""));if(I){for(var O=0;O<I.length;O++)if(C=I[O],C.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&C.getAttribute("rel")===(f.rel==null?null:f.rel)&&C.getAttribute("title")===(f.title==null?null:f.title)&&C.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){I.splice(O,1);break t}}C=v.createElement(g),Un(C,g,f),v.head.appendChild(C);break;case"meta":if(I=y$("meta","content",v).get(g+(f.content||""))){for(O=0;O<I.length;O++)if(C=I[O],C.getAttribute("content")===(f.content==null?null:""+f.content)&&C.getAttribute("name")===(f.name==null?null:f.name)&&C.getAttribute("property")===(f.property==null?null:f.property)&&C.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&C.getAttribute("charset")===(f.charSet==null?null:f.charSet)){I.splice(O,1);break t}}C=v.createElement(g),Un(C,g,f),v.head.appendChild(C);break;default:throw Error(s(468,g))}C[Pn]=a,_n(C),g=C}a.stateNode=g}else b$(v,a.type,a.stateNode);else a.stateNode=g$(v,g,a.memoizedProps);else C!==g?(C===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):C.count--,g===null?b$(v,a.type,a.stateNode):g$(v,g,a.memoizedProps)):g===null&&a.stateNode!==null&&cb(a,a.memoizedProps,f.memoizedProps)}break;case 27:Ss(u,a),Cs(a),g&512&&(fn||f===null||Jr(f,f.return)),f!==null&&g&4&&cb(a,a.memoizedProps,f.memoizedProps);break;case 5:if(Ss(u,a),Cs(a),g&512&&(fn||f===null||Jr(f,f.return)),a.flags&32){v=a.stateNode;try{Cl(v,"")}catch(Ne){kt(a,a.return,Ne)}}g&4&&a.stateNode!=null&&(v=a.memoizedProps,cb(a,v,f!==null?f.memoizedProps:v)),g&1024&&(db=!0);break;case 6:if(Ss(u,a),Cs(a),g&4){if(a.stateNode===null)throw Error(s(162));g=a.memoizedProps,f=a.stateNode;try{f.nodeValue=g}catch(Ne){kt(a,a.return,Ne)}}break;case 3:if($p=null,v=Ir,Ir=Tp(u.containerInfo),Ss(u,a),Ir=v,Cs(a),g&4&&f!==null&&f.memoizedState.isDehydrated)try{ec(u.containerInfo)}catch(Ne){kt(a,a.return,Ne)}db&&(db=!1,b2(a));break;case 4:g=Ir,Ir=Tp(a.stateNode.containerInfo),Ss(u,a),Cs(a),Ir=g;break;case 12:Ss(u,a),Cs(a);break;case 31:Ss(u,a),Cs(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,up(a,g)));break;case 13:Ss(u,a),Cs(a),a.child.flags&8192&&a.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(dp=Lt()),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,up(a,g)));break;case 22:v=a.memoizedState!==null;var j=f!==null&&f.memoizedState!==null,le=_i,me=fn;if(_i=le||v,fn=me||j,Ss(u,a),fn=me,_i=le,Cs(a),g&8192)e:for(u=a.stateNode,u._visibility=v?u._visibility&-2:u._visibility|1,v&&(f===null||j||_i||fn||ba(a)),f=null,u=a;;){if(u.tag===5||u.tag===26){if(f===null){j=f=u;try{if(C=j.stateNode,v)I=C.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{O=j.stateNode;var be=j.memoizedProps.style,ue=be!=null&&be.hasOwnProperty("display")?be.display:null;O.style.display=ue==null||typeof ue=="boolean"?"":(""+ue).trim()}}catch(Ne){kt(j,j.return,Ne)}}}else if(u.tag===6){if(f===null){j=u;try{j.stateNode.nodeValue=v?"":j.memoizedProps}catch(Ne){kt(j,j.return,Ne)}}}else if(u.tag===18){if(f===null){j=u;try{var de=j.stateNode;v?a$(de,!0):a$(j.stateNode,!1)}catch(Ne){kt(j,j.return,Ne)}}}else if((u.tag!==22&&u.tag!==23||u.memoizedState===null||u===a)&&u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break e;for(;u.sibling===null;){if(u.return===null||u.return===a)break e;f===u&&(f=null),u=u.return}f===u&&(f=null),u.sibling.return=u.return,u=u.sibling}g&4&&(g=a.updateQueue,g!==null&&(f=g.retryQueue,f!==null&&(g.retryQueue=null,up(a,f))));break;case 19:Ss(u,a),Cs(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,up(a,g)));break;case 30:break;case 21:break;default:Ss(u,a),Cs(a)}}function Cs(a){var u=a.flags;if(u&2){try{for(var f,g=a.return;g!==null;){if(c2(g)){f=g;break}g=g.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var v=f.stateNode,C=ub(a);cp(a,C,v);break;case 5:var I=f.stateNode;f.flags&32&&(Cl(I,""),f.flags&=-33);var O=ub(a);cp(a,O,I);break;case 3:case 4:var j=f.stateNode.containerInfo,le=ub(a);hb(a,le,j);break;default:throw Error(s(161))}}catch(me){kt(a,a.return,me)}a.flags&=-3}u&4096&&(a.flags&=-4097)}function b2(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var u=a;b2(u),u.tag===5&&u.flags&1024&&u.stateNode.reset(),a=a.sibling}}function Di(a,u){if(u.subtreeFlags&8772)for(u=u.child;u!==null;)d2(a,u.alternate,u),u=u.sibling}function ba(a){for(a=a.child;a!==null;){var u=a;switch(u.tag){case 0:case 11:case 14:case 15:uo(4,u,u.return),ba(u);break;case 1:Jr(u,u.return);var f=u.stateNode;typeof f.componentWillUnmount=="function"&&a2(u,u.return,f),ba(u);break;case 27:Hu(u.stateNode);case 26:case 5:Jr(u,u.return),ba(u);break;case 22:u.memoizedState===null&&ba(u);break;case 30:ba(u);break;default:ba(u)}a=a.sibling}}function Oi(a,u,f){for(f=f&&(u.subtreeFlags&8772)!==0,u=u.child;u!==null;){var g=u.alternate,v=a,C=u,I=C.flags;switch(C.tag){case 0:case 11:case 15:Oi(v,C,f),Fu(4,C);break;case 1:if(Oi(v,C,f),g=C,v=g.stateNode,typeof v.componentDidMount=="function")try{v.componentDidMount()}catch(le){kt(g,g.return,le)}if(g=C,v=g.updateQueue,v!==null){var O=g.stateNode;try{var j=v.shared.hiddenCallbacks;if(j!==null)for(v.shared.hiddenCallbacks=null,v=0;v<j.length;v++)XT(j[v],O)}catch(le){kt(g,g.return,le)}}f&&I&64&&o2(C),Lu(C,C.return);break;case 27:u2(C);case 26:case 5:Oi(v,C,f),f&&g===null&&I&4&&l2(C),Lu(C,C.return);break;case 12:Oi(v,C,f);break;case 31:Oi(v,C,f),f&&I&4&&m2(v,C);break;case 13:Oi(v,C,f),f&&I&4&&g2(v,C);break;case 22:C.memoizedState===null&&Oi(v,C,f),Lu(C,C.return);break;case 30:break;default:Oi(v,C,f)}u=u.sibling}}function fb(a,u){var f=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),a=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(a=u.memoizedState.cachePool.pool),a!==f&&(a!=null&&a.refCount++,f!=null&&Cu(f))}function pb(a,u){a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Cu(a))}function Nr(a,u,f,g){if(u.subtreeFlags&10256)for(u=u.child;u!==null;)x2(a,u,f,g),u=u.sibling}function x2(a,u,f,g){var v=u.flags;switch(u.tag){case 0:case 11:case 15:Nr(a,u,f,g),v&2048&&Fu(9,u);break;case 1:Nr(a,u,f,g);break;case 3:Nr(a,u,f,g),v&2048&&(a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Cu(a)));break;case 12:if(v&2048){Nr(a,u,f,g),a=u.stateNode;try{var C=u.memoizedProps,I=C.id,O=C.onPostCommit;typeof O=="function"&&O(I,u.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(j){kt(u,u.return,j)}}else Nr(a,u,f,g);break;case 31:Nr(a,u,f,g);break;case 13:Nr(a,u,f,g);break;case 23:break;case 22:C=u.stateNode,I=u.alternate,u.memoizedState!==null?C._visibility&2?Nr(a,u,f,g):Pu(a,u):C._visibility&2?Nr(a,u,f,g):(C._visibility|=2,jl(a,u,f,g,(u.subtreeFlags&10256)!==0||!1)),v&2048&&fb(I,u);break;case 24:Nr(a,u,f,g),v&2048&&pb(u.alternate,u);break;default:Nr(a,u,f,g)}}function jl(a,u,f,g,v){for(v=v&&((u.subtreeFlags&10256)!==0||!1),u=u.child;u!==null;){var C=a,I=u,O=f,j=g,le=I.flags;switch(I.tag){case 0:case 11:case 15:jl(C,I,O,j,v),Fu(8,I);break;case 23:break;case 22:var me=I.stateNode;I.memoizedState!==null?me._visibility&2?jl(C,I,O,j,v):Pu(C,I):(me._visibility|=2,jl(C,I,O,j,v)),v&&le&2048&&fb(I.alternate,I);break;case 24:jl(C,I,O,j,v),v&&le&2048&&pb(I.alternate,I);break;default:jl(C,I,O,j,v)}u=u.sibling}}function Pu(a,u){if(u.subtreeFlags&10256)for(u=u.child;u!==null;){var f=a,g=u,v=g.flags;switch(g.tag){case 22:Pu(f,g),v&2048&&fb(g.alternate,g);break;case 24:Pu(f,g),v&2048&&pb(g.alternate,g);break;default:Pu(f,g)}u=u.sibling}}var zu=8192;function Gl(a,u,f){if(a.subtreeFlags&zu)for(a=a.child;a!==null;)v2(a,u,f),a=a.sibling}function v2(a,u,f){switch(a.tag){case 26:Gl(a,u,f),a.flags&zu&&a.memoizedState!==null&&lB(f,Ir,a.memoizedState,a.memoizedProps);break;case 5:Gl(a,u,f);break;case 3:case 4:var g=Ir;Ir=Tp(a.stateNode.containerInfo),Gl(a,u,f),Ir=g;break;case 22:a.memoizedState===null&&(g=a.alternate,g!==null&&g.memoizedState!==null?(g=zu,zu=16777216,Gl(a,u,f),zu=g):Gl(a,u,f));break;default:Gl(a,u,f)}}function w2(a){var u=a.alternate;if(u!==null&&(a=u.child,a!==null)){u.child=null;do u=a.sibling,a.sibling=null,a=u;while(a!==null)}}function Bu(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Rn=g,C2(g,a)}w2(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)S2(a),a=a.sibling}function S2(a){switch(a.tag){case 0:case 11:case 15:Bu(a),a.flags&2048&&uo(9,a,a.return);break;case 3:Bu(a);break;case 12:Bu(a);break;case 22:var u=a.stateNode;a.memoizedState!==null&&u._visibility&2&&(a.return===null||a.return.tag!==13)?(u._visibility&=-3,hp(a)):Bu(a);break;default:Bu(a)}}function hp(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Rn=g,C2(g,a)}w2(a)}for(a=a.child;a!==null;){switch(u=a,u.tag){case 0:case 11:case 15:uo(8,u,u.return),hp(u);break;case 22:f=u.stateNode,f._visibility&2&&(f._visibility&=-3,hp(u));break;default:hp(u)}a=a.sibling}}function C2(a,u){for(;Rn!==null;){var f=Rn;switch(f.tag){case 0:case 11:case 15:uo(8,f,u);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var g=f.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Cu(f.memoizedState.cache)}if(g=f.child,g!==null)g.return=f,Rn=g;else e:for(f=a;Rn!==null;){g=Rn;var v=g.sibling,C=g.return;if(f2(g),g===f){Rn=null;break e}if(v!==null){v.return=C,Rn=v;break e}Rn=C}}}var Cz={getCacheForType:function(a){var u=Bn(un),f=u.data.get(a);return f===void 0&&(f=a(),u.data.set(a,f)),f},cacheSignal:function(){return Bn(un).controller.signal}},Tz=typeof WeakMap=="function"?WeakMap:Map,vt=0,_t=null,it=null,at=0,Tt=0,Bs=null,ho=!1,Wl=!1,mb=!1,Mi=0,Yt=0,fo=0,xa=0,gb=0,Vs=0,Hl=0,Vu=null,Ts=null,yb=!1,dp=0,T2=0,fp=1/0,pp=null,po=null,Cn=0,mo=null,ql=null,Fi=0,bb=0,xb=null,k2=null,Uu=0,vb=null;function Us(){return(vt&2)!==0&&at!==0?at&-at:P.T!==null?$b():VC()}function $2(){if(Vs===0)if((at&536870912)===0||ct){var a=Sf;Sf<<=1,(Sf&3932160)===0&&(Sf=262144),Vs=a}else Vs=536870912;return a=Ps.current,a!==null&&(a.flags|=32),Vs}function ks(a,u,f){(a===_t&&(Tt===2||Tt===9)||a.cancelPendingCommit!==null)&&(Kl(a,0),go(a,at,Vs,!1)),cu(a,f),((vt&2)===0||a!==_t)&&(a===_t&&((vt&2)===0&&(xa|=f),Yt===4&&go(a,at,Vs,!1)),Zr(a))}function E2(a,u,f){if((vt&6)!==0)throw Error(s(327));var g=!f&&(u&127)===0&&(u&a.expiredLanes)===0||lu(a,u),v=g?Ez(a,u):Sb(a,u,!0),C=g;do{if(v===0){Wl&&!g&&go(a,u,0,!1);break}else{if(f=a.current.alternate,C&&!kz(f)){v=Sb(a,u,!1),C=!1;continue}if(v===2){if(C=u,a.errorRecoveryDisabledLanes&C)var I=0;else I=a.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){u=I;e:{var O=a;v=Vu;var j=O.current.memoizedState.isDehydrated;if(j&&(Kl(O,I).flags|=256),I=Sb(O,I,!1),I!==2){if(mb&&!j){O.errorRecoveryDisabledLanes|=C,xa|=C,v=4;break e}C=Ts,Ts=v,C!==null&&(Ts===null?Ts=C:Ts.push.apply(Ts,C))}v=I}if(C=!1,v!==2)continue}}if(v===1){Kl(a,0),go(a,u,0,!0);break}e:{switch(g=a,C=v,C){case 0:case 1:throw Error(s(345));case 4:if((u&4194048)!==u)break;case 6:go(g,u,Vs,!ho);break e;case 2:Ts=null;break;case 3:case 5:break;default:throw Error(s(329))}if((u&62914560)===u&&(v=dp+300-Lt(),10<v)){if(go(g,u,Vs,!ho),Tf(g,0,!0)!==0)break e;Fi=u,g.timeoutHandle=r$(I2.bind(null,g,f,Ts,pp,yb,u,Vs,xa,Hl,ho,C,"Throttled",-0,0),v);break e}I2(g,f,Ts,pp,yb,u,Vs,xa,Hl,ho,C,null,-0,0)}}break}while(!0);Zr(a)}function I2(a,u,f,g,v,C,I,O,j,le,me,be,ue,de){if(a.timeoutHandle=-1,be=u.subtreeFlags,be&8192||(be&16785408)===16785408){be={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:wi},v2(u,C,be);var Ne=(C&62914560)===C?dp-Lt():(C&4194048)===C?T2-Lt():0;if(Ne=cB(be,Ne),Ne!==null){Fi=C,a.cancelPendingCommit=Ne(F2.bind(null,a,u,C,f,g,v,I,O,j,me,be,null,ue,de)),go(a,C,I,!le);return}}F2(a,u,C,f,g,v,I,O,j)}function kz(a){for(var u=a;;){var f=u.tag;if((f===0||f===11||f===15)&&u.flags&16384&&(f=u.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var g=0;g<f.length;g++){var v=f[g],C=v.getSnapshot;v=v.value;try{if(!Fs(C(),v))return!1}catch{return!1}}if(f=u.child,u.subtreeFlags&16384&&f!==null)f.return=u,u=f;else{if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return!0;u=u.return}u.sibling.return=u.return,u=u.sibling}}return!0}function go(a,u,f,g){u&=~gb,u&=~xa,a.suspendedLanes|=u,a.pingedLanes&=~u,g&&(a.warmLanes|=u),g=a.expirationTimes;for(var v=u;0<v;){var C=31-Ms(v),I=1<<C;g[C]=-1,v&=~I}f!==0&&PC(a,f,u)}function mp(){return(vt&6)===0?(ju(0),!1):!0}function wb(){if(it!==null){if(Tt===0)var a=it.return;else a=it,ki=ua=null,Ly(a),Pl=null,ku=0,a=it;for(;a!==null;)i2(a.alternate,a),a=a.return;it=null}}function Kl(a,u){var f=a.timeoutHandle;f!==-1&&(a.timeoutHandle=-1,Wz(f)),f=a.cancelPendingCommit,f!==null&&(a.cancelPendingCommit=null,f()),Fi=0,wb(),_t=a,it=f=Ci(a.current,null),at=u,Tt=0,Bs=null,ho=!1,Wl=lu(a,u),mb=!1,Hl=Vs=gb=xa=fo=Yt=0,Ts=Vu=null,yb=!1,(u&8)!==0&&(u|=u&32);var g=a.entangledLanes;if(g!==0)for(a=a.entanglements,g&=u;0<g;){var v=31-Ms(g),C=1<<v;u|=a[v],g&=~C}return Mi=u,Ff(),f}function N2(a,u){Je=null,P.H=Du,u===Ll||u===Gf?(u=WT(),Tt=3):u===ky?(u=WT(),Tt=4):Tt=u===Qy?8:u!==null&&typeof u=="object"&&typeof u.then=="function"?6:1,Bs=u,it===null&&(Yt=1,rp(a,nr(u,a.current)))}function A2(){var a=Ps.current;return a===null?!0:(at&4194048)===at?or===null:(at&62914560)===at||(at&536870912)!==0?a===or:!1}function _2(){var a=P.H;return P.H=Du,a===null?Du:a}function R2(){var a=P.A;return P.A=Cz,a}function gp(){Yt=4,ho||(at&4194048)!==at&&Ps.current!==null||(Wl=!0),(fo&134217727)===0&&(xa&134217727)===0||_t===null||go(_t,at,Vs,!1)}function Sb(a,u,f){var g=vt;vt|=2;var v=_2(),C=R2();(_t!==a||at!==u)&&(pp=null,Kl(a,u)),u=!1;var I=Yt;e:do try{if(Tt!==0&&it!==null){var O=it,j=Bs;switch(Tt){case 8:wb(),I=6;break e;case 3:case 2:case 9:case 6:Ps.current===null&&(u=!0);var le=Tt;if(Tt=0,Bs=null,Xl(a,O,j,le),f&&Wl){I=0;break e}break;default:le=Tt,Tt=0,Bs=null,Xl(a,O,j,le)}}$z(),I=Yt;break}catch(me){N2(a,me)}while(!0);return u&&a.shellSuspendCounter++,ki=ua=null,vt=g,P.H=v,P.A=C,it===null&&(_t=null,at=0,Ff()),I}function $z(){for(;it!==null;)D2(it)}function Ez(a,u){var f=vt;vt|=2;var g=_2(),v=R2();_t!==a||at!==u?(pp=null,fp=Lt()+500,Kl(a,u)):Wl=lu(a,u);e:do try{if(Tt!==0&&it!==null){u=it;var C=Bs;t:switch(Tt){case 1:Tt=0,Bs=null,Xl(a,u,C,1);break;case 2:case 9:if(jT(C)){Tt=0,Bs=null,O2(u);break}u=function(){Tt!==2&&Tt!==9||_t!==a||(Tt=7),Zr(a)},C.then(u,u);break e;case 3:Tt=7;break e;case 4:Tt=5;break e;case 7:jT(C)?(Tt=0,Bs=null,O2(u)):(Tt=0,Bs=null,Xl(a,u,C,7));break;case 5:var I=null;switch(it.tag){case 26:I=it.memoizedState;case 5:case 27:var O=it;if(I?x$(I):O.stateNode.complete){Tt=0,Bs=null;var j=O.sibling;if(j!==null)it=j;else{var le=O.return;le!==null?(it=le,yp(le)):it=null}break t}}Tt=0,Bs=null,Xl(a,u,C,5);break;case 6:Tt=0,Bs=null,Xl(a,u,C,6);break;case 8:wb(),Yt=6;break e;default:throw Error(s(462))}}Iz();break}catch(me){N2(a,me)}while(!0);return ki=ua=null,P.H=g,P.A=v,vt=f,it!==null?0:(_t=null,at=0,Ff(),Yt)}function Iz(){for(;it!==null&&!as();)D2(it)}function D2(a){var u=s2(a.alternate,a,Mi);a.memoizedProps=a.pendingProps,u===null?yp(a):it=u}function O2(a){var u=a,f=u.alternate;switch(u.tag){case 15:case 0:u=Jk(f,u,u.pendingProps,u.type,void 0,at);break;case 11:u=Jk(f,u,u.pendingProps,u.type.render,u.ref,at);break;case 5:Ly(u);default:i2(f,u),u=it=RT(u,Mi),u=s2(f,u,Mi)}a.memoizedProps=a.pendingProps,u===null?yp(a):it=u}function Xl(a,u,f,g){ki=ua=null,Ly(u),Pl=null,ku=0;var v=u.return;try{if(gz(a,v,u,f,at)){Yt=1,rp(a,nr(f,a.current)),it=null;return}}catch(C){if(v!==null)throw it=v,C;Yt=1,rp(a,nr(f,a.current)),it=null;return}u.flags&32768?(ct||g===1?a=!0:Wl||(at&536870912)!==0?a=!1:(ho=a=!0,(g===2||g===9||g===3||g===6)&&(g=Ps.current,g!==null&&g.tag===13&&(g.flags|=16384))),M2(u,a)):yp(u)}function yp(a){var u=a;do{if((u.flags&32768)!==0){M2(u,ho);return}a=u.return;var f=xz(u.alternate,u,Mi);if(f!==null){it=f;return}if(u=u.sibling,u!==null){it=u;return}it=u=a}while(u!==null);Yt===0&&(Yt=5)}function M2(a,u){do{var f=vz(a.alternate,a);if(f!==null){f.flags&=32767,it=f;return}if(f=a.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!u&&(a=a.sibling,a!==null)){it=a;return}it=a=f}while(a!==null);Yt=6,it=null}function F2(a,u,f,g,v,C,I,O,j){a.cancelPendingCommit=null;do bp();while(Cn!==0);if((vt&6)!==0)throw Error(s(327));if(u!==null){if(u===a.current)throw Error(s(177));if(C=u.lanes|u.childLanes,C|=uy,aP(a,f,C,I,O,j),a===_t&&(it=_t=null,at=0),ql=u,mo=a,Fi=f,bb=C,xb=v,k2=g,(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,Rz(Os,function(){return V2(),null})):(a.callbackNode=null,a.callbackPriority=0),g=(u.flags&13878)!==0,(u.subtreeFlags&13878)!==0||g){g=P.T,P.T=null,v=B.p,B.p=2,I=vt,vt|=4;try{wz(a,u,f)}finally{vt=I,B.p=v,P.T=g}}Cn=1,L2(),P2(),z2()}}function L2(){if(Cn===1){Cn=0;var a=mo,u=ql,f=(u.flags&13878)!==0;if((u.subtreeFlags&13878)!==0||f){f=P.T,P.T=null;var g=B.p;B.p=2;var v=vt;vt|=4;try{y2(u,a);var C=Ob,I=CT(a.containerInfo),O=C.focusedElem,j=C.selectionRange;if(I!==O&&O&&O.ownerDocument&&ST(O.ownerDocument.documentElement,O)){if(j!==null&&iy(O)){var le=j.start,me=j.end;if(me===void 0&&(me=le),"selectionStart"in O)O.selectionStart=le,O.selectionEnd=Math.min(me,O.value.length);else{var be=O.ownerDocument||document,ue=be&&be.defaultView||window;if(ue.getSelection){var de=ue.getSelection(),Ne=O.textContent.length,Be=Math.min(j.start,Ne),Nt=j.end===void 0?Be:Math.min(j.end,Ne);!de.extend&&Be>Nt&&(I=Nt,Nt=Be,Be=I);var se=wT(O,Be),q=wT(O,Nt);if(se&&q&&(de.rangeCount!==1||de.anchorNode!==se.node||de.anchorOffset!==se.offset||de.focusNode!==q.node||de.focusOffset!==q.offset)){var ae=be.createRange();ae.setStart(se.node,se.offset),de.removeAllRanges(),Be>Nt?(de.addRange(ae),de.extend(q.node,q.offset)):(ae.setEnd(q.node,q.offset),de.addRange(ae))}}}}for(be=[],de=O;de=de.parentNode;)de.nodeType===1&&be.push({element:de,left:de.scrollLeft,top:de.scrollTop});for(typeof O.focus=="function"&&O.focus(),O=0;O<be.length;O++){var ge=be[O];ge.element.scrollLeft=ge.left,ge.element.scrollTop=ge.top}}Ap=!!Db,Ob=Db=null}finally{vt=v,B.p=g,P.T=f}}a.current=u,Cn=2}}function P2(){if(Cn===2){Cn=0;var a=mo,u=ql,f=(u.flags&8772)!==0;if((u.subtreeFlags&8772)!==0||f){f=P.T,P.T=null;var g=B.p;B.p=2;var v=vt;vt|=4;try{d2(a,u.alternate,u)}finally{vt=v,B.p=g,P.T=f}}Cn=3}}function z2(){if(Cn===4||Cn===3){Cn=0,xi();var a=mo,u=ql,f=Fi,g=k2;(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?Cn=5:(Cn=0,ql=mo=null,B2(a,a.pendingLanes));var v=a.pendingLanes;if(v===0&&(po=null),B0(f),u=u.stateNode,ls&&typeof ls.onCommitFiberRoot=="function")try{ls.onCommitFiberRoot(qr,u,void 0,(u.current.flags&128)===128)}catch{}if(g!==null){u=P.T,v=B.p,B.p=2,P.T=null;try{for(var C=a.onRecoverableError,I=0;I<g.length;I++){var O=g[I];C(O.value,{componentStack:O.stack})}}finally{P.T=u,B.p=v}}(Fi&3)!==0&&bp(),Zr(a),v=a.pendingLanes,(f&261930)!==0&&(v&42)!==0?a===vb?Uu++:(Uu=0,vb=a):Uu=0,ju(0)}}function B2(a,u){(a.pooledCacheLanes&=u)===0&&(u=a.pooledCache,u!=null&&(a.pooledCache=null,Cu(u)))}function bp(){return L2(),P2(),z2(),V2()}function V2(){if(Cn!==5)return!1;var a=mo,u=bb;bb=0;var f=B0(Fi),g=P.T,v=B.p;try{B.p=32>f?32:f,P.T=null,f=xb,xb=null;var C=mo,I=Fi;if(Cn=0,ql=mo=null,Fi=0,(vt&6)!==0)throw Error(s(331));var O=vt;if(vt|=4,S2(C.current),x2(C,C.current,I,f),vt=O,ju(0,!1),ls&&typeof ls.onPostCommitFiberRoot=="function")try{ls.onPostCommitFiberRoot(qr,C)}catch{}return!0}finally{B.p=v,P.T=g,B2(a,u)}}function U2(a,u,f){u=nr(f,u),u=Zy(a.stateNode,u,2),a=ao(a,u,2),a!==null&&(cu(a,2),Zr(a))}function kt(a,u,f){if(a.tag===3)U2(a,a,f);else for(;u!==null;){if(u.tag===3){U2(u,a,f);break}else if(u.tag===1){var g=u.stateNode;if(typeof u.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(po===null||!po.has(g))){a=nr(f,a),f=jk(2),g=ao(u,f,2),g!==null&&(Gk(f,g,u,a),cu(g,2),Zr(g));break}}u=u.return}}function Cb(a,u,f){var g=a.pingCache;if(g===null){g=a.pingCache=new Tz;var v=new Set;g.set(u,v)}else v=g.get(u),v===void 0&&(v=new Set,g.set(u,v));v.has(f)||(mb=!0,v.add(f),a=Nz.bind(null,a,u,f),u.then(a,a))}function Nz(a,u,f){var g=a.pingCache;g!==null&&g.delete(u),a.pingedLanes|=a.suspendedLanes&f,a.warmLanes&=~f,_t===a&&(at&f)===f&&(Yt===4||Yt===3&&(at&62914560)===at&&300>Lt()-dp?(vt&2)===0&&Kl(a,0):gb|=f,Hl===at&&(Hl=0)),Zr(a)}function j2(a,u){u===0&&(u=LC()),a=aa(a,u),a!==null&&(cu(a,u),Zr(a))}function Az(a){var u=a.memoizedState,f=0;u!==null&&(f=u.retryLane),j2(a,f)}function _z(a,u){var f=0;switch(a.tag){case 31:case 13:var g=a.stateNode,v=a.memoizedState;v!==null&&(f=v.retryLane);break;case 19:g=a.stateNode;break;case 22:g=a.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(u),j2(a,f)}function Rz(a,u){return Kt(a,u)}var xp=null,Yl=null,Tb=!1,vp=!1,kb=!1,yo=0;function Zr(a){a!==Yl&&a.next===null&&(Yl===null?xp=Yl=a:Yl=Yl.next=a),vp=!0,Tb||(Tb=!0,Oz())}function ju(a,u){if(!kb&&vp){kb=!0;do for(var f=!1,g=xp;g!==null;){if(a!==0){var v=g.pendingLanes;if(v===0)var C=0;else{var I=g.suspendedLanes,O=g.pingedLanes;C=(1<<31-Ms(42|a)+1)-1,C&=v&~(I&~O),C=C&201326741?C&201326741|1:C?C|2:0}C!==0&&(f=!0,q2(g,C))}else C=at,C=Tf(g,g===_t?C:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(C&3)===0||lu(g,C)||(f=!0,q2(g,C));g=g.next}while(f);kb=!1}}function Dz(){G2()}function G2(){vp=Tb=!1;var a=0;yo!==0&&Gz()&&(a=yo);for(var u=Lt(),f=null,g=xp;g!==null;){var v=g.next,C=W2(g,u);C===0?(g.next=null,f===null?xp=v:f.next=v,v===null&&(Yl=f)):(f=g,(a!==0||(C&3)!==0)&&(vp=!0)),g=v}Cn!==0&&Cn!==5||ju(a),yo!==0&&(yo=0)}function W2(a,u){for(var f=a.suspendedLanes,g=a.pingedLanes,v=a.expirationTimes,C=a.pendingLanes&-62914561;0<C;){var I=31-Ms(C),O=1<<I,j=v[I];j===-1?((O&f)===0||(O&g)!==0)&&(v[I]=oP(O,u)):j<=u&&(a.expiredLanes|=O),C&=~O}if(u=_t,f=at,f=Tf(a,a===u?f:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g=a.callbackNode,f===0||a===u&&(Tt===2||Tt===9)||a.cancelPendingCommit!==null)return g!==null&&g!==null&&Zs(g),a.callbackNode=null,a.callbackPriority=0;if((f&3)===0||lu(a,f)){if(u=f&-f,u===a.callbackPriority)return u;switch(g!==null&&Zs(g),B0(f)){case 2:case 8:f=$r;break;case 32:f=Os;break;case 268435456:f=gl;break;default:f=Os}return g=H2.bind(null,a),f=Kt(f,g),a.callbackPriority=u,a.callbackNode=f,u}return g!==null&&g!==null&&Zs(g),a.callbackPriority=2,a.callbackNode=null,2}function H2(a,u){if(Cn!==0&&Cn!==5)return a.callbackNode=null,a.callbackPriority=0,null;var f=a.callbackNode;if(bp()&&a.callbackNode!==f)return null;var g=at;return g=Tf(a,a===_t?g:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g===0?null:(E2(a,g,u),W2(a,Lt()),a.callbackNode!=null&&a.callbackNode===f?H2.bind(null,a):null)}function q2(a,u){if(bp())return null;E2(a,u,!0)}function Oz(){Hz(function(){(vt&6)!==0?Kt(kr,Dz):G2()})}function $b(){if(yo===0){var a=Ml;a===0&&(a=wf,wf<<=1,(wf&261888)===0&&(wf=256)),yo=a}return yo}function K2(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:If(""+a)}function X2(a,u){var f=u.ownerDocument.createElement("input");return f.name=u.name,f.value=u.value,a.id&&f.setAttribute("form",a.id),u.parentNode.insertBefore(f,u),a=new FormData(a),f.parentNode.removeChild(f),a}function Mz(a,u,f,g,v){if(u==="submit"&&f&&f.stateNode===v){var C=K2((v[xs]||null).action),I=g.submitter;I&&(u=(u=I[xs]||null)?K2(u.formAction):I.getAttribute("formAction"),u!==null&&(C=u,I=null));var O=new Rf("action","action",null,g,v);a.push({event:O,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(yo!==0){var j=I?X2(v,I):new FormData(v);Hy(f,{pending:!0,data:j,method:v.method,action:C},null,j)}}else typeof C=="function"&&(O.preventDefault(),j=I?X2(v,I):new FormData(v),Hy(f,{pending:!0,data:j,method:v.method,action:C},C,j))},currentTarget:v}]})}}for(var Eb=0;Eb<cy.length;Eb++){var Ib=cy[Eb],Fz=Ib.toLowerCase(),Lz=Ib[0].toUpperCase()+Ib.slice(1);Er(Fz,"on"+Lz)}Er($T,"onAnimationEnd"),Er(ET,"onAnimationIteration"),Er(IT,"onAnimationStart"),Er("dblclick","onDoubleClick"),Er("focusin","onFocus"),Er("focusout","onBlur"),Er(QP,"onTransitionRun"),Er(ez,"onTransitionStart"),Er(tz,"onTransitionCancel"),Er(NT,"onTransitionEnd"),wl("onMouseEnter",["mouseout","mouseover"]),wl("onMouseLeave",["mouseout","mouseover"]),wl("onPointerEnter",["pointerout","pointerover"]),wl("onPointerLeave",["pointerout","pointerover"]),sa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),sa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),sa("onBeforeInput",["compositionend","keypress","textInput","paste"]),sa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),sa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),sa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Gu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pz=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Gu));function Y2(a,u){u=(u&4)!==0;for(var f=0;f<a.length;f++){var g=a[f],v=g.event;g=g.listeners;e:{var C=void 0;if(u)for(var I=g.length-1;0<=I;I--){var O=g[I],j=O.instance,le=O.currentTarget;if(O=O.listener,j!==C&&v.isPropagationStopped())break e;C=O,v.currentTarget=le;try{C(v)}catch(me){Mf(me)}v.currentTarget=null,C=j}else for(I=0;I<g.length;I++){if(O=g[I],j=O.instance,le=O.currentTarget,O=O.listener,j!==C&&v.isPropagationStopped())break e;C=O,v.currentTarget=le;try{C(v)}catch(me){Mf(me)}v.currentTarget=null,C=j}}}}function ot(a,u){var f=u[V0];f===void 0&&(f=u[V0]=new Set);var g=a+"__bubble";f.has(g)||(J2(u,a,2,!1),f.add(g))}function Nb(a,u,f){var g=0;u&&(g|=4),J2(f,a,g,u)}var wp="_reactListening"+Math.random().toString(36).slice(2);function Ab(a){if(!a[wp]){a[wp]=!0,GC.forEach(function(f){f!=="selectionchange"&&(Pz.has(f)||Nb(f,!1,a),Nb(f,!0,a))});var u=a.nodeType===9?a:a.ownerDocument;u===null||u[wp]||(u[wp]=!0,Nb("selectionchange",!1,u))}}function J2(a,u,f,g){switch($$(u)){case 2:var v=dB;break;case 8:v=fB;break;default:v=Wb}f=v.bind(null,u,f,a),v=void 0,!Y0||u!=="touchstart"&&u!=="touchmove"&&u!=="wheel"||(v=!0),g?v!==void 0?a.addEventListener(u,f,{capture:!0,passive:v}):a.addEventListener(u,f,!0):v!==void 0?a.addEventListener(u,f,{passive:v}):a.addEventListener(u,f,!1)}function _b(a,u,f,g,v){var C=g;if((u&1)===0&&(u&2)===0&&g!==null)e:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var O=g.stateNode.containerInfo;if(O===v)break;if(I===4)for(I=g.return;I!==null;){var j=I.tag;if((j===3||j===4)&&I.stateNode.containerInfo===v)return;I=I.return}for(;O!==null;){if(I=bl(O),I===null)return;if(j=I.tag,j===5||j===6||j===26||j===27){g=C=I;continue e}O=O.parentNode}}g=g.return}nT(function(){var le=C,me=K0(f),be=[];e:{var ue=AT.get(a);if(ue!==void 0){var de=Rf,Ne=a;switch(a){case"keypress":if(Af(f)===0)break e;case"keydown":case"keyup":de=_P;break;case"focusin":Ne="focus",de=ey;break;case"focusout":Ne="blur",de=ey;break;case"beforeblur":case"afterblur":de=ey;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":de=iT;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":de=xP;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":de=OP;break;case $T:case ET:case IT:de=SP;break;case NT:de=FP;break;case"scroll":case"scrollend":de=yP;break;case"wheel":de=PP;break;case"copy":case"cut":case"paste":de=TP;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":de=aT;break;case"toggle":case"beforetoggle":de=BP}var Be=(u&4)!==0,Nt=!Be&&(a==="scroll"||a==="scrollend"),se=Be?ue!==null?ue+"Capture":null:ue;Be=[];for(var q=le,ae;q!==null;){var ge=q;if(ae=ge.stateNode,ge=ge.tag,ge!==5&&ge!==26&&ge!==27||ae===null||se===null||(ge=du(q,se),ge!=null&&Be.push(Wu(q,ge,ae))),Nt)break;q=q.return}0<Be.length&&(ue=new de(ue,Ne,null,f,me),be.push({event:ue,listeners:Be}))}}if((u&7)===0){e:{if(ue=a==="mouseover"||a==="pointerover",de=a==="mouseout"||a==="pointerout",ue&&f!==q0&&(Ne=f.relatedTarget||f.fromElement)&&(bl(Ne)||Ne[yl]))break e;if((de||ue)&&(ue=me.window===me?me:(ue=me.ownerDocument)?ue.defaultView||ue.parentWindow:window,de?(Ne=f.relatedTarget||f.toElement,de=le,Ne=Ne?bl(Ne):null,Ne!==null&&(Nt=i(Ne),Be=Ne.tag,Ne!==Nt||Be!==5&&Be!==27&&Be!==6)&&(Ne=null)):(de=null,Ne=le),de!==Ne)){if(Be=iT,ge="onMouseLeave",se="onMouseEnter",q="mouse",(a==="pointerout"||a==="pointerover")&&(Be=aT,ge="onPointerLeave",se="onPointerEnter",q="pointer"),Nt=de==null?ue:hu(de),ae=Ne==null?ue:hu(Ne),ue=new Be(ge,q+"leave",de,f,me),ue.target=Nt,ue.relatedTarget=ae,ge=null,bl(me)===le&&(Be=new Be(se,q+"enter",Ne,f,me),Be.target=ae,Be.relatedTarget=Nt,ge=Be),Nt=ge,de&&Ne)t:{for(Be=zz,se=de,q=Ne,ae=0,ge=se;ge;ge=Be(ge))ae++;ge=0;for(var Fe=q;Fe;Fe=Be(Fe))ge++;for(;0<ae-ge;)se=Be(se),ae--;for(;0<ge-ae;)q=Be(q),ge--;for(;ae--;){if(se===q||q!==null&&se===q.alternate){Be=se;break t}se=Be(se),q=Be(q)}Be=null}else Be=null;de!==null&&Z2(be,ue,de,Be,!1),Ne!==null&&Nt!==null&&Z2(be,Nt,Ne,Be,!0)}}e:{if(ue=le?hu(le):window,de=ue.nodeName&&ue.nodeName.toLowerCase(),de==="select"||de==="input"&&ue.type==="file")var mt=mT;else if(fT(ue))if(gT)mt=YP;else{mt=KP;var Re=qP}else de=ue.nodeName,!de||de.toLowerCase()!=="input"||ue.type!=="checkbox"&&ue.type!=="radio"?le&&H0(le.elementType)&&(mt=mT):mt=XP;if(mt&&(mt=mt(a,le))){pT(be,mt,f,me);break e}Re&&Re(a,ue,le),a==="focusout"&&le&&ue.type==="number"&&le.memoizedProps.value!=null&&W0(ue,"number",ue.value)}switch(Re=le?hu(le):window,a){case"focusin":(fT(Re)||Re.contentEditable==="true")&&(El=Re,oy=le,vu=null);break;case"focusout":vu=oy=El=null;break;case"mousedown":ay=!0;break;case"contextmenu":case"mouseup":case"dragend":ay=!1,TT(be,f,me);break;case"selectionchange":if(ZP)break;case"keydown":case"keyup":TT(be,f,me)}var et;if(ny)e:{switch(a){case"compositionstart":var lt="onCompositionStart";break e;case"compositionend":lt="onCompositionEnd";break e;case"compositionupdate":lt="onCompositionUpdate";break e}lt=void 0}else $l?hT(a,f)&&(lt="onCompositionEnd"):a==="keydown"&&f.keyCode===229&&(lt="onCompositionStart");lt&&(lT&&f.locale!=="ko"&&($l||lt!=="onCompositionStart"?lt==="onCompositionEnd"&&$l&&(et=sT()):(eo=me,J0="value"in eo?eo.value:eo.textContent,$l=!0)),Re=Sp(le,lt),0<Re.length&&(lt=new oT(lt,a,null,f,me),be.push({event:lt,listeners:Re}),et?lt.data=et:(et=dT(f),et!==null&&(lt.data=et)))),(et=UP?jP(a,f):GP(a,f))&&(lt=Sp(le,"onBeforeInput"),0<lt.length&&(Re=new oT("onBeforeInput","beforeinput",null,f,me),be.push({event:Re,listeners:lt}),Re.data=et)),Mz(be,a,le,f,me)}Y2(be,u)})}function Wu(a,u,f){return{instance:a,listener:u,currentTarget:f}}function Sp(a,u){for(var f=u+"Capture",g=[];a!==null;){var v=a,C=v.stateNode;if(v=v.tag,v!==5&&v!==26&&v!==27||C===null||(v=du(a,f),v!=null&&g.unshift(Wu(a,v,C)),v=du(a,u),v!=null&&g.push(Wu(a,v,C))),a.tag===3)return g;a=a.return}return[]}function zz(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function Z2(a,u,f,g,v){for(var C=u._reactName,I=[];f!==null&&f!==g;){var O=f,j=O.alternate,le=O.stateNode;if(O=O.tag,j!==null&&j===g)break;O!==5&&O!==26&&O!==27||le===null||(j=le,v?(le=du(f,C),le!=null&&I.unshift(Wu(f,le,j))):v||(le=du(f,C),le!=null&&I.push(Wu(f,le,j)))),f=f.return}I.length!==0&&a.push({event:u,listeners:I})}var Bz=/\r\n?/g,Vz=/\u0000|\uFFFD/g;function Q2(a){return(typeof a=="string"?a:""+a).replace(Bz,`
`).replace(Vz,"")}function e$(a,u){return u=Q2(u),Q2(a)===u}function It(a,u,f,g,v,C){switch(f){case"children":typeof g=="string"?u==="body"||u==="textarea"&&g===""||Cl(a,g):(typeof g=="number"||typeof g=="bigint")&&u!=="body"&&Cl(a,""+g);break;case"className":$f(a,"class",g);break;case"tabIndex":$f(a,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":$f(a,f,g);break;case"style":eT(a,g,C);break;case"data":if(u!=="object"){$f(a,"data",g);break}case"src":case"href":if(g===""&&(u!=="a"||f!=="href")){a.removeAttribute(f);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=If(""+g),a.setAttribute(f,g);break;case"action":case"formAction":if(typeof g=="function"){a.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof C=="function"&&(f==="formAction"?(u!=="input"&&It(a,u,"name",v.name,v,null),It(a,u,"formEncType",v.formEncType,v,null),It(a,u,"formMethod",v.formMethod,v,null),It(a,u,"formTarget",v.formTarget,v,null)):(It(a,u,"encType",v.encType,v,null),It(a,u,"method",v.method,v,null),It(a,u,"target",v.target,v,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=If(""+g),a.setAttribute(f,g);break;case"onClick":g!=null&&(a.onclick=wi);break;case"onScroll":g!=null&&ot("scroll",a);break;case"onScrollEnd":g!=null&&ot("scrollend",a);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"multiple":a.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":a.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){a.removeAttribute("xlink:href");break}f=If(""+g),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""+g):a.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""):a.removeAttribute(f);break;case"capture":case"download":g===!0?a.setAttribute(f,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,g):a.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?a.setAttribute(f,g):a.removeAttribute(f);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?a.removeAttribute(f):a.setAttribute(f,g);break;case"popover":ot("beforetoggle",a),ot("toggle",a),kf(a,"popover",g);break;case"xlinkActuate":vi(a,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":vi(a,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":vi(a,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":vi(a,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":vi(a,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":vi(a,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":vi(a,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":vi(a,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":vi(a,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":kf(a,"is",g);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=mP.get(f)||f,kf(a,f,g))}}function Rb(a,u,f,g,v,C){switch(f){case"style":eT(a,g,C);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"children":typeof g=="string"?Cl(a,g):(typeof g=="number"||typeof g=="bigint")&&Cl(a,""+g);break;case"onScroll":g!=null&&ot("scroll",a);break;case"onScrollEnd":g!=null&&ot("scrollend",a);break;case"onClick":g!=null&&(a.onclick=wi);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!WC.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(v=f.endsWith("Capture"),u=f.slice(2,v?f.length-7:void 0),C=a[xs]||null,C=C!=null?C[f]:null,typeof C=="function"&&a.removeEventListener(u,C,v),typeof g=="function")){typeof C!="function"&&C!==null&&(f in a?a[f]=null:a.hasAttribute(f)&&a.removeAttribute(f)),a.addEventListener(u,g,v);break e}f in a?a[f]=g:g===!0?a.setAttribute(f,""):kf(a,f,g)}}}function Un(a,u,f){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":ot("error",a),ot("load",a);var g=!1,v=!1,C;for(C in f)if(f.hasOwnProperty(C)){var I=f[C];if(I!=null)switch(C){case"src":g=!0;break;case"srcSet":v=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:It(a,u,C,I,f,null)}}v&&It(a,u,"srcSet",f.srcSet,f,null),g&&It(a,u,"src",f.src,f,null);return;case"input":ot("invalid",a);var O=C=I=v=null,j=null,le=null;for(g in f)if(f.hasOwnProperty(g)){var me=f[g];if(me!=null)switch(g){case"name":v=me;break;case"type":I=me;break;case"checked":j=me;break;case"defaultChecked":le=me;break;case"value":C=me;break;case"defaultValue":O=me;break;case"children":case"dangerouslySetInnerHTML":if(me!=null)throw Error(s(137,u));break;default:It(a,u,g,me,f,null)}}YC(a,C,O,j,le,I,v,!1);return;case"select":ot("invalid",a),g=I=C=null;for(v in f)if(f.hasOwnProperty(v)&&(O=f[v],O!=null))switch(v){case"value":C=O;break;case"defaultValue":I=O;break;case"multiple":g=O;default:It(a,u,v,O,f,null)}u=C,f=I,a.multiple=!!g,u!=null?Sl(a,!!g,u,!1):f!=null&&Sl(a,!!g,f,!0);return;case"textarea":ot("invalid",a),C=v=g=null;for(I in f)if(f.hasOwnProperty(I)&&(O=f[I],O!=null))switch(I){case"value":g=O;break;case"defaultValue":v=O;break;case"children":C=O;break;case"dangerouslySetInnerHTML":if(O!=null)throw Error(s(91));break;default:It(a,u,I,O,f,null)}ZC(a,g,v,C);return;case"option":for(j in f)f.hasOwnProperty(j)&&(g=f[j],g!=null)&&(j==="selected"?a.selected=g&&typeof g!="function"&&typeof g!="symbol":It(a,u,j,g,f,null));return;case"dialog":ot("beforetoggle",a),ot("toggle",a),ot("cancel",a),ot("close",a);break;case"iframe":case"object":ot("load",a);break;case"video":case"audio":for(g=0;g<Gu.length;g++)ot(Gu[g],a);break;case"image":ot("error",a),ot("load",a);break;case"details":ot("toggle",a);break;case"embed":case"source":case"link":ot("error",a),ot("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(le in f)if(f.hasOwnProperty(le)&&(g=f[le],g!=null))switch(le){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:It(a,u,le,g,f,null)}return;default:if(H0(u)){for(me in f)f.hasOwnProperty(me)&&(g=f[me],g!==void 0&&Rb(a,u,me,g,f,void 0));return}}for(O in f)f.hasOwnProperty(O)&&(g=f[O],g!=null&&It(a,u,O,g,f,null))}function Uz(a,u,f,g){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var v=null,C=null,I=null,O=null,j=null,le=null,me=null;for(de in f){var be=f[de];if(f.hasOwnProperty(de)&&be!=null)switch(de){case"checked":break;case"value":break;case"defaultValue":j=be;default:g.hasOwnProperty(de)||It(a,u,de,null,g,be)}}for(var ue in g){var de=g[ue];if(be=f[ue],g.hasOwnProperty(ue)&&(de!=null||be!=null))switch(ue){case"type":C=de;break;case"name":v=de;break;case"checked":le=de;break;case"defaultChecked":me=de;break;case"value":I=de;break;case"defaultValue":O=de;break;case"children":case"dangerouslySetInnerHTML":if(de!=null)throw Error(s(137,u));break;default:de!==be&&It(a,u,ue,de,g,be)}}G0(a,I,O,j,le,me,C,v);return;case"select":de=I=O=ue=null;for(C in f)if(j=f[C],f.hasOwnProperty(C)&&j!=null)switch(C){case"value":break;case"multiple":de=j;default:g.hasOwnProperty(C)||It(a,u,C,null,g,j)}for(v in g)if(C=g[v],j=f[v],g.hasOwnProperty(v)&&(C!=null||j!=null))switch(v){case"value":ue=C;break;case"defaultValue":O=C;break;case"multiple":I=C;default:C!==j&&It(a,u,v,C,g,j)}u=O,f=I,g=de,ue!=null?Sl(a,!!f,ue,!1):!!g!=!!f&&(u!=null?Sl(a,!!f,u,!0):Sl(a,!!f,f?[]:"",!1));return;case"textarea":de=ue=null;for(O in f)if(v=f[O],f.hasOwnProperty(O)&&v!=null&&!g.hasOwnProperty(O))switch(O){case"value":break;case"children":break;default:It(a,u,O,null,g,v)}for(I in g)if(v=g[I],C=f[I],g.hasOwnProperty(I)&&(v!=null||C!=null))switch(I){case"value":ue=v;break;case"defaultValue":de=v;break;case"children":break;case"dangerouslySetInnerHTML":if(v!=null)throw Error(s(91));break;default:v!==C&&It(a,u,I,v,g,C)}JC(a,ue,de);return;case"option":for(var Ne in f)ue=f[Ne],f.hasOwnProperty(Ne)&&ue!=null&&!g.hasOwnProperty(Ne)&&(Ne==="selected"?a.selected=!1:It(a,u,Ne,null,g,ue));for(j in g)ue=g[j],de=f[j],g.hasOwnProperty(j)&&ue!==de&&(ue!=null||de!=null)&&(j==="selected"?a.selected=ue&&typeof ue!="function"&&typeof ue!="symbol":It(a,u,j,ue,g,de));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Be in f)ue=f[Be],f.hasOwnProperty(Be)&&ue!=null&&!g.hasOwnProperty(Be)&&It(a,u,Be,null,g,ue);for(le in g)if(ue=g[le],de=f[le],g.hasOwnProperty(le)&&ue!==de&&(ue!=null||de!=null))switch(le){case"children":case"dangerouslySetInnerHTML":if(ue!=null)throw Error(s(137,u));break;default:It(a,u,le,ue,g,de)}return;default:if(H0(u)){for(var Nt in f)ue=f[Nt],f.hasOwnProperty(Nt)&&ue!==void 0&&!g.hasOwnProperty(Nt)&&Rb(a,u,Nt,void 0,g,ue);for(me in g)ue=g[me],de=f[me],!g.hasOwnProperty(me)||ue===de||ue===void 0&&de===void 0||Rb(a,u,me,ue,g,de);return}}for(var se in f)ue=f[se],f.hasOwnProperty(se)&&ue!=null&&!g.hasOwnProperty(se)&&It(a,u,se,null,g,ue);for(be in g)ue=g[be],de=f[be],!g.hasOwnProperty(be)||ue===de||ue==null&&de==null||It(a,u,be,ue,g,de)}function t$(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function jz(){if(typeof performance.getEntriesByType=="function"){for(var a=0,u=0,f=performance.getEntriesByType("resource"),g=0;g<f.length;g++){var v=f[g],C=v.transferSize,I=v.initiatorType,O=v.duration;if(C&&O&&t$(I)){for(I=0,O=v.responseEnd,g+=1;g<f.length;g++){var j=f[g],le=j.startTime;if(le>O)break;var me=j.transferSize,be=j.initiatorType;me&&t$(be)&&(j=j.responseEnd,I+=me*(j<O?1:(O-le)/(j-le)))}if(--g,u+=8*(C+I)/(v.duration/1e3),a++,10<a)break}}if(0<a)return u/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var Db=null,Ob=null;function Cp(a){return a.nodeType===9?a:a.ownerDocument}function n$(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function s$(a,u){if(a===0)switch(u){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&u==="foreignObject"?0:a}function Mb(a,u){return a==="textarea"||a==="noscript"||typeof u.children=="string"||typeof u.children=="number"||typeof u.children=="bigint"||typeof u.dangerouslySetInnerHTML=="object"&&u.dangerouslySetInnerHTML!==null&&u.dangerouslySetInnerHTML.__html!=null}var Fb=null;function Gz(){var a=window.event;return a&&a.type==="popstate"?a===Fb?!1:(Fb=a,!0):(Fb=null,!1)}var r$=typeof setTimeout=="function"?setTimeout:void 0,Wz=typeof clearTimeout=="function"?clearTimeout:void 0,i$=typeof Promise=="function"?Promise:void 0,Hz=typeof queueMicrotask=="function"?queueMicrotask:typeof i$<"u"?function(a){return i$.resolve(null).then(a).catch(qz)}:r$;function qz(a){setTimeout(function(){throw a})}function bo(a){return a==="head"}function o$(a,u){var f=u,g=0;do{var v=f.nextSibling;if(a.removeChild(f),v&&v.nodeType===8)if(f=v.data,f==="/$"||f==="/&"){if(g===0){a.removeChild(v),ec(u);return}g--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")g++;else if(f==="html")Hu(a.ownerDocument.documentElement);else if(f==="head"){f=a.ownerDocument.head,Hu(f);for(var C=f.firstChild;C;){var I=C.nextSibling,O=C.nodeName;C[uu]||O==="SCRIPT"||O==="STYLE"||O==="LINK"&&C.rel.toLowerCase()==="stylesheet"||f.removeChild(C),C=I}}else f==="body"&&Hu(a.ownerDocument.body);f=v}while(f);ec(u)}function a$(a,u){var f=a;a=0;do{var g=f.nextSibling;if(f.nodeType===1?u?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(u?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),g&&g.nodeType===8)if(f=g.data,f==="/$"){if(a===0)break;a--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||a++;f=g}while(f)}function Lb(a){var u=a.firstChild;for(u&&u.nodeType===10&&(u=u.nextSibling);u;){var f=u;switch(u=u.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":Lb(f),U0(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}a.removeChild(f)}}function Kz(a,u,f,g){for(;a.nodeType===1;){var v=f;if(a.nodeName.toLowerCase()!==u.toLowerCase()){if(!g&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(g){if(!a[uu])switch(u){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(C=a.getAttribute("rel"),C==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(C!==v.rel||a.getAttribute("href")!==(v.href==null||v.href===""?null:v.href)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin)||a.getAttribute("title")!==(v.title==null?null:v.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(C=a.getAttribute("src"),(C!==(v.src==null?null:v.src)||a.getAttribute("type")!==(v.type==null?null:v.type)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin))&&C&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(u==="input"&&a.type==="hidden"){var C=v.name==null?null:""+v.name;if(v.type==="hidden"&&a.getAttribute("name")===C)return a}else return a;if(a=ar(a.nextSibling),a===null)break}return null}function Xz(a,u,f){if(u==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!f||(a=ar(a.nextSibling),a===null))return null;return a}function l$(a,u){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!u||(a=ar(a.nextSibling),a===null))return null;return a}function Pb(a){return a.data==="$?"||a.data==="$~"}function zb(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function Yz(a,u){var f=a.ownerDocument;if(a.data==="$~")a._reactRetry=u;else if(a.data!=="$?"||f.readyState!=="loading")u();else{var g=function(){u(),f.removeEventListener("DOMContentLoaded",g)};f.addEventListener("DOMContentLoaded",g),a._reactRetry=g}}function ar(a){for(;a!=null;a=a.nextSibling){var u=a.nodeType;if(u===1||u===3)break;if(u===8){if(u=a.data,u==="$"||u==="$!"||u==="$?"||u==="$~"||u==="&"||u==="F!"||u==="F")break;if(u==="/$"||u==="/&")return null}}return a}var Bb=null;function c$(a){a=a.nextSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="/$"||f==="/&"){if(u===0)return ar(a.nextSibling);u--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||u++}a=a.nextSibling}return null}function u$(a){a=a.previousSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(u===0)return a;u--}else f!=="/$"&&f!=="/&"||u++}a=a.previousSibling}return null}function h$(a,u,f){switch(u=Cp(f),a){case"html":if(a=u.documentElement,!a)throw Error(s(452));return a;case"head":if(a=u.head,!a)throw Error(s(453));return a;case"body":if(a=u.body,!a)throw Error(s(454));return a;default:throw Error(s(451))}}function Hu(a){for(var u=a.attributes;u.length;)a.removeAttributeNode(u[0]);U0(a)}var lr=new Map,d$=new Set;function Tp(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var Li=B.d;B.d={f:Jz,r:Zz,D:Qz,C:eB,L:tB,m:nB,X:rB,S:sB,M:iB};function Jz(){var a=Li.f(),u=mp();return a||u}function Zz(a){var u=xl(a);u!==null&&u.tag===5&&u.type==="form"?Nk(u):Li.r(a)}var Jl=typeof document>"u"?null:document;function f$(a,u,f){var g=Jl;if(g&&typeof u=="string"&&u){var v=er(u);v='link[rel="'+a+'"][href="'+v+'"]',typeof f=="string"&&(v+='[crossorigin="'+f+'"]'),d$.has(v)||(d$.add(v),a={rel:a,crossOrigin:f,href:u},g.querySelector(v)===null&&(u=g.createElement("link"),Un(u,"link",a),_n(u),g.head.appendChild(u)))}}function Qz(a){Li.D(a),f$("dns-prefetch",a,null)}function eB(a,u){Li.C(a,u),f$("preconnect",a,u)}function tB(a,u,f){Li.L(a,u,f);var g=Jl;if(g&&a&&u){var v='link[rel="preload"][as="'+er(u)+'"]';u==="image"&&f&&f.imageSrcSet?(v+='[imagesrcset="'+er(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(v+='[imagesizes="'+er(f.imageSizes)+'"]')):v+='[href="'+er(a)+'"]';var C=v;switch(u){case"style":C=Zl(a);break;case"script":C=Ql(a)}lr.has(C)||(a=p({rel:"preload",href:u==="image"&&f&&f.imageSrcSet?void 0:a,as:u},f),lr.set(C,a),g.querySelector(v)!==null||u==="style"&&g.querySelector(qu(C))||u==="script"&&g.querySelector(Ku(C))||(u=g.createElement("link"),Un(u,"link",a),_n(u),g.head.appendChild(u)))}}function nB(a,u){Li.m(a,u);var f=Jl;if(f&&a){var g=u&&typeof u.as=="string"?u.as:"script",v='link[rel="modulepreload"][as="'+er(g)+'"][href="'+er(a)+'"]',C=v;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":C=Ql(a)}if(!lr.has(C)&&(a=p({rel:"modulepreload",href:a},u),lr.set(C,a),f.querySelector(v)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(Ku(C)))return}g=f.createElement("link"),Un(g,"link",a),_n(g),f.head.appendChild(g)}}}function sB(a,u,f){Li.S(a,u,f);var g=Jl;if(g&&a){var v=vl(g).hoistableStyles,C=Zl(a);u=u||"default";var I=v.get(C);if(!I){var O={loading:0,preload:null};if(I=g.querySelector(qu(C)))O.loading=5;else{a=p({rel:"stylesheet",href:a,"data-precedence":u},f),(f=lr.get(C))&&Vb(a,f);var j=I=g.createElement("link");_n(j),Un(j,"link",a),j._p=new Promise(function(le,me){j.onload=le,j.onerror=me}),j.addEventListener("load",function(){O.loading|=1}),j.addEventListener("error",function(){O.loading|=2}),O.loading|=4,kp(I,u,g)}I={type:"stylesheet",instance:I,count:1,state:O},v.set(C,I)}}}function rB(a,u){Li.X(a,u);var f=Jl;if(f&&a){var g=vl(f).hoistableScripts,v=Ql(a),C=g.get(v);C||(C=f.querySelector(Ku(v)),C||(a=p({src:a,async:!0},u),(u=lr.get(v))&&Ub(a,u),C=f.createElement("script"),_n(C),Un(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function iB(a,u){Li.M(a,u);var f=Jl;if(f&&a){var g=vl(f).hoistableScripts,v=Ql(a),C=g.get(v);C||(C=f.querySelector(Ku(v)),C||(a=p({src:a,async:!0,type:"module"},u),(u=lr.get(v))&&Ub(a,u),C=f.createElement("script"),_n(C),Un(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function p$(a,u,f,g){var v=(v=ye.current)?Tp(v):null;if(!v)throw Error(s(446));switch(a){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(u=Zl(f.href),f=vl(v).hoistableStyles,g=f.get(u),g||(g={type:"style",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){a=Zl(f.href);var C=vl(v).hoistableStyles,I=C.get(a);if(I||(v=v.ownerDocument||v,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},C.set(a,I),(C=v.querySelector(qu(a)))&&!C._p&&(I.instance=C,I.state.loading=5),lr.has(a)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},lr.set(a,f),C||oB(v,a,f,I.state))),u&&g===null)throw Error(s(528,""));return I}if(u&&g!==null)throw Error(s(529,""));return null;case"script":return u=f.async,f=f.src,typeof f=="string"&&u&&typeof u!="function"&&typeof u!="symbol"?(u=Ql(f),f=vl(v).hoistableScripts,g=f.get(u),g||(g={type:"script",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,a))}}function Zl(a){return'href="'+er(a)+'"'}function qu(a){return'link[rel="stylesheet"]['+a+"]"}function m$(a){return p({},a,{"data-precedence":a.precedence,precedence:null})}function oB(a,u,f,g){a.querySelector('link[rel="preload"][as="style"]['+u+"]")?g.loading=1:(u=a.createElement("link"),g.preload=u,u.addEventListener("load",function(){return g.loading|=1}),u.addEventListener("error",function(){return g.loading|=2}),Un(u,"link",f),_n(u),a.head.appendChild(u))}function Ql(a){return'[src="'+er(a)+'"]'}function Ku(a){return"script[async]"+a}function g$(a,u,f){if(u.count++,u.instance===null)switch(u.type){case"style":var g=a.querySelector('style[data-href~="'+er(f.href)+'"]');if(g)return u.instance=g,_n(g),g;var v=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return g=(a.ownerDocument||a).createElement("style"),_n(g),Un(g,"style",v),kp(g,f.precedence,a),u.instance=g;case"stylesheet":v=Zl(f.href);var C=a.querySelector(qu(v));if(C)return u.state.loading|=4,u.instance=C,_n(C),C;g=m$(f),(v=lr.get(v))&&Vb(g,v),C=(a.ownerDocument||a).createElement("link"),_n(C);var I=C;return I._p=new Promise(function(O,j){I.onload=O,I.onerror=j}),Un(C,"link",g),u.state.loading|=4,kp(C,f.precedence,a),u.instance=C;case"script":return C=Ql(f.src),(v=a.querySelector(Ku(C)))?(u.instance=v,_n(v),v):(g=f,(v=lr.get(C))&&(g=p({},f),Ub(g,v)),a=a.ownerDocument||a,v=a.createElement("script"),_n(v),Un(v,"link",g),a.head.appendChild(v),u.instance=v);case"void":return null;default:throw Error(s(443,u.type))}else u.type==="stylesheet"&&(u.state.loading&4)===0&&(g=u.instance,u.state.loading|=4,kp(g,f.precedence,a));return u.instance}function kp(a,u,f){for(var g=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),v=g.length?g[g.length-1]:null,C=v,I=0;I<g.length;I++){var O=g[I];if(O.dataset.precedence===u)C=O;else if(C!==v)break}C?C.parentNode.insertBefore(a,C.nextSibling):(u=f.nodeType===9?f.head:f,u.insertBefore(a,u.firstChild))}function Vb(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.title==null&&(a.title=u.title)}function Ub(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.integrity==null&&(a.integrity=u.integrity)}var $p=null;function y$(a,u,f){if($p===null){var g=new Map,v=$p=new Map;v.set(f,g)}else v=$p,g=v.get(f),g||(g=new Map,v.set(f,g));if(g.has(a))return g;for(g.set(a,null),f=f.getElementsByTagName(a),v=0;v<f.length;v++){var C=f[v];if(!(C[uu]||C[Pn]||a==="link"&&C.getAttribute("rel")==="stylesheet")&&C.namespaceURI!=="http://www.w3.org/2000/svg"){var I=C.getAttribute(u)||"";I=a+I;var O=g.get(I);O?O.push(C):g.set(I,[C])}}return g}function b$(a,u,f){a=a.ownerDocument||a,a.head.insertBefore(f,u==="title"?a.querySelector("head > title"):null)}function aB(a,u,f){if(f===1||u.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof u.precedence!="string"||typeof u.href!="string"||u.href==="")break;return!0;case"link":if(typeof u.rel!="string"||typeof u.href!="string"||u.href===""||u.onLoad||u.onError)break;return u.rel==="stylesheet"?(a=u.disabled,typeof u.precedence=="string"&&a==null):!0;case"script":if(u.async&&typeof u.async!="function"&&typeof u.async!="symbol"&&!u.onLoad&&!u.onError&&u.src&&typeof u.src=="string")return!0}return!1}function x$(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function lB(a,u,f,g){if(f.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var v=Zl(g.href),C=u.querySelector(qu(v));if(C){u=C._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(a.count++,a=Ep.bind(a),u.then(a,a)),f.state.loading|=4,f.instance=C,_n(C);return}C=u.ownerDocument||u,g=m$(g),(v=lr.get(v))&&Vb(g,v),C=C.createElement("link"),_n(C);var I=C;I._p=new Promise(function(O,j){I.onload=O,I.onerror=j}),Un(C,"link",g),f.instance=C}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(f,u),(u=f.state.preload)&&(f.state.loading&3)===0&&(a.count++,f=Ep.bind(a),u.addEventListener("load",f),u.addEventListener("error",f))}}var jb=0;function cB(a,u){return a.stylesheets&&a.count===0&&Np(a,a.stylesheets),0<a.count||0<a.imgCount?function(f){var g=setTimeout(function(){if(a.stylesheets&&Np(a,a.stylesheets),a.unsuspend){var C=a.unsuspend;a.unsuspend=null,C()}},6e4+u);0<a.imgBytes&&jb===0&&(jb=62500*jz());var v=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&Np(a,a.stylesheets),a.unsuspend)){var C=a.unsuspend;a.unsuspend=null,C()}},(a.imgBytes>jb?50:800)+u);return a.unsuspend=f,function(){a.unsuspend=null,clearTimeout(g),clearTimeout(v)}}:null}function Ep(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Np(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var Ip=null;function Np(a,u){a.stylesheets=null,a.unsuspend!==null&&(a.count++,Ip=new Map,u.forEach(uB,a),Ip=null,Ep.call(a))}function uB(a,u){if(!(u.state.loading&4)){var f=Ip.get(a);if(f)var g=f.get(null);else{f=new Map,Ip.set(a,f);for(var v=a.querySelectorAll("link[data-precedence],style[data-precedence]"),C=0;C<v.length;C++){var I=v[C];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(f.set(I.dataset.precedence,I),g=I)}g&&f.set(null,g)}v=u.instance,I=v.getAttribute("data-precedence"),C=f.get(I)||g,C===g&&f.set(null,v),f.set(I,v),this.count++,g=Ep.bind(this),v.addEventListener("load",g),v.addEventListener("error",g),C?C.parentNode.insertBefore(v,C.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(v,a.firstChild)),u.state.loading|=4}}var Xu={$$typeof:k,Provider:null,Consumer:null,_currentValue:G,_currentValue2:G,_threadCount:0};function hB(a,u,f,g,v,C,I,O,j){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=P0(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=P0(0),this.hiddenUpdates=P0(null),this.identifierPrefix=g,this.onUncaughtError=v,this.onCaughtError=C,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=j,this.incompleteTransitions=new Map}function v$(a,u,f,g,v,C,I,O,j,le,me,be){return a=new hB(a,u,f,I,j,le,me,be,O),u=1,C===!0&&(u|=24),C=Ls(3,null,null,u),a.current=C,C.stateNode=a,u=Sy(),u.refCount++,a.pooledCache=u,u.refCount++,C.memoizedState={element:g,isDehydrated:f,cache:u},$y(C),a}function w$(a){return a?(a=Al,a):Al}function S$(a,u,f,g,v,C){v=w$(v),g.context===null?g.context=v:g.pendingContext=v,g=oo(u),g.payload={element:f},C=C===void 0?null:C,C!==null&&(g.callback=C),f=ao(a,g,u),f!==null&&(ks(f,a,u),Eu(f,a,u))}function C$(a,u){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var f=a.retryLane;a.retryLane=f!==0&&f<u?f:u}}function Gb(a,u){C$(a,u),(a=a.alternate)&&C$(a,u)}function T$(a){if(a.tag===13||a.tag===31){var u=aa(a,67108864);u!==null&&ks(u,a,67108864),Gb(a,67108864)}}function k$(a){if(a.tag===13||a.tag===31){var u=Us();u=z0(u);var f=aa(a,u);f!==null&&ks(f,a,u),Gb(a,u)}}var Ap=!0;function dB(a,u,f,g){var v=P.T;P.T=null;var C=B.p;try{B.p=2,Wb(a,u,f,g)}finally{B.p=C,P.T=v}}function fB(a,u,f,g){var v=P.T;P.T=null;var C=B.p;try{B.p=8,Wb(a,u,f,g)}finally{B.p=C,P.T=v}}function Wb(a,u,f,g){if(Ap){var v=Hb(g);if(v===null)_b(a,u,g,_p,f),E$(a,g);else if(mB(v,a,u,f,g))g.stopPropagation();else if(E$(a,g),u&4&&-1<pB.indexOf(a)){for(;v!==null;){var C=xl(v);if(C!==null)switch(C.tag){case 3:if(C=C.stateNode,C.current.memoizedState.isDehydrated){var I=na(C.pendingLanes);if(I!==0){var O=C;for(O.pendingLanes|=2,O.entangledLanes|=2;I;){var j=1<<31-Ms(I);O.entanglements[1]|=j,I&=~j}Zr(C),(vt&6)===0&&(fp=Lt()+500,ju(0))}}break;case 31:case 13:O=aa(C,2),O!==null&&ks(O,C,2),mp(),Gb(C,2)}if(C=Hb(g),C===null&&_b(a,u,g,_p,f),C===v)break;v=C}v!==null&&g.stopPropagation()}else _b(a,u,g,null,f)}}function Hb(a){return a=K0(a),qb(a)}var _p=null;function qb(a){if(_p=null,a=bl(a),a!==null){var u=i(a);if(u===null)a=null;else{var f=u.tag;if(f===13){if(a=o(u),a!==null)return a;a=null}else if(f===31){if(a=l(u),a!==null)return a;a=null}else if(f===3){if(u.stateNode.current.memoizedState.isDehydrated)return u.tag===3?u.stateNode.containerInfo:null;a=null}else u!==a&&(a=null)}}return _p=a,null}function $$(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Tr()){case kr:return 2;case $r:return 8;case Os:case ta:return 32;case gl:return 268435456;default:return 32}default:return 32}}var Kb=!1,xo=null,vo=null,wo=null,Yu=new Map,Ju=new Map,So=[],pB="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function E$(a,u){switch(a){case"focusin":case"focusout":xo=null;break;case"dragenter":case"dragleave":vo=null;break;case"mouseover":case"mouseout":wo=null;break;case"pointerover":case"pointerout":Yu.delete(u.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ju.delete(u.pointerId)}}function Zu(a,u,f,g,v,C){return a===null||a.nativeEvent!==C?(a={blockedOn:u,domEventName:f,eventSystemFlags:g,nativeEvent:C,targetContainers:[v]},u!==null&&(u=xl(u),u!==null&&T$(u)),a):(a.eventSystemFlags|=g,u=a.targetContainers,v!==null&&u.indexOf(v)===-1&&u.push(v),a)}function mB(a,u,f,g,v){switch(u){case"focusin":return xo=Zu(xo,a,u,f,g,v),!0;case"dragenter":return vo=Zu(vo,a,u,f,g,v),!0;case"mouseover":return wo=Zu(wo,a,u,f,g,v),!0;case"pointerover":var C=v.pointerId;return Yu.set(C,Zu(Yu.get(C)||null,a,u,f,g,v)),!0;case"gotpointercapture":return C=v.pointerId,Ju.set(C,Zu(Ju.get(C)||null,a,u,f,g,v)),!0}return!1}function I$(a){var u=bl(a.target);if(u!==null){var f=i(u);if(f!==null){if(u=f.tag,u===13){if(u=o(f),u!==null){a.blockedOn=u,UC(a.priority,function(){k$(f)});return}}else if(u===31){if(u=l(f),u!==null){a.blockedOn=u,UC(a.priority,function(){k$(f)});return}}else if(u===3&&f.stateNode.current.memoizedState.isDehydrated){a.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Rp(a){if(a.blockedOn!==null)return!1;for(var u=a.targetContainers;0<u.length;){var f=Hb(a.nativeEvent);if(f===null){f=a.nativeEvent;var g=new f.constructor(f.type,f);q0=g,f.target.dispatchEvent(g),q0=null}else return u=xl(f),u!==null&&T$(u),a.blockedOn=f,!1;u.shift()}return!0}function N$(a,u,f){Rp(a)&&f.delete(u)}function gB(){Kb=!1,xo!==null&&Rp(xo)&&(xo=null),vo!==null&&Rp(vo)&&(vo=null),wo!==null&&Rp(wo)&&(wo=null),Yu.forEach(N$),Ju.forEach(N$)}function Dp(a,u){a.blockedOn===u&&(a.blockedOn=null,Kb||(Kb=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,gB)))}var Op=null;function A$(a){Op!==a&&(Op=a,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Op===a&&(Op=null);for(var u=0;u<a.length;u+=3){var f=a[u],g=a[u+1],v=a[u+2];if(typeof g!="function"){if(qb(g||f)===null)continue;break}var C=xl(f);C!==null&&(a.splice(u,3),u-=3,Hy(C,{pending:!0,data:v,method:f.method,action:g},g,v))}}))}function ec(a){function u(j){return Dp(j,a)}xo!==null&&Dp(xo,a),vo!==null&&Dp(vo,a),wo!==null&&Dp(wo,a),Yu.forEach(u),Ju.forEach(u);for(var f=0;f<So.length;f++){var g=So[f];g.blockedOn===a&&(g.blockedOn=null)}for(;0<So.length&&(f=So[0],f.blockedOn===null);)I$(f),f.blockedOn===null&&So.shift();if(f=(a.ownerDocument||a).$$reactFormReplay,f!=null)for(g=0;g<f.length;g+=3){var v=f[g],C=f[g+1],I=v[xs]||null;if(typeof C=="function")I||A$(f);else if(I){var O=null;if(C&&C.hasAttribute("formAction")){if(v=C,I=C[xs]||null)O=I.formAction;else if(qb(v)!==null)continue}else O=I.action;typeof O=="function"?f[g+1]=O:(f.splice(g,3),g-=3),A$(f)}}}function _$(){function a(C){C.canIntercept&&C.info==="react-transition"&&C.intercept({handler:function(){return new Promise(function(I){return v=I})},focusReset:"manual",scroll:"manual"})}function u(){v!==null&&(v(),v=null),g||setTimeout(f,20)}function f(){if(!g&&!navigation.transition){var C=navigation.currentEntry;C&&C.url!=null&&navigation.navigate(C.url,{state:C.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,v=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",u),navigation.addEventListener("navigateerror",u),setTimeout(f,100),function(){g=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",u),navigation.removeEventListener("navigateerror",u),v!==null&&(v(),v=null)}}}function Xb(a){this._internalRoot=a}Mp.prototype.render=Xb.prototype.render=function(a){var u=this._internalRoot;if(u===null)throw Error(s(409));var f=u.current,g=Us();S$(f,g,a,u,null,null)},Mp.prototype.unmount=Xb.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var u=a.containerInfo;S$(a.current,2,null,a,null,null),mp(),u[yl]=null}};function Mp(a){this._internalRoot=a}Mp.prototype.unstable_scheduleHydration=function(a){if(a){var u=VC();a={blockedOn:null,target:a,priority:u};for(var f=0;f<So.length&&u!==0&&u<So[f].priority;f++);So.splice(f,0,a),f===0&&I$(a)}};var R$=e.version;if(R$!=="19.2.3")throw Error(s(527,R$,"19.2.3"));B.findDOMNode=function(a){var u=a._reactInternals;if(u===void 0)throw typeof a.render=="function"?Error(s(188)):(a=Object.keys(a).join(","),Error(s(268,a)));return a=h(u),a=a!==null?d(a):null,a=a===null?null:a.stateNode,a};var yB={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:P,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Fp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Fp.isDisabled&&Fp.supportsFiber)try{qr=Fp.inject(yB),ls=Fp}catch{}}return eh.createRoot=function(a,u){if(!r(a))throw Error(s(299));var f=!1,g="",v=zk,C=Bk,I=Vk;return u!=null&&(u.unstable_strictMode===!0&&(f=!0),u.identifierPrefix!==void 0&&(g=u.identifierPrefix),u.onUncaughtError!==void 0&&(v=u.onUncaughtError),u.onCaughtError!==void 0&&(C=u.onCaughtError),u.onRecoverableError!==void 0&&(I=u.onRecoverableError)),u=v$(a,1,!1,null,null,f,g,null,v,C,I,_$),a[yl]=u.current,Ab(a),new Xb(u)},eh.hydrateRoot=function(a,u,f){if(!r(a))throw Error(s(299));var g=!1,v="",C=zk,I=Bk,O=Vk,j=null;return f!=null&&(f.unstable_strictMode===!0&&(g=!0),f.identifierPrefix!==void 0&&(v=f.identifierPrefix),f.onUncaughtError!==void 0&&(C=f.onUncaughtError),f.onCaughtError!==void 0&&(I=f.onCaughtError),f.onRecoverableError!==void 0&&(O=f.onRecoverableError),f.formState!==void 0&&(j=f.formState)),u=v$(a,1,!0,u,f??null,g,v,j,C,I,O,_$),u.context=w$(null),f=u.current,g=Us(),g=z0(g),v=oo(g),v.callback=null,ao(f,v,g),f=g,u.current.lanes=f,cu(u,f),Zr(u),a[yl]=u.current,Ab(a),new Mp(u)},eh.version="19.2.3",eh}var U$;function AB(){if(U$)return Zb.exports;U$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),Zb.exports=NB(),Zb.exports}var _B=AB();const RB=dw(_B),pw=Se.createContext({});function mw(n){const e=Se.useRef(null);return e.current===null&&(e.current=n()),e.current}const gw=typeof window<"u",CA=gw?Se.useLayoutEffect:Se.useEffect,ng=Se.createContext(null);function yw(n,e){n.indexOf(e)===-1&&n.push(e)}function bw(n,e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}const Ui=(n,e,t)=>t>e?e:t<n?n:t;let xw=()=>{};const ji={},TA=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function kA(n){return typeof n=="object"&&n!==null}const $A=n=>/^0[^.\s]+$/u.test(n);function vw(n){let e;return()=>(e===void 0&&(e=n()),e)}const br=n=>n,DB=(n,e)=>t=>e(n(t)),Xh=(...n)=>n.reduce(DB),kh=(n,e,t)=>{const s=e-n;return s===0?1:(t-n)/s};class ww{constructor(){this.subscriptions=[]}add(e){return yw(this.subscriptions,e),()=>bw(this.subscriptions,e)}notify(e,t,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](e,t,s);else for(let i=0;i<r;i++){const o=this.subscriptions[i];o&&o(e,t,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const ii=n=>n*1e3,mr=n=>n/1e3;function EA(n,e){return e?n*(1e3/e):0}const IA=(n,e,t)=>(((1-3*t+3*e)*n+(3*t-6*e))*n+3*e)*n,OB=1e-7,MB=12;function FB(n,e,t,s,r){let i,o,l=0;do o=e+(t-e)/2,i=IA(o,s,r)-n,i>0?t=o:e=o;while(Math.abs(i)>OB&&++l<MB);return o}function Yh(n,e,t,s){if(n===e&&t===s)return br;const r=i=>FB(i,0,1,n,t);return i=>i===0||i===1?i:IA(r(i),e,s)}const NA=n=>e=>e<=.5?n(2*e)/2:(2-n(2*(1-e)))/2,AA=n=>e=>1-n(1-e),_A=Yh(.33,1.53,.69,.99),Sw=AA(_A),RA=NA(Sw),DA=n=>(n*=2)<1?.5*Sw(n):.5*(2-Math.pow(2,-10*(n-1))),Cw=n=>1-Math.sin(Math.acos(n)),OA=AA(Cw),MA=NA(Cw),LB=Yh(.42,0,1,1),PB=Yh(0,0,.58,1),FA=Yh(.42,0,.58,1),zB=n=>Array.isArray(n)&&typeof n[0]!="number",LA=n=>Array.isArray(n)&&typeof n[0]=="number",BB={linear:br,easeIn:LB,easeInOut:FA,easeOut:PB,circIn:Cw,circInOut:MA,circOut:OA,backIn:Sw,backInOut:RA,backOut:_A,anticipate:DA},VB=n=>typeof n=="string",j$=n=>{if(LA(n)){xw(n.length===4);const[e,t,s,r]=n;return Yh(e,t,s,r)}else if(VB(n))return BB[n];return n},Lp=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function UB(n,e){let t=new Set,s=new Set,r=!1,i=!1;const o=new WeakSet;let l={delta:0,timestamp:0,isProcessing:!1};function c(d){o.has(d)&&(h.schedule(d),n()),d(l)}const h={schedule:(d,p=!1,m=!1)=>{const b=m&&r?t:s;return p&&o.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),o.delete(d)},process:d=>{if(l=d,r){i=!0;return}r=!0,[t,s]=[s,t],t.forEach(c),t.clear(),r=!1,i&&(i=!1,h.process(d))}};return h}const jB=40;function PA(n,e){let t=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},i=()=>t=!0,o=Lp.reduce((k,$)=>(k[$]=UB(i),k),{}),{setup:l,read:c,resolveKeyframes:h,preUpdate:d,update:p,preRender:m,render:y,postRender:b}=o,x=()=>{const k=ji.useManualTiming?r.timestamp:performance.now();t=!1,ji.useManualTiming||(r.delta=s?1e3/60:Math.max(Math.min(k-r.timestamp,jB),1)),r.timestamp=k,r.isProcessing=!0,l.process(r),c.process(r),h.process(r),d.process(r),p.process(r),m.process(r),y.process(r),b.process(r),r.isProcessing=!1,t&&e&&(s=!1,n(x))},w=()=>{t=!0,s=!0,r.isProcessing||n(x)};return{schedule:Lp.reduce((k,$)=>{const E=o[$];return k[$]=(N,_=!1,R=!1)=>(t||w(),E.schedule(N,_,R)),k},{}),cancel:k=>{for(let $=0;$<Lp.length;$++)o[Lp[$]].cancel(k)},state:r,steps:o}}const{schedule:jt,cancel:Mo,state:Wn,steps:nx}=PA(typeof requestAnimationFrame<"u"?requestAnimationFrame:br,!0);let rm;function GB(){rm=void 0}const Is={now:()=>(rm===void 0&&Is.set(Wn.isProcessing||ji.useManualTiming?Wn.timestamp:performance.now()),rm),set:n=>{rm=n,queueMicrotask(GB)}},zA=n=>e=>typeof e=="string"&&e.startsWith(n),BA=zA("--"),WB=zA("var(--"),Tw=n=>WB(n)?HB.test(n.split("/*")[0].trim()):!1,HB=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Uc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},$h={...Uc,transform:n=>Ui(0,1,n)},Pp={...Uc,default:1},ph=n=>Math.round(n*1e5)/1e5,kw=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function qB(n){return n==null}const KB=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,$w=(n,e)=>t=>!!(typeof t=="string"&&KB.test(t)&&t.startsWith(n)||e&&!qB(t)&&Object.prototype.hasOwnProperty.call(t,e)),VA=(n,e,t)=>s=>{if(typeof s!="string")return s;const[r,i,o,l]=s.match(kw);return{[n]:parseFloat(r),[e]:parseFloat(i),[t]:parseFloat(o),alpha:l!==void 0?parseFloat(l):1}},XB=n=>Ui(0,255,n),sx={...Uc,transform:n=>Math.round(XB(n))},Ma={test:$w("rgb","red"),parse:VA("red","green","blue"),transform:({red:n,green:e,blue:t,alpha:s=1})=>"rgba("+sx.transform(n)+", "+sx.transform(e)+", "+sx.transform(t)+", "+ph($h.transform(s))+")"};function YB(n){let e="",t="",s="",r="";return n.length>5?(e=n.substring(1,3),t=n.substring(3,5),s=n.substring(5,7),r=n.substring(7,9)):(e=n.substring(1,2),t=n.substring(2,3),s=n.substring(3,4),r=n.substring(4,5),e+=e,t+=t,s+=s,r+=r),{red:parseInt(e,16),green:parseInt(t,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const Kx={test:$w("#"),parse:YB,transform:Ma.transform},Jh=n=>({test:e=>typeof e=="string"&&e.endsWith(n)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${n}`}),To=Jh("deg"),oi=Jh("%"),He=Jh("px"),JB=Jh("vh"),ZB=Jh("vw"),G$={...oi,parse:n=>oi.parse(n)/100,transform:n=>oi.transform(n*100)},gc={test:$w("hsl","hue"),parse:VA("hue","saturation","lightness"),transform:({hue:n,saturation:e,lightness:t,alpha:s=1})=>"hsla("+Math.round(n)+", "+oi.transform(ph(e))+", "+oi.transform(ph(t))+", "+ph($h.transform(s))+")"},mn={test:n=>Ma.test(n)||Kx.test(n)||gc.test(n),parse:n=>Ma.test(n)?Ma.parse(n):gc.test(n)?gc.parse(n):Kx.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?Ma.transform(n):gc.transform(n),getAnimatableNone:n=>{const e=mn.parse(n);return e.alpha=0,mn.transform(e)}},QB=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function eV(n){return isNaN(n)&&typeof n=="string"&&(n.match(kw)?.length||0)+(n.match(QB)?.length||0)>0}const UA="number",jA="color",tV="var",nV="var(",W$="${}",sV=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Eh(n){const e=n.toString(),t=[],s={color:[],number:[],var:[]},r=[];let i=0;const l=e.replace(sV,c=>(mn.test(c)?(s.color.push(i),r.push(jA),t.push(mn.parse(c))):c.startsWith(nV)?(s.var.push(i),r.push(tV),t.push(c)):(s.number.push(i),r.push(UA),t.push(parseFloat(c))),++i,W$)).split(W$);return{values:t,split:l,indexes:s,types:r}}function GA(n){return Eh(n).values}function WA(n){const{split:e,types:t}=Eh(n),s=e.length;return r=>{let i="";for(let o=0;o<s;o++)if(i+=e[o],r[o]!==void 0){const l=t[o];l===UA?i+=ph(r[o]):l===jA?i+=mn.transform(r[o]):i+=r[o]}return i}}const rV=n=>typeof n=="number"?0:mn.test(n)?mn.getAnimatableNone(n):n;function iV(n){const e=GA(n);return WA(n)(e.map(rV))}const Fo={test:eV,parse:GA,createTransformer:WA,getAnimatableNone:iV};function rx(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function oV({hue:n,saturation:e,lightness:t,alpha:s}){n/=360,e/=100,t/=100;let r=0,i=0,o=0;if(!e)r=i=o=t;else{const l=t<.5?t*(1+e):t+e-t*e,c=2*t-l;r=rx(c,l,n+1/3),i=rx(c,l,n),o=rx(c,l,n-1/3)}return{red:Math.round(r*255),green:Math.round(i*255),blue:Math.round(o*255),alpha:s}}function ym(n,e){return t=>t>0?e:n}const qt=(n,e,t)=>n+(e-n)*t,ix=(n,e,t)=>{const s=n*n,r=t*(e*e-s)+s;return r<0?0:Math.sqrt(r)},aV=[Kx,Ma,gc],lV=n=>aV.find(e=>e.test(n));function H$(n){const e=lV(n);if(!e)return!1;let t=e.parse(n);return e===gc&&(t=oV(t)),t}const q$=(n,e)=>{const t=H$(n),s=H$(e);if(!t||!s)return ym(n,e);const r={...t};return i=>(r.red=ix(t.red,s.red,i),r.green=ix(t.green,s.green,i),r.blue=ix(t.blue,s.blue,i),r.alpha=qt(t.alpha,s.alpha,i),Ma.transform(r))},Xx=new Set(["none","hidden"]);function cV(n,e){return Xx.has(n)?t=>t<=0?n:e:t=>t>=1?e:n}function uV(n,e){return t=>qt(n,e,t)}function Ew(n){return typeof n=="number"?uV:typeof n=="string"?Tw(n)?ym:mn.test(n)?q$:fV:Array.isArray(n)?HA:typeof n=="object"?mn.test(n)?q$:hV:ym}function HA(n,e){const t=[...n],s=t.length,r=n.map((i,o)=>Ew(i)(i,e[o]));return i=>{for(let o=0;o<s;o++)t[o]=r[o](i);return t}}function hV(n,e){const t={...n,...e},s={};for(const r in t)n[r]!==void 0&&e[r]!==void 0&&(s[r]=Ew(n[r])(n[r],e[r]));return r=>{for(const i in s)t[i]=s[i](r);return t}}function dV(n,e){const t=[],s={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const i=e.types[r],o=n.indexes[i][s[i]],l=n.values[o]??0;t[r]=l,s[i]++}return t}const fV=(n,e)=>{const t=Fo.createTransformer(e),s=Eh(n),r=Eh(e);return s.indexes.var.length===r.indexes.var.length&&s.indexes.color.length===r.indexes.color.length&&s.indexes.number.length>=r.indexes.number.length?Xx.has(n)&&!r.values.length||Xx.has(e)&&!s.values.length?cV(n,e):Xh(HA(dV(s,r),r.values),t):ym(n,e)};function qA(n,e,t){return typeof n=="number"&&typeof e=="number"&&typeof t=="number"?qt(n,e,t):Ew(n)(n,e)}const pV=n=>{const e=({timestamp:t})=>n(t);return{start:(t=!0)=>jt.update(e,t),stop:()=>Mo(e),now:()=>Wn.isProcessing?Wn.timestamp:Is.now()}},KA=(n,e,t=10)=>{let s="";const r=Math.max(Math.round(e/t),2);for(let i=0;i<r;i++)s+=Math.round(n(i/(r-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},bm=2e4;function Iw(n){let e=0;const t=50;let s=n.next(e);for(;!s.done&&e<bm;)e+=t,s=n.next(e);return e>=bm?1/0:e}function mV(n,e=100,t){const s=t({...n,keyframes:[0,e]}),r=Math.min(Iw(s),bm);return{type:"keyframes",ease:i=>s.next(r*i).value/e,duration:mr(r)}}const gV=5;function XA(n,e,t){const s=Math.max(e-gV,0);return EA(t-n(s),e-s)}const Zt={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},ox=.001;function yV({duration:n=Zt.duration,bounce:e=Zt.bounce,velocity:t=Zt.velocity,mass:s=Zt.mass}){let r,i,o=1-e;o=Ui(Zt.minDamping,Zt.maxDamping,o),n=Ui(Zt.minDuration,Zt.maxDuration,mr(n)),o<1?(r=h=>{const d=h*o,p=d*n,m=d-t,y=Yx(h,o),b=Math.exp(-p);return ox-m/y*b},i=h=>{const p=h*o*n,m=p*t+t,y=Math.pow(o,2)*Math.pow(h,2)*n,b=Math.exp(-p),x=Yx(Math.pow(h,2),o);return(-r(h)+ox>0?-1:1)*((m-y)*b)/x}):(r=h=>{const d=Math.exp(-h*n),p=(h-t)*n+1;return-ox+d*p},i=h=>{const d=Math.exp(-h*n),p=(t-h)*(n*n);return d*p});const l=5/n,c=xV(r,i,l);if(n=ii(n),isNaN(c))return{stiffness:Zt.stiffness,damping:Zt.damping,duration:n};{const h=Math.pow(c,2)*s;return{stiffness:h,damping:o*2*Math.sqrt(s*h),duration:n}}}const bV=12;function xV(n,e,t){let s=t;for(let r=1;r<bV;r++)s=s-n(s)/e(s);return s}function Yx(n,e){return n*Math.sqrt(1-e*e)}const vV=["duration","bounce"],wV=["stiffness","damping","mass"];function K$(n,e){return e.some(t=>n[t]!==void 0)}function SV(n){let e={velocity:Zt.velocity,stiffness:Zt.stiffness,damping:Zt.damping,mass:Zt.mass,isResolvedFromDuration:!1,...n};if(!K$(n,wV)&&K$(n,vV))if(n.visualDuration){const t=n.visualDuration,s=2*Math.PI/(t*1.2),r=s*s,i=2*Ui(.05,1,1-(n.bounce||0))*Math.sqrt(r);e={...e,mass:Zt.mass,stiffness:r,damping:i}}else{const t=yV(n);e={...e,...t,mass:Zt.mass},e.isResolvedFromDuration=!0}return e}function xm(n=Zt.visualDuration,e=Zt.bounce){const t=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:e}:n;let{restSpeed:s,restDelta:r}=t;const i=t.keyframes[0],o=t.keyframes[t.keyframes.length-1],l={done:!1,value:i},{stiffness:c,damping:h,mass:d,duration:p,velocity:m,isResolvedFromDuration:y}=SV({...t,velocity:-mr(t.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(c*d)),w=o-i,S=mr(Math.sqrt(c/d)),T=Math.abs(w)<5;s||(s=T?Zt.restSpeed.granular:Zt.restSpeed.default),r||(r=T?Zt.restDelta.granular:Zt.restDelta.default);let k;if(x<1){const E=Yx(S,x);k=N=>{const _=Math.exp(-x*S*N);return o-_*((b+x*S*w)/E*Math.sin(E*N)+w*Math.cos(E*N))}}else if(x===1)k=E=>o-Math.exp(-S*E)*(w+(b+S*w)*E);else{const E=S*Math.sqrt(x*x-1);k=N=>{const _=Math.exp(-x*S*N),R=Math.min(E*N,300);return o-_*((b+x*S*w)*Math.sinh(R)+E*w*Math.cosh(R))/E}}const $={calculatedDuration:y&&p||null,next:E=>{const N=k(E);if(y)l.done=E>=p;else{let _=E===0?b:0;x<1&&(_=E===0?ii(b):XA(k,E,N));const R=Math.abs(_)<=s,D=Math.abs(o-N)<=r;l.done=R&&D}return l.value=l.done?o:N,l},toString:()=>{const E=Math.min(Iw($),bm),N=KA(_=>$.next(E*_).value,E,30);return E+"ms "+N},toTransition:()=>{}};return $}xm.applyToOptions=n=>{const e=mV(n,100,xm);return n.ease=e.ease,n.duration=ii(e.duration),n.type="keyframes",n};function Jx({keyframes:n,velocity:e=0,power:t=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:i=500,modifyTarget:o,min:l,max:c,restDelta:h=.5,restSpeed:d}){const p=n[0],m={done:!1,value:p},y=R=>l!==void 0&&R<l||c!==void 0&&R>c,b=R=>l===void 0?c:c===void 0||Math.abs(l-R)<Math.abs(c-R)?l:c;let x=t*e;const w=p+x,S=o===void 0?w:o(w);S!==w&&(x=S-p);const T=R=>-x*Math.exp(-R/s),k=R=>S+T(R),$=R=>{const D=T(R),M=k(R);m.done=Math.abs(D)<=h,m.value=m.done?S:M};let E,N;const _=R=>{y(m.value)&&(E=R,N=xm({keyframes:[m.value,b(m.value)],velocity:XA(k,R,m.value),damping:r,stiffness:i,restDelta:h,restSpeed:d}))};return _(0),{calculatedDuration:null,next:R=>{let D=!1;return!N&&E===void 0&&(D=!0,$(R),_(R)),E!==void 0&&R>=E?N.next(R-E):(!D&&$(R),m)}}}function CV(n,e,t){const s=[],r=t||ji.mix||qA,i=n.length-1;for(let o=0;o<i;o++){let l=r(n[o],n[o+1]);if(e){const c=Array.isArray(e)?e[o]||br:e;l=Xh(c,l)}s.push(l)}return s}function TV(n,e,{clamp:t=!0,ease:s,mixer:r}={}){const i=n.length;if(xw(i===e.length),i===1)return()=>e[0];if(i===2&&e[0]===e[1])return()=>e[1];const o=n[0]===n[1];n[0]>n[i-1]&&(n=[...n].reverse(),e=[...e].reverse());const l=CV(e,s,r),c=l.length,h=d=>{if(o&&d<n[0])return e[0];let p=0;if(c>1)for(;p<n.length-2&&!(d<n[p+1]);p++);const m=kh(n[p],n[p+1],d);return l[p](m)};return t?d=>h(Ui(n[0],n[i-1],d)):h}function kV(n,e){const t=n[n.length-1];for(let s=1;s<=e;s++){const r=kh(0,e,s);n.push(qt(t,1,r))}}function $V(n){const e=[0];return kV(e,n.length-1),e}function EV(n,e){return n.map(t=>t*e)}function IV(n,e){return n.map(()=>e||FA).splice(0,n.length-1)}function mh({duration:n=300,keyframes:e,times:t,ease:s="easeInOut"}){const r=zB(s)?s.map(j$):j$(s),i={done:!1,value:e[0]},o=EV(t&&t.length===e.length?t:$V(e),n),l=TV(o,e,{ease:Array.isArray(r)?r:IV(e,r)});return{calculatedDuration:n,next:c=>(i.value=l(c),i.done=c>=n,i)}}const NV=n=>n!==null;function Nw(n,{repeat:e,repeatType:t="loop"},s,r=1){const i=n.filter(NV),l=r<0||e&&t!=="loop"&&e%2===1?0:i.length-1;return!l||s===void 0?i[l]:s}const AV={decay:Jx,inertia:Jx,tween:mh,keyframes:mh,spring:xm};function YA(n){typeof n.type=="string"&&(n.type=AV[n.type])}class Aw{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,t){return this.finished.then(e,t)}}const _V=n=>n/100;class _w extends Aw{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:t}=this.options;t&&t.updatedAt!==Is.now()&&this.tick(Is.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;YA(e);const{type:t=mh,repeat:s=0,repeatDelay:r=0,repeatType:i,velocity:o=0}=e;let{keyframes:l}=e;const c=t||mh;c!==mh&&typeof l[0]!="number"&&(this.mixKeyframes=Xh(_V,qA(l[0],l[1])),l=[0,100]);const h=c({...e,keyframes:l});i==="mirror"&&(this.mirroredGenerator=c({...e,keyframes:[...l].reverse(),velocity:-o})),h.calculatedDuration===null&&(h.calculatedDuration=Iw(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+r,this.totalDuration=this.resolvedDuration*(s+1)-r,this.generator=h}updateTime(e){const t=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=t}tick(e,t=!1){const{generator:s,totalDuration:r,mixKeyframes:i,mirroredGenerator:o,resolvedDuration:l,calculatedDuration:c}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:p,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-r/this.speed,this.startTime)),t?this.currentTime=e:this.updateTime(e);const S=this.currentTime-h*(this.playbackSpeed>=0?1:-1),T=this.playbackSpeed>=0?S<0:S>r;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=r);let k=this.currentTime,$=s;if(p){const R=Math.min(this.currentTime,r)/l;let D=Math.floor(R),M=R%1;!M&&R>=1&&(M=1),M===1&&D--,D=Math.min(D,p+1),D%2&&(m==="reverse"?(M=1-M,y&&(M-=y/l)):m==="mirror"&&($=o)),k=Ui(0,1,M)*l}const E=T?{done:!1,value:d[0]}:$.next(k);i&&(E.value=i(E.value));let{done:N}=E;!T&&c!==null&&(N=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const _=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&N);return _&&b!==Jx&&(E.value=Nw(d,this.options,w,this.speed)),x&&x(E.value),_&&this.finish(),E}then(e,t){return this.finished.then(e,t)}get duration(){return mr(this.calculatedDuration)}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+mr(e)}get time(){return mr(this.currentTime)}set time(e){e=ii(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(Is.now());const t=this.playbackSpeed!==e;this.playbackSpeed=e,t&&(this.time=mr(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=pV,startTime:t}=this.options;this.driver||(this.driver=e(r=>this.tick(r))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=t??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Is.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),e.observe(this)}}function RV(n){for(let e=1;e<n.length;e++)n[e]??(n[e]=n[e-1])}const Fa=n=>n*180/Math.PI,Zx=n=>{const e=Fa(Math.atan2(n[1],n[0]));return Qx(e)},DV={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:Zx,rotateZ:Zx,skewX:n=>Fa(Math.atan(n[1])),skewY:n=>Fa(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},Qx=n=>(n=n%360,n<0&&(n+=360),n),X$=Zx,Y$=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),J$=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),OV={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:Y$,scaleY:J$,scale:n=>(Y$(n)+J$(n))/2,rotateX:n=>Qx(Fa(Math.atan2(n[6],n[5]))),rotateY:n=>Qx(Fa(Math.atan2(-n[2],n[0]))),rotateZ:X$,rotate:X$,skewX:n=>Fa(Math.atan(n[4])),skewY:n=>Fa(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function ev(n){return n.includes("scale")?1:0}function tv(n,e){if(!n||n==="none")return ev(e);const t=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,r;if(t)s=OV,r=t;else{const l=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=DV,r=l}if(!r)return ev(e);const i=s[e],o=r[1].split(",").map(FV);return typeof i=="function"?i(o):o[i]}const MV=(n,e)=>{const{transform:t="none"}=getComputedStyle(n);return tv(t,e)};function FV(n){return parseFloat(n.trim())}const jc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Gc=new Set(jc),Z$=n=>n===Uc||n===He,LV=new Set(["x","y","z"]),PV=jc.filter(n=>!LV.has(n));function zV(n){const e=[];return PV.forEach(t=>{const s=n.getValue(t);s!==void 0&&(e.push([t,s.get()]),s.set(t.startsWith("scale")?1:0))}),e}const Ba={width:({x:n},{paddingLeft:e="0",paddingRight:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),height:({y:n},{paddingTop:e="0",paddingBottom:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),top:(n,{top:e})=>parseFloat(e),left:(n,{left:e})=>parseFloat(e),bottom:({y:n},{top:e})=>parseFloat(e)+(n.max-n.min),right:({x:n},{left:e})=>parseFloat(e)+(n.max-n.min),x:(n,{transform:e})=>tv(e,"x"),y:(n,{transform:e})=>tv(e,"y")};Ba.translateX=Ba.x;Ba.translateY=Ba.y;const Va=new Set;let nv=!1,sv=!1,rv=!1;function JA(){if(sv){const n=Array.from(Va).filter(s=>s.needsMeasurement),e=new Set(n.map(s=>s.element)),t=new Map;e.forEach(s=>{const r=zV(s);r.length&&(t.set(s,r),s.render())}),n.forEach(s=>s.measureInitialState()),e.forEach(s=>{s.render();const r=t.get(s);r&&r.forEach(([i,o])=>{s.getValue(i)?.set(o)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}sv=!1,nv=!1,Va.forEach(n=>n.complete(rv)),Va.clear()}function ZA(){Va.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(sv=!0)})}function BV(){rv=!0,ZA(),JA(),rv=!1}class Rw{constructor(e,t,s,r,i,o=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...e],this.onComplete=t,this.name=s,this.motionValue=r,this.element=i,this.isAsync=o}scheduleResolve(){this.state="scheduled",this.isAsync?(Va.add(this),nv||(nv=!0,jt.read(ZA),jt.resolveKeyframes(JA))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:t,element:s,motionValue:r}=this;if(e[0]===null){const i=r?.get(),o=e[e.length-1];if(i!==void 0)e[0]=i;else if(s&&t){const l=s.readValue(t,o);l!=null&&(e[0]=l)}e[0]===void 0&&(e[0]=o),r&&i===void 0&&r.set(e[0])}RV(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),Va.delete(this)}cancel(){this.state==="scheduled"&&(Va.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const VV=n=>n.startsWith("--");function UV(n,e,t){VV(e)?n.style.setProperty(e,t):n.style[e]=t}const jV=vw(()=>window.ScrollTimeline!==void 0),GV={};function WV(n,e){const t=vw(n);return()=>GV[e]??t()}const QA=WV(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),oh=([n,e,t,s])=>`cubic-bezier(${n}, ${e}, ${t}, ${s})`,Q$={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:oh([0,.65,.55,1]),circOut:oh([.55,0,1,.45]),backIn:oh([.31,.01,.66,-.59]),backOut:oh([.33,1.53,.69,.99])};function e_(n,e){if(n)return typeof n=="function"?QA()?KA(n,e):"ease-out":LA(n)?oh(n):Array.isArray(n)?n.map(t=>e_(t,e)||Q$.easeOut):Q$[n]}function HV(n,e,t,{delay:s=0,duration:r=300,repeat:i=0,repeatType:o="loop",ease:l="easeOut",times:c}={},h=void 0){const d={[e]:t};c&&(d.offset=c);const p=e_(l,r);Array.isArray(p)&&(d.easing=p);const m={delay:s,duration:r,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:i+1,direction:o==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function t_(n){return typeof n=="function"&&"applyToOptions"in n}function qV({type:n,...e}){return t_(n)&&QA()?n.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class KV extends Aw{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:t,name:s,keyframes:r,pseudoElement:i,allowFlatten:o=!1,finalKeyframe:l,onComplete:c}=e;this.isPseudoElement=!!i,this.allowFlatten=o,this.options=e,xw(typeof e.type!="string");const h=qV(e);this.animation=HV(t,s,r,h,i),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!i){const d=Nw(r,this.options,l,this.speed);this.updateMotionValue?this.updateMotionValue(d):UV(t,s,d),this.animation.cancel()}c?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const e=this.animation.effect?.getComputedTiming?.().duration||0;return mr(Number(e))}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+mr(e)}get time(){return mr(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=ii(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:t}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,e&&jV()?(this.animation.timeline=e,br):t(this)}}const n_={anticipate:DA,backInOut:RA,circInOut:MA};function XV(n){return n in n_}function YV(n){typeof n.ease=="string"&&XV(n.ease)&&(n.ease=n_[n.ease])}const eE=10;class JV extends KV{constructor(e){YV(e),YA(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:t,onUpdate:s,onComplete:r,element:i,...o}=this.options;if(!t)return;if(e!==void 0){t.set(e);return}const l=new _w({...o,autoplay:!1}),c=ii(this.finishedTime??this.time);t.setWithVelocity(l.sample(c-eE).value,l.sample(c).value,eE),l.stop()}}const tE=(n,e)=>e==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(Fo.test(n)||n==="0")&&!n.startsWith("url("));function ZV(n){const e=n[0];if(n.length===1)return!0;for(let t=0;t<n.length;t++)if(n[t]!==e)return!0}function QV(n,e,t,s){const r=n[0];if(r===null)return!1;if(e==="display"||e==="visibility")return!0;const i=n[n.length-1],o=tE(r,e),l=tE(i,e);return!o||!l?!1:ZV(n)||(t==="spring"||t_(t))&&s}function iv(n){n.duration=0,n.type="keyframes"}const eU=new Set(["opacity","clipPath","filter","transform"]),tU=vw(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function nU(n){const{motionValue:e,name:t,repeatDelay:s,repeatType:r,damping:i,type:o}=n;if(!(e?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:c,transformTemplate:h}=e.owner.getProps();return tU()&&t&&eU.has(t)&&(t!=="transform"||!h)&&!c&&!s&&r!=="mirror"&&i!==0&&o!=="inertia"}const sU=40;class rU extends Aw{constructor({autoplay:e=!0,delay:t=0,type:s="keyframes",repeat:r=0,repeatDelay:i=0,repeatType:o="loop",keyframes:l,name:c,motionValue:h,element:d,...p}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Is.now();const m={autoplay:e,delay:t,type:s,repeat:r,repeatDelay:i,repeatType:o,name:c,motionValue:h,element:d,...p},y=d?.KeyframeResolver||Rw;this.keyframeResolver=new y(l,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),c,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(e,t,s,r){this.keyframeResolver=void 0;const{name:i,type:o,velocity:l,delay:c,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Is.now(),QV(e,i,o,l)||((ji.instantAnimations||!c)&&d?.(Nw(e,s,t)),e[0]=e[e.length-1],iv(s),s.repeat=0);const m={startTime:r?this.resolvedAt?this.resolvedAt-this.createdAt>sU?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:t,...s,keyframes:e},y=!h&&nU(m)?new JV({...m,element:m.motionValue.owner.current}):new _w(m);y.finished.then(()=>this.notifyFinished()).catch(br),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(e,t){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),BV()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const iU=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function oU(n){const e=iU.exec(n);if(!e)return[,];const[,t,s,r]=e;return[`--${t??s}`,r]}function s_(n,e,t=1){const[s,r]=oU(n);if(!s)return;const i=window.getComputedStyle(e).getPropertyValue(s);if(i){const o=i.trim();return TA(o)?parseFloat(o):o}return Tw(r)?s_(r,e,t+1):r}function Dw(n,e){return n?.[e]??n?.default??n}const r_=new Set(["width","height","top","left","right","bottom",...jc]),aU={test:n=>n==="auto",parse:n=>n},i_=n=>e=>e.test(n),o_=[Uc,He,oi,To,ZB,JB,aU],nE=n=>o_.find(i_(n));function lU(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||$A(n):!0}const cU=new Set(["brightness","contrast","saturate","opacity"]);function uU(n){const[e,t]=n.slice(0,-1).split("(");if(e==="drop-shadow")return n;const[s]=t.match(kw)||[];if(!s)return n;const r=t.replace(s,"");let i=cU.has(e)?1:0;return s!==t&&(i*=100),e+"("+i+r+")"}const hU=/\b([a-z-]*)\(.*?\)/gu,ov={...Fo,getAnimatableNone:n=>{const e=n.match(hU);return e?e.map(uU).join(" "):n}},sE={...Uc,transform:Math.round},dU={rotate:To,rotateX:To,rotateY:To,rotateZ:To,scale:Pp,scaleX:Pp,scaleY:Pp,scaleZ:Pp,skew:To,skewX:To,skewY:To,distance:He,translateX:He,translateY:He,translateZ:He,x:He,y:He,z:He,perspective:He,transformPerspective:He,opacity:$h,originX:G$,originY:G$,originZ:He},Ow={borderWidth:He,borderTopWidth:He,borderRightWidth:He,borderBottomWidth:He,borderLeftWidth:He,borderRadius:He,radius:He,borderTopLeftRadius:He,borderTopRightRadius:He,borderBottomRightRadius:He,borderBottomLeftRadius:He,width:He,maxWidth:He,height:He,maxHeight:He,top:He,right:He,bottom:He,left:He,padding:He,paddingTop:He,paddingRight:He,paddingBottom:He,paddingLeft:He,margin:He,marginTop:He,marginRight:He,marginBottom:He,marginLeft:He,backgroundPositionX:He,backgroundPositionY:He,...dU,zIndex:sE,fillOpacity:$h,strokeOpacity:$h,numOctaves:sE},fU={...Ow,color:mn,backgroundColor:mn,outlineColor:mn,fill:mn,stroke:mn,borderColor:mn,borderTopColor:mn,borderRightColor:mn,borderBottomColor:mn,borderLeftColor:mn,filter:ov,WebkitFilter:ov},a_=n=>fU[n];function l_(n,e){let t=a_(n);return t!==ov&&(t=Fo),t.getAnimatableNone?t.getAnimatableNone(e):void 0}const pU=new Set(["auto","none","0"]);function mU(n,e,t){let s=0,r;for(;s<n.length&&!r;){const i=n[s];typeof i=="string"&&!pU.has(i)&&Eh(i).values.length&&(r=n[s]),s++}if(r&&t)for(const i of e)n[i]=l_(t,r)}class gU extends Rw{constructor(e,t,s,r,i){super(e,t,s,r,i,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:t,name:s}=this;if(!t||!t.current)return;super.readKeyframes();for(let c=0;c<e.length;c++){let h=e[c];if(typeof h=="string"&&(h=h.trim(),Tw(h))){const d=s_(h,t.current);d!==void 0&&(e[c]=d),c===e.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!r_.has(s)||e.length!==2)return;const[r,i]=e,o=nE(r),l=nE(i);if(o!==l)if(Z$(o)&&Z$(l))for(let c=0;c<e.length;c++){const h=e[c];typeof h=="string"&&(e[c]=parseFloat(h))}else Ba[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:t}=this,s=[];for(let r=0;r<e.length;r++)(e[r]===null||lU(e[r]))&&s.push(r);s.length&&mU(e,s,t)}measureInitialState(){const{element:e,unresolvedKeyframes:t,name:s}=this;if(!e||!e.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=Ba[s](e.measureViewportBox(),window.getComputedStyle(e.current)),t[0]=this.measuredOrigin;const r=t[t.length-1];r!==void 0&&e.getValue(s,r).jump(r,!1)}measureEndState(){const{element:e,name:t,unresolvedKeyframes:s}=this;if(!e||!e.current)return;const r=e.getValue(t);r&&r.jump(this.measuredOrigin,!1);const i=s.length-1,o=s[i];s[i]=Ba[t](e.measureViewportBox(),window.getComputedStyle(e.current)),o!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=o),this.removedTransforms?.length&&this.removedTransforms.forEach(([l,c])=>{e.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function yU(n,e,t){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const r=t?.[n]??s.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}const c_=(n,e)=>e&&typeof n=="number"?e.transform(n):n;function u_(n){return kA(n)&&"offsetHeight"in n}const rE=30,bU=n=>!isNaN(parseFloat(n));class xU{constructor(e,t={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const r=Is.now();if(this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const i of this.dependents)i.dirty()},this.hasAnimated=!1,this.setCurrent(e),this.owner=t.owner}setCurrent(e){this.current=e,this.updatedAt=Is.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=bU(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new ww);const s=this.events[e].add(t);return e==="change"?()=>{s(),jt.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e){this.passiveEffect?this.passiveEffect(e,this.updateAndNotify):this.updateAndNotify(e)}setWithVelocity(e,t,s){this.set(t),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-s}jump(e,t=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,t&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(e){this.dependents||(this.dependents=new Set),this.dependents.add(e)}removeDependent(e){this.dependents&&this.dependents.delete(e)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=Is.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>rE)return 0;const t=Math.min(this.updatedAt-this.prevUpdatedAt,rE);return EA(parseFloat(this.current)-parseFloat(this.prevFrameValue),t)}start(e){return this.stop(),new Promise(t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Nc(n,e){return new xU(n,e)}const{schedule:Mw}=PA(queueMicrotask,!1),Dr={x:!1,y:!1};function h_(){return Dr.x||Dr.y}function vU(n){return n==="x"||n==="y"?Dr[n]?null:(Dr[n]=!0,()=>{Dr[n]=!1}):Dr.x||Dr.y?null:(Dr.x=Dr.y=!0,()=>{Dr.x=Dr.y=!1})}function d_(n,e){const t=yU(n),s=new AbortController,r={passive:!0,...e,signal:s.signal};return[t,r,()=>s.abort()]}function iE(n){return!(n.pointerType==="touch"||h_())}function wU(n,e,t={}){const[s,r,i]=d_(n,t),o=l=>{if(!iE(l))return;const{target:c}=l,h=e(c,l);if(typeof h!="function"||!c)return;const d=p=>{iE(p)&&(h(p),c.removeEventListener("pointerleave",d))};c.addEventListener("pointerleave",d,r)};return s.forEach(l=>{l.addEventListener("pointerenter",o,r)}),i}const f_=(n,e)=>e?n===e?!0:f_(n,e.parentElement):!1,Fw=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,SU=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function CU(n){return SU.has(n.tagName)||n.tabIndex!==-1}const im=new WeakSet;function oE(n){return e=>{e.key==="Enter"&&n(e)}}function ax(n,e){n.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const TU=(n,e)=>{const t=n.currentTarget;if(!t)return;const s=oE(()=>{if(im.has(t))return;ax(t,"down");const r=oE(()=>{ax(t,"up")}),i=()=>ax(t,"cancel");t.addEventListener("keyup",r,e),t.addEventListener("blur",i,e)});t.addEventListener("keydown",s,e),t.addEventListener("blur",()=>t.removeEventListener("keydown",s),e)};function aE(n){return Fw(n)&&!h_()}function kU(n,e,t={}){const[s,r,i]=d_(n,t),o=l=>{const c=l.currentTarget;if(!aE(l))return;im.add(c);const h=e(c,l),d=(y,b)=>{window.removeEventListener("pointerup",p),window.removeEventListener("pointercancel",m),im.has(c)&&im.delete(c),aE(y)&&typeof h=="function"&&h(y,{success:b})},p=y=>{d(y,c===window||c===document||t.useGlobalTarget||f_(c,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",p,r),window.addEventListener("pointercancel",m,r)};return s.forEach(l=>{(t.useGlobalTarget?window:l).addEventListener("pointerdown",o,r),u_(l)&&(l.addEventListener("focus",h=>TU(h,r)),!CU(l)&&!l.hasAttribute("tabindex")&&(l.tabIndex=0))}),i}function p_(n){return kA(n)&&"ownerSVGElement"in n}function $U(n){return p_(n)&&n.tagName==="svg"}const ns=n=>!!(n&&n.getVelocity),EU=[...o_,mn,Fo],IU=n=>EU.find(i_(n)),Lw=Se.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function lE(n,e){if(typeof n=="function")return n(e);n!=null&&(n.current=e)}function NU(...n){return e=>{let t=!1;const s=n.map(r=>{const i=lE(r,e);return!t&&typeof i=="function"&&(t=!0),i});if(t)return()=>{for(let r=0;r<s.length;r++){const i=s[r];typeof i=="function"?i():lE(n[r],null)}}}}function AU(...n){return Se.useCallback(NU(...n),n)}class _U extends Se.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const s=t.offsetParent,r=u_(s)&&s.offsetWidth||0,i=this.props.sizeRef.current;i.height=t.offsetHeight||0,i.width=t.offsetWidth||0,i.top=t.offsetTop,i.left=t.offsetLeft,i.right=r-i.width-i.left}return null}componentDidUpdate(){}render(){return this.props.children}}function RU({children:n,isPresent:e,anchorX:t,root:s}){const r=Se.useId(),i=Se.useRef(null),o=Se.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:l}=Se.useContext(Lw),c=AU(i,n?.ref);return Se.useInsertionEffect(()=>{const{width:h,height:d,top:p,left:m,right:y}=o.current;if(e||!i.current||!h||!d)return;const b=t==="left"?`left: ${m}`:`right: ${y}`;i.current.dataset.motionPopId=r;const x=document.createElement("style");l&&(x.nonce=l);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${p}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[e]),oe.jsx(_U,{isPresent:e,childRef:i,sizeRef:o,children:Se.cloneElement(n,{ref:c})})}const DU=({children:n,initial:e,isPresent:t,onExitComplete:s,custom:r,presenceAffectsLayout:i,mode:o,anchorX:l,root:c})=>{const h=mw(OU),d=Se.useId();let p=!0,m=Se.useMemo(()=>(p=!1,{id:d,initial:e,isPresent:t,custom:r,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[t,h,s]);return i&&p&&(m={...m}),Se.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[t]),Se.useEffect(()=>{!t&&!h.size&&s&&s()},[t]),o==="popLayout"&&(n=oe.jsx(RU,{isPresent:t,anchorX:l,root:c,children:n})),oe.jsx(ng.Provider,{value:m,children:n})};function OU(){return new Map}function m_(n=!0){const e=Se.useContext(ng);if(e===null)return[!0,null];const{isPresent:t,onExitComplete:s,register:r}=e,i=Se.useId();Se.useEffect(()=>{if(n)return r(i)},[n]);const o=Se.useCallback(()=>n&&s&&s(i),[i,s,n]);return!t&&s?[!1,o]:[!0]}const zp=n=>n.key||"";function cE(n){const e=[];return Se.Children.forEach(n,t=>{Se.isValidElement(t)&&e.push(t)}),e}const MU=({children:n,custom:e,initial:t=!0,onExitComplete:s,presenceAffectsLayout:r=!0,mode:i="sync",propagate:o=!1,anchorX:l="left",root:c})=>{const[h,d]=m_(o),p=Se.useMemo(()=>cE(n),[n]),m=o&&!h?[]:p.map(zp),y=Se.useRef(!0),b=Se.useRef(p),x=mw(()=>new Map),[w,S]=Se.useState(p),[T,k]=Se.useState(p);CA(()=>{y.current=!1,b.current=p;for(let N=0;N<T.length;N++){const _=zp(T[N]);m.includes(_)?x.delete(_):x.get(_)!==!0&&x.set(_,!1)}},[T,m.length,m.join("-")]);const $=[];if(p!==w){let N=[...p];for(let _=0;_<T.length;_++){const R=T[_],D=zp(R);m.includes(D)||(N.splice(_,0,R),$.push(R))}return i==="wait"&&$.length&&(N=$),k(cE(N)),S(p),null}const{forceRender:E}=Se.useContext(pw);return oe.jsx(oe.Fragment,{children:T.map(N=>{const _=zp(N),R=o&&!h?!1:p===T||m.includes(_),D=()=>{if(x.has(_))x.set(_,!0);else return;let M=!0;x.forEach(A=>{A||(M=!1)}),M&&(E?.(),k(b.current),o&&d?.(),s&&s())};return oe.jsx(DU,{isPresent:R,initial:!y.current||t?void 0:!1,custom:e,presenceAffectsLayout:r,mode:i,root:c,onExitComplete:R?void 0:D,anchorX:l,children:N},_)})})},g_=Se.createContext({strict:!1}),uE={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Ac={};for(const n in uE)Ac[n]={isEnabled:e=>uE[n].some(t=>!!e[t])};function FU(n){for(const e in n)Ac[e]={...Ac[e],...n[e]}}const LU=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function vm(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||LU.has(n)}let y_=n=>!vm(n);function PU(n){typeof n=="function"&&(y_=e=>e.startsWith("on")?!vm(e):n(e))}try{PU(require("@emotion/is-prop-valid").default)}catch{}function zU(n,e,t){const s={};for(const r in n)r==="values"&&typeof n.values=="object"||(y_(r)||t===!0&&vm(r)||!e&&!vm(r)||n.draggable&&r.startsWith("onDrag"))&&(s[r]=n[r]);return s}const sg=Se.createContext({});function rg(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function Ih(n){return typeof n=="string"||Array.isArray(n)}const Pw=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],zw=["initial",...Pw];function ig(n){return rg(n.animate)||zw.some(e=>Ih(n[e]))}function b_(n){return!!(ig(n)||n.variants)}function BU(n,e){if(ig(n)){const{initial:t,animate:s}=n;return{initial:t===!1||Ih(t)?t:void 0,animate:Ih(s)?s:void 0}}return n.inherit!==!1?e:{}}function VU(n){const{initial:e,animate:t}=BU(n,Se.useContext(sg));return Se.useMemo(()=>({initial:e,animate:t}),[hE(e),hE(t)])}function hE(n){return Array.isArray(n)?n.join(" "):n}function dE(n,e){return e.max===e.min?0:n/(e.max-e.min)*100}const th={correct:(n,e)=>{if(!e.target)return n;if(typeof n=="string")if(He.test(n))n=parseFloat(n);else return n;const t=dE(n,e.target.x),s=dE(n,e.target.y);return`${t}% ${s}%`}},UU={correct:(n,{treeScale:e,projectionDelta:t})=>{const s=n,r=Fo.parse(n);if(r.length>5)return s;const i=Fo.createTransformer(n),o=typeof r[0]!="number"?1:0,l=t.x.scale*e.x,c=t.y.scale*e.y;r[0+o]/=l,r[1+o]/=c;const h=qt(l,c,.5);return typeof r[2+o]=="number"&&(r[2+o]/=h),typeof r[3+o]=="number"&&(r[3+o]/=h),i(r)}},av={borderRadius:{...th,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:th,borderTopRightRadius:th,borderBottomLeftRadius:th,borderBottomRightRadius:th,boxShadow:UU};function x_(n,{layout:e,layoutId:t}){return Gc.has(n)||n.startsWith("origin")||(e||t!==void 0)&&(!!av[n]||n==="opacity")}const jU={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},GU=jc.length;function WU(n,e,t){let s="",r=!0;for(let i=0;i<GU;i++){const o=jc[i],l=n[o];if(l===void 0)continue;let c=!0;if(typeof l=="number"?c=l===(o.startsWith("scale")?1:0):c=parseFloat(l)===0,!c||t){const h=c_(l,Ow[o]);if(!c){r=!1;const d=jU[o]||o;s+=`${d}(${h}) `}t&&(e[o]=h)}}return s=s.trim(),t?s=t(e,r?"":s):r&&(s="none"),s}function Bw(n,e,t){const{style:s,vars:r,transformOrigin:i}=n;let o=!1,l=!1;for(const c in e){const h=e[c];if(Gc.has(c)){o=!0;continue}else if(BA(c)){r[c]=h;continue}else{const d=c_(h,Ow[c]);c.startsWith("origin")?(l=!0,i[c]=d):s[c]=d}}if(e.transform||(o||t?s.transform=WU(e,n.transform,t):s.transform&&(s.transform="none")),l){const{originX:c="50%",originY:h="50%",originZ:d=0}=i;s.transformOrigin=`${c} ${h} ${d}`}}const Vw=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function v_(n,e,t){for(const s in e)!ns(e[s])&&!x_(s,t)&&(n[s]=e[s])}function HU({transformTemplate:n},e){return Se.useMemo(()=>{const t=Vw();return Bw(t,e,n),Object.assign({},t.vars,t.style)},[e])}function qU(n,e){const t=n.style||{},s={};return v_(s,t,n),Object.assign(s,HU(n,e)),s}function KU(n,e){const t={},s=qU(n,e);return n.drag&&n.dragListener!==!1&&(t.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(t.tabIndex=0),t.style=s,t}const XU={offset:"stroke-dashoffset",array:"stroke-dasharray"},YU={offset:"strokeDashoffset",array:"strokeDasharray"};function JU(n,e,t=1,s=0,r=!0){n.pathLength=1;const i=r?XU:YU;n[i.offset]=He.transform(-s);const o=He.transform(e),l=He.transform(t);n[i.array]=`${o} ${l}`}function w_(n,{attrX:e,attrY:t,attrScale:s,pathLength:r,pathSpacing:i=1,pathOffset:o=0,...l},c,h,d){if(Bw(n,l,h),c){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:m}=n;p.transform&&(m.transform=p.transform,delete p.transform),(m.transform||p.transformOrigin)&&(m.transformOrigin=p.transformOrigin??"50% 50%",delete p.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete p.transformBox),e!==void 0&&(p.x=e),t!==void 0&&(p.y=t),s!==void 0&&(p.scale=s),r!==void 0&&JU(p,r,i,o,!1)}const S_=()=>({...Vw(),attrs:{}}),C_=n=>typeof n=="string"&&n.toLowerCase()==="svg";function ZU(n,e,t,s){const r=Se.useMemo(()=>{const i=S_();return w_(i,e,C_(s),n.transformTemplate,n.style),{...i.attrs,style:{...i.style}}},[e]);if(n.style){const i={};v_(i,n.style,n),r.style={...i,...r.style}}return r}const QU=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Uw(n){return typeof n!="string"||n.includes("-")?!1:!!(QU.indexOf(n)>-1||/[A-Z]/u.test(n))}function e4(n,e,t,{latestValues:s},r,i=!1){const l=(Uw(n)?ZU:KU)(e,s,r,n),c=zU(e,typeof n=="string",i),h=n!==Se.Fragment?{...c,...l,ref:t}:{},{children:d}=e,p=Se.useMemo(()=>ns(d)?d.get():d,[d]);return Se.createElement(n,{...h,children:p})}function fE(n){const e=[{},{}];return n?.values.forEach((t,s)=>{e[0][s]=t.get(),e[1][s]=t.getVelocity()}),e}function jw(n,e,t,s){if(typeof e=="function"){const[r,i]=fE(s);e=e(t!==void 0?t:n.custom,r,i)}if(typeof e=="string"&&(e=n.variants&&n.variants[e]),typeof e=="function"){const[r,i]=fE(s);e=e(t!==void 0?t:n.custom,r,i)}return e}function om(n){return ns(n)?n.get():n}function t4({scrapeMotionValuesFromProps:n,createRenderState:e},t,s,r){return{latestValues:n4(t,s,r,n),renderState:e()}}function n4(n,e,t,s){const r={},i=s(n,{});for(const m in i)r[m]=om(i[m]);let{initial:o,animate:l}=n;const c=ig(n),h=b_(n);e&&h&&!c&&n.inherit!==!1&&(o===void 0&&(o=e.initial),l===void 0&&(l=e.animate));let d=t?t.initial===!1:!1;d=d||o===!1;const p=d?l:o;if(p&&typeof p!="boolean"&&!rg(p)){const m=Array.isArray(p)?p:[p];for(let y=0;y<m.length;y++){const b=jw(n,m[y]);if(b){const{transitionEnd:x,transition:w,...S}=b;for(const T in S){let k=S[T];if(Array.isArray(k)){const $=d?k.length-1:0;k=k[$]}k!==null&&(r[T]=k)}for(const T in x)r[T]=x[T]}}}return r}const T_=n=>(e,t)=>{const s=Se.useContext(sg),r=Se.useContext(ng),i=()=>t4(n,e,s,r);return t?i():mw(i)};function Gw(n,e,t){const{style:s}=n,r={};for(const i in s)(ns(s[i])||e.style&&ns(e.style[i])||x_(i,n)||t?.getValue(i)?.liveStyle!==void 0)&&(r[i]=s[i]);return r}const s4=T_({scrapeMotionValuesFromProps:Gw,createRenderState:Vw});function k_(n,e,t){const s=Gw(n,e,t);for(const r in n)if(ns(n[r])||ns(e[r])){const i=jc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;s[i]=n[r]}return s}const r4=T_({scrapeMotionValuesFromProps:k_,createRenderState:S_}),i4=Symbol.for("motionComponentSymbol");function yc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function o4(n,e,t){return Se.useCallback(s=>{s&&n.onMount&&n.onMount(s),e&&(s?e.mount(s):e.unmount()),t&&(typeof t=="function"?t(s):yc(t)&&(t.current=s))},[e])}const Ww=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),a4="framerAppearId",$_="data-"+Ww(a4),E_=Se.createContext({});function l4(n,e,t,s,r){const{visualElement:i}=Se.useContext(sg),o=Se.useContext(g_),l=Se.useContext(ng),c=Se.useContext(Lw).reducedMotion,h=Se.useRef(null);s=s||o.renderer,!h.current&&s&&(h.current=s(n,{visualState:e,parent:i,props:t,presenceContext:l,blockInitialAnimation:l?l.initial===!1:!1,reducedMotionConfig:c}));const d=h.current,p=Se.useContext(E_);d&&!d.projection&&r&&(d.type==="html"||d.type==="svg")&&c4(h.current,t,r,p);const m=Se.useRef(!1);Se.useInsertionEffect(()=>{d&&m.current&&d.update(t,l)});const y=t[$_],b=Se.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return CA(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),Se.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function c4(n,e,t,s){const{layoutId:r,layout:i,drag:o,dragConstraints:l,layoutScroll:c,layoutRoot:h,layoutCrossfade:d}=e;n.projection=new t(n.latestValues,e["data-framer-portal-id"]?void 0:I_(n.parent)),n.projection.setOptions({layoutId:r,layout:i,alwaysMeasureLayout:!!o||l&&yc(l),visualElement:n,animationType:typeof i=="string"?i:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:c,layoutRoot:h})}function I_(n){if(n)return n.options.allowProjection!==!1?n.projection:I_(n.parent)}function lx(n,{forwardMotionProps:e=!1}={},t,s){t&&FU(t);const r=Uw(n)?r4:s4;function i(l,c){let h;const d={...Se.useContext(Lw),...l,layoutId:u4(l)},{isStatic:p}=d,m=VU(l),y=r(l,p);if(!p&&gw){h4();const b=d4(d);h=b.MeasureLayout,m.visualElement=l4(n,y,d,s,b.ProjectionNode)}return oe.jsxs(sg.Provider,{value:m,children:[h&&m.visualElement?oe.jsx(h,{visualElement:m.visualElement,...d}):null,e4(n,l,o4(y,m.visualElement,c),y,p,e)]})}i.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const o=Se.forwardRef(i);return o[i4]=n,o}function u4({layoutId:n}){const e=Se.useContext(pw).id;return e&&n!==void 0?e+"-"+n:n}function h4(n,e){Se.useContext(g_).strict}function d4(n){const{drag:e,layout:t}=Ac;if(!e&&!t)return{};const s={...e,...t};return{MeasureLayout:e?.isEnabled(n)||t?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function f4(n,e){if(typeof Proxy>"u")return lx;const t=new Map,s=(i,o)=>lx(i,o,n,e),r=(i,o)=>s(i,o);return new Proxy(r,{get:(i,o)=>o==="create"?s:(t.has(o)||t.set(o,lx(o,void 0,n,e)),t.get(o))})}function N_({top:n,left:e,right:t,bottom:s}){return{x:{min:e,max:t},y:{min:n,max:s}}}function p4({x:n,y:e}){return{top:e.min,right:n.max,bottom:e.max,left:n.min}}function m4(n,e){if(!e)return n;const t=e({x:n.left,y:n.top}),s=e({x:n.right,y:n.bottom});return{top:t.y,left:t.x,bottom:s.y,right:s.x}}function cx(n){return n===void 0||n===1}function lv({scale:n,scaleX:e,scaleY:t}){return!cx(n)||!cx(e)||!cx(t)}function Ea(n){return lv(n)||A_(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function A_(n){return pE(n.x)||pE(n.y)}function pE(n){return n&&n!=="0%"}function wm(n,e,t){const s=n-t,r=e*s;return t+r}function mE(n,e,t,s,r){return r!==void 0&&(n=wm(n,r,s)),wm(n,t,s)+e}function cv(n,e=0,t=1,s,r){n.min=mE(n.min,e,t,s,r),n.max=mE(n.max,e,t,s,r)}function __(n,{x:e,y:t}){cv(n.x,e.translate,e.scale,e.originPoint),cv(n.y,t.translate,t.scale,t.originPoint)}const gE=.999999999999,yE=1.0000000000001;function g4(n,e,t,s=!1){const r=t.length;if(!r)return;e.x=e.y=1;let i,o;for(let l=0;l<r;l++){i=t[l],o=i.projectionDelta;const{visualElement:c}=i.options;c&&c.props.style&&c.props.style.display==="contents"||(s&&i.options.layoutScroll&&i.scroll&&i!==i.root&&xc(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),o&&(e.x*=o.x.scale,e.y*=o.y.scale,__(n,o)),s&&Ea(i.latestValues)&&xc(n,i.latestValues))}e.x<yE&&e.x>gE&&(e.x=1),e.y<yE&&e.y>gE&&(e.y=1)}function bc(n,e){n.min=n.min+e,n.max=n.max+e}function bE(n,e,t,s,r=.5){const i=qt(n.min,n.max,r);cv(n,e,t,i,s)}function xc(n,e){bE(n.x,e.x,e.scaleX,e.scale,e.originX),bE(n.y,e.y,e.scaleY,e.scale,e.originY)}function R_(n,e){return N_(m4(n.getBoundingClientRect(),e))}function y4(n,e,t){const s=R_(n,t),{scroll:r}=e;return r&&(bc(s.x,r.offset.x),bc(s.y,r.offset.y)),s}const xE=()=>({translate:0,scale:1,origin:0,originPoint:0}),vc=()=>({x:xE(),y:xE()}),vE=()=>({min:0,max:0}),kn=()=>({x:vE(),y:vE()}),uv={current:null},D_={current:!1};function b4(){if(D_.current=!0,!!gw)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),e=()=>uv.current=n.matches;n.addEventListener("change",e),e()}else uv.current=!1}const x4=new WeakMap;function v4(n,e,t){for(const s in e){const r=e[s],i=t[s];if(ns(r))n.addValue(s,r);else if(ns(i))n.addValue(s,Nc(r,{owner:n}));else if(i!==r)if(n.hasValue(s)){const o=n.getValue(s);o.liveStyle===!0?o.jump(r):o.hasAnimated||o.set(r)}else{const o=n.getStaticValue(s);n.addValue(s,Nc(o!==void 0?o:r,{owner:n}))}}for(const s in t)e[s]===void 0&&n.removeValue(s);return e}const wE=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class w4{scrapeMotionValuesFromProps(e,t,s){return{}}constructor({parent:e,props:t,presenceContext:s,reducedMotionConfig:r,blockInitialAnimation:i,visualState:o},l={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Rw,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Is.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,jt.render(this.render,!1,!0))};const{latestValues:c,renderState:h}=o;this.latestValues=c,this.baseTarget={...c},this.initialValues=t.initial?{...c}:{},this.renderState=h,this.parent=e,this.props=t,this.presenceContext=s,this.depth=e?e.depth+1:0,this.reducedMotionConfig=r,this.options=l,this.blockInitialAnimation=!!i,this.isControllingVariants=ig(t),this.isVariantNode=b_(t),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...p}=this.scrapeMotionValuesFromProps(t,{},this);for(const m in p){const y=p[m];c[m]!==void 0&&ns(y)&&y.set(c[m])}}mount(e){this.current=e,x4.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,s)=>this.bindToMotionValue(s,t)),D_.current||b4(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:uv.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),Mo(this.notifyUpdate),Mo(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const t=this.features[e];t&&(t.unmount(),t.isMounted=!1)}this.current=null}addChild(e){this.children.add(e),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(e)}removeChild(e){this.children.delete(e),this.enteringChildren&&this.enteringChildren.delete(e)}bindToMotionValue(e,t){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const s=Gc.has(e);s&&this.onBindTransform&&this.onBindTransform();const r=t.on("change",o=>{this.latestValues[e]=o,this.props.onUpdate&&jt.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,e,t)),this.valueSubscriptions.set(e,()=>{r(),i&&i(),t.owner&&t.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in Ac){const t=Ac[e];if(!t)continue;const{isEnabled:s,Feature:r}=t;if(!this.features[e]&&r&&s(this.props)&&(this.features[e]=new r(this)),this.features[e]){const i=this.features[e];i.isMounted?i.update():(i.mount(),i.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):kn()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let s=0;s<wE.length;s++){const r=wE[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const i="on"+r,o=e[i];o&&(this.propEventSubscriptions[r]=this.on(r,o))}this.prevMotionValues=v4(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){const s=this.values.get(e);t!==s&&(s&&this.removeValue(e),this.bindToMotionValue(e,t),this.values.set(e,t),this.latestValues[e]=t.get())}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let s=this.values.get(e);return s===void 0&&t!==void 0&&(s=Nc(t===null?void 0:t,{owner:this}),this.addValue(e,s)),s}readValue(e,t){let s=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return s!=null&&(typeof s=="string"&&(TA(s)||$A(s))?s=parseFloat(s):!IU(s)&&Fo.test(t)&&(s=l_(e,t)),this.setBaseTarget(e,ns(s)?s.get():s)),ns(s)?s.get():s}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){const{initial:t}=this.props;let s;if(typeof t=="string"||typeof t=="object"){const i=jw(this.props,t,this.presenceContext?.custom);i&&(s=i[e])}if(t&&s!==void 0)return s;const r=this.getBaseTargetFromProps(this.props,e);return r!==void 0&&!ns(r)?r:this.initialValues[e]!==void 0&&s===void 0?void 0:this.baseTarget[e]}on(e,t){return this.events[e]||(this.events[e]=new ww),this.events[e].add(t)}notify(e,...t){this.events[e]&&this.events[e].notify(...t)}scheduleRenderMicrotask(){Mw.render(this.render)}}class O_ extends w4{constructor(){super(...arguments),this.KeyframeResolver=gU}sortInstanceNodePosition(e,t){return e.compareDocumentPosition(t)&2?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,{vars:t,style:s}){delete t[e],delete s[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;ns(e)&&(this.childSubscription=e.on("change",t=>{this.current&&(this.current.textContent=`${t}`)}))}}function M_(n,{style:e,vars:t},s,r){const i=n.style;let o;for(o in e)i[o]=e[o];r?.applyProjectionStyles(i,s);for(o in t)i.setProperty(o,t[o])}function S4(n){return window.getComputedStyle(n)}class C4 extends O_{constructor(){super(...arguments),this.type="html",this.renderInstance=M_}readValueFromInstance(e,t){if(Gc.has(t))return this.projection?.isProjecting?ev(t):MV(e,t);{const s=S4(e),r=(BA(t)?s.getPropertyValue(t):s[t])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(e,{transformPagePoint:t}){return R_(e,t)}build(e,t,s){Bw(e,t,s.transformTemplate)}scrapeMotionValuesFromProps(e,t,s){return Gw(e,t,s)}}const F_=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function T4(n,e,t,s){M_(n,e,void 0,s);for(const r in e.attrs)n.setAttribute(F_.has(r)?r:Ww(r),e.attrs[r])}class k4 extends O_{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=kn}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(Gc.has(t)){const s=a_(t);return s&&s.default||0}return t=F_.has(t)?t:Ww(t),e.getAttribute(t)}scrapeMotionValuesFromProps(e,t,s){return k_(e,t,s)}build(e,t,s){w_(e,t,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(e,t,s,r){T4(e,t,s,r)}mount(e){this.isSVGTag=C_(e.tagName),super.mount(e)}}const $4=(n,e)=>Uw(n)?new k4(e):new C4(e,{allowProjection:n!==Se.Fragment});function Sc(n,e,t){const s=n.getProps();return jw(s,e,t!==void 0?t:s.custom,n)}const hv=n=>Array.isArray(n);function E4(n,e,t){n.hasValue(e)?n.getValue(e).set(t):n.addValue(e,Nc(t))}function I4(n){return hv(n)?n[n.length-1]||0:n}function N4(n,e){const t=Sc(n,e);let{transitionEnd:s={},transition:r={},...i}=t||{};i={...i,...s};for(const o in i){const l=I4(i[o]);E4(n,o,l)}}function A4(n){return!!(ns(n)&&n.add)}function dv(n,e){const t=n.getValue("willChange");if(A4(t))return t.add(e);if(!t&&ji.WillChange){const s=new ji.WillChange("auto");n.addValue("willChange",s),s.add(e)}}function L_(n){return n.props[$_]}const _4=n=>n!==null;function R4(n,{repeat:e,repeatType:t="loop"},s){const r=n.filter(_4),i=e&&t!=="loop"&&e%2===1?0:r.length-1;return r[i]}const D4={type:"spring",stiffness:500,damping:25,restSpeed:10},O4=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),M4={type:"keyframes",duration:.8},F4={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},L4=(n,{keyframes:e})=>e.length>2?M4:Gc.has(n)?n.startsWith("scale")?O4(e[1]):D4:F4;function P4({when:n,delay:e,delayChildren:t,staggerChildren:s,staggerDirection:r,repeat:i,repeatType:o,repeatDelay:l,from:c,elapsed:h,...d}){return!!Object.keys(d).length}const Hw=(n,e,t,s={},r,i)=>o=>{const l=Dw(s,n)||{},c=l.delay||s.delay||0;let{elapsed:h=0}=s;h=h-ii(c);const d={keyframes:Array.isArray(t)?t:[null,t],ease:"easeOut",velocity:e.getVelocity(),...l,delay:-h,onUpdate:m=>{e.set(m),l.onUpdate&&l.onUpdate(m)},onComplete:()=>{o(),l.onComplete&&l.onComplete()},name:n,motionValue:e,element:i?void 0:r};P4(l)||Object.assign(d,L4(n,d)),d.duration&&(d.duration=ii(d.duration)),d.repeatDelay&&(d.repeatDelay=ii(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let p=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(iv(d),d.delay===0&&(p=!0)),(ji.instantAnimations||ji.skipAnimations)&&(p=!0,iv(d),d.delay=0),d.allowFlatten=!l.type&&!l.ease,p&&!i&&e.get()!==void 0){const m=R4(d.keyframes,l);if(m!==void 0){jt.update(()=>{d.onUpdate(m),d.onComplete()});return}}return l.isSync?new _w(d):new rU(d)};function z4({protectedKeys:n,needsAnimating:e},t){const s=n.hasOwnProperty(t)&&e[t]!==!0;return e[t]=!1,s}function P_(n,e,{delay:t=0,transitionOverride:s,type:r}={}){let{transition:i=n.getDefaultTransition(),transitionEnd:o,...l}=e;s&&(i=s);const c=[],h=r&&n.animationState&&n.animationState.getState()[r];for(const d in l){const p=n.getValue(d,n.latestValues[d]??null),m=l[d];if(m===void 0||h&&z4(h,d))continue;const y={delay:t,...Dw(i||{},d)},b=p.get();if(b!==void 0&&!p.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=L_(n);if(S){const T=window.MotionHandoffAnimation(S,d,jt);T!==null&&(y.startTime=T,x=!0)}}dv(n,d),p.start(Hw(d,p,m,n.shouldReduceMotion&&r_.has(d)?{type:!1}:y,n,x));const w=p.animation;w&&c.push(w)}return o&&Promise.all(c).then(()=>{jt.update(()=>{o&&N4(n,o)})}),c}function z_(n,e,t,s=0,r=1){const i=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(e),o=n.size,l=(o-1)*s;return typeof t=="function"?t(i,o):r===1?i*s:l-i*s}function fv(n,e,t={}){const s=Sc(n,e,t.type==="exit"?n.presenceContext?.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=s||{};t.transitionOverride&&(r=t.transitionOverride);const i=s?()=>Promise.all(P_(n,s,t)):()=>Promise.resolve(),o=n.variantChildren&&n.variantChildren.size?(c=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:p}=r;return B4(n,e,c,h,d,p,t)}:()=>Promise.resolve(),{when:l}=r;if(l){const[c,h]=l==="beforeChildren"?[i,o]:[o,i];return c().then(()=>h())}else return Promise.all([i(),o(t.delay)])}function B4(n,e,t=0,s=0,r=0,i=1,o){const l=[];for(const c of n.variantChildren)c.notify("AnimationStart",e),l.push(fv(c,e,{...o,delay:t+(typeof s=="function"?0:s)+z_(n.variantChildren,c,s,r,i)}).then(()=>c.notify("AnimationComplete",e)));return Promise.all(l)}function V4(n,e,t={}){n.notify("AnimationStart",e);let s;if(Array.isArray(e)){const r=e.map(i=>fv(n,i,t));s=Promise.all(r)}else if(typeof e=="string")s=fv(n,e,t);else{const r=typeof e=="function"?Sc(n,e,t.custom):e;s=Promise.all(P_(n,r,t))}return s.then(()=>{n.notify("AnimationComplete",e)})}function B_(n,e){if(!Array.isArray(e))return!1;const t=e.length;if(t!==n.length)return!1;for(let s=0;s<t;s++)if(e[s]!==n[s])return!1;return!0}const U4=zw.length;function V_(n){if(!n)return;if(!n.isControllingVariants){const t=n.parent?V_(n.parent)||{}:{};return n.props.initial!==void 0&&(t.initial=n.props.initial),t}const e={};for(let t=0;t<U4;t++){const s=zw[t],r=n.props[s];(Ih(r)||r===!1)&&(e[s]=r)}return e}const j4=[...Pw].reverse(),G4=Pw.length;function W4(n){return e=>Promise.all(e.map(({animation:t,options:s})=>V4(n,t,s)))}function H4(n){let e=W4(n),t=SE(),s=!0;const r=c=>(h,d)=>{const p=Sc(n,d,c==="exit"?n.presenceContext?.custom:void 0);if(p){const{transition:m,transitionEnd:y,...b}=p;h={...h,...b,...y}}return h};function i(c){e=c(n)}function o(c){const{props:h}=n,d=V_(n.parent)||{},p=[],m=new Set;let y={},b=1/0;for(let w=0;w<G4;w++){const S=j4[w],T=t[S],k=h[S]!==void 0?h[S]:d[S],$=Ih(k),E=S===c?T.isActive:null;E===!1&&(b=w);let N=k===d[S]&&k!==h[S]&&$;if(N&&s&&n.manuallyAnimateOnMount&&(N=!1),T.protectedKeys={...y},!T.isActive&&E===null||!k&&!T.prevProp||rg(k)||typeof k=="boolean")continue;const _=q4(T.prevProp,k);let R=_||S===c&&T.isActive&&!N&&$||w>b&&$,D=!1;const M=Array.isArray(k)?k:[k];let A=M.reduce(r(S),{});E===!1&&(A={});const{prevResolvedValues:z={}}=T,W={...z,...A},Y=B=>{R=!0,m.has(B)&&(D=!0,m.delete(B)),T.needsAnimating[B]=!0;const G=n.getValue(B);G&&(G.liveStyle=!1)};for(const B in W){const G=A[B],ee=z[B];if(y.hasOwnProperty(B))continue;let Z=!1;hv(G)&&hv(ee)?Z=!B_(G,ee):Z=G!==ee,Z?G!=null?Y(B):m.add(B):G!==void 0&&m.has(B)?Y(B):T.protectedKeys[B]=!0}T.prevProp=k,T.prevResolvedValues=A,T.isActive&&(y={...y,...A}),s&&n.blockInitialAnimation&&(R=!1);const K=N&&_;R&&(!K||D)&&p.push(...M.map(B=>{const G={type:S};if(typeof B=="string"&&s&&!K&&n.manuallyAnimateOnMount&&n.parent){const{parent:ee}=n,Z=Sc(ee,B);if(ee.enteringChildren&&Z){const{delayChildren:F}=Z.transition||{};G.delay=z_(ee.enteringChildren,n,F)}}return{animation:B,options:G}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const S=Sc(n,Array.isArray(h.initial)?h.initial[0]:h.initial);S&&S.transition&&(w.transition=S.transition)}m.forEach(S=>{const T=n.getBaseTarget(S),k=n.getValue(S);k&&(k.liveStyle=!0),w[S]=T??null}),p.push({animation:w})}let x=!!p.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?e(p):Promise.resolve()}function l(c,h){if(t[c].isActive===h)return Promise.resolve();n.variantChildren?.forEach(p=>p.animationState?.setActive(c,h)),t[c].isActive=h;const d=o(c);for(const p in t)t[p].protectedKeys={};return d}return{animateChanges:o,setActive:l,setAnimateFunction:i,getState:()=>t,reset:()=>{t=SE()}}}function q4(n,e){return typeof e=="string"?e!==n:Array.isArray(e)?!B_(e,n):!1}function va(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function SE(){return{animate:va(!0),whileInView:va(),whileHover:va(),whileTap:va(),whileDrag:va(),whileFocus:va(),exit:va()}}class jo{constructor(e){this.isMounted=!1,this.node=e}update(){}}class K4 extends jo{constructor(e){super(e),e.animationState||(e.animationState=H4(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();rg(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let X4=0;class Y4 extends jo{constructor(){super(...arguments),this.id=X4++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===s)return;const r=this.node.animationState.setActive("exit",!e);t&&!e&&r.then(()=>{t(this.id)})}mount(){const{register:e,onExitComplete:t}=this.node.presenceContext||{};t&&t(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const J4={animation:{Feature:K4},exit:{Feature:Y4}};function Nh(n,e,t,s={passive:!0}){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t)}function Zh(n){return{point:{x:n.pageX,y:n.pageY}}}const Z4=n=>e=>Fw(e)&&n(e,Zh(e));function gh(n,e,t,s){return Nh(n,e,Z4(t),s)}const U_=1e-4,Q4=1-U_,ej=1+U_,j_=.01,tj=0-j_,nj=0+j_;function ps(n){return n.max-n.min}function sj(n,e,t){return Math.abs(n-e)<=t}function CE(n,e,t,s=.5){n.origin=s,n.originPoint=qt(e.min,e.max,n.origin),n.scale=ps(t)/ps(e),n.translate=qt(t.min,t.max,n.origin)-n.originPoint,(n.scale>=Q4&&n.scale<=ej||isNaN(n.scale))&&(n.scale=1),(n.translate>=tj&&n.translate<=nj||isNaN(n.translate))&&(n.translate=0)}function yh(n,e,t,s){CE(n.x,e.x,t.x,s?s.originX:void 0),CE(n.y,e.y,t.y,s?s.originY:void 0)}function TE(n,e,t){n.min=t.min+e.min,n.max=n.min+ps(e)}function rj(n,e,t){TE(n.x,e.x,t.x),TE(n.y,e.y,t.y)}function kE(n,e,t){n.min=e.min-t.min,n.max=n.min+ps(e)}function Sm(n,e,t){kE(n.x,e.x,t.x),kE(n.y,e.y,t.y)}function hr(n){return[n("x"),n("y")]}const G_=({current:n})=>n?n.ownerDocument.defaultView:null,$E=(n,e)=>Math.abs(n-e);function ij(n,e){const t=$E(n.x,e.x),s=$E(n.y,e.y);return Math.sqrt(t**2+s**2)}class W_{constructor(e,t,{transformPagePoint:s,contextWindow:r=window,dragSnapToOrigin:i=!1,distanceThreshold:o=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=hx(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=ij(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=Wn;this.history.push({...x,timestamp:w});const{onStart:S,onMove:T}=this.handlers;y||(S&&S(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),T&&T(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=ux(y,this.transformPagePoint),jt.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const S=hx(m.type==="pointercancel"?this.lastMoveEventInfo:ux(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,S),x&&x(m,S)},!Fw(e))return;this.dragSnapToOrigin=i,this.handlers=t,this.transformPagePoint=s,this.distanceThreshold=o,this.contextWindow=r||window;const l=Zh(e),c=ux(l,this.transformPagePoint),{point:h}=c,{timestamp:d}=Wn;this.history=[{...h,timestamp:d}];const{onSessionStart:p}=t;p&&p(e,hx(c,this.history)),this.removeListeners=Xh(gh(this.contextWindow,"pointermove",this.handlePointerMove),gh(this.contextWindow,"pointerup",this.handlePointerUp),gh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),Mo(this.updatePoint)}}function ux(n,e){return e?{point:e(n.point)}:n}function EE(n,e){return{x:n.x-e.x,y:n.y-e.y}}function hx({point:n},e){return{point:n,delta:EE(n,H_(e)),offset:EE(n,oj(e)),velocity:aj(e,.1)}}function oj(n){return n[0]}function H_(n){return n[n.length-1]}function aj(n,e){if(n.length<2)return{x:0,y:0};let t=n.length-1,s=null;const r=H_(n);for(;t>=0&&(s=n[t],!(r.timestamp-s.timestamp>ii(e)));)t--;if(!s)return{x:0,y:0};const i=mr(r.timestamp-s.timestamp);if(i===0)return{x:0,y:0};const o={x:(r.x-s.x)/i,y:(r.y-s.y)/i};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}function lj(n,{min:e,max:t},s){return e!==void 0&&n<e?n=s?qt(e,n,s.min):Math.max(n,e):t!==void 0&&n>t&&(n=s?qt(t,n,s.max):Math.min(n,t)),n}function IE(n,e,t){return{min:e!==void 0?n.min+e:void 0,max:t!==void 0?n.max+t-(n.max-n.min):void 0}}function cj(n,{top:e,left:t,bottom:s,right:r}){return{x:IE(n.x,t,r),y:IE(n.y,e,s)}}function NE(n,e){let t=e.min-n.min,s=e.max-n.max;return e.max-e.min<n.max-n.min&&([t,s]=[s,t]),{min:t,max:s}}function uj(n,e){return{x:NE(n.x,e.x),y:NE(n.y,e.y)}}function hj(n,e){let t=.5;const s=ps(n),r=ps(e);return r>s?t=kh(e.min,e.max-s,n.min):s>r&&(t=kh(n.min,n.max-r,e.min)),Ui(0,1,t)}function dj(n,e){const t={};return e.min!==void 0&&(t.min=e.min-n.min),e.max!==void 0&&(t.max=e.max-n.min),t}const pv=.35;function fj(n=pv){return n===!1?n=0:n===!0&&(n=pv),{x:AE(n,"left","right"),y:AE(n,"top","bottom")}}function AE(n,e,t){return{min:_E(n,e),max:_E(n,t)}}function _E(n,e){return typeof n=="number"?n:n[e]||0}const pj=new WeakMap;class mj{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=kn(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=e}start(e,{snapToCursor:t=!1,distanceThreshold:s}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const i=p=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),t&&this.snapToCursor(Zh(p).point)},o=(p,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=vU(y),!this.openDragLock))return;this.latestPointerEvent=p,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),hr(S=>{let T=this.getAxisMotionValue(S).get()||0;if(oi.test(T)){const{projection:k}=this.visualElement;if(k&&k.layout){const $=k.layout.layoutBox[S];$&&(T=ps($)*(parseFloat(T)/100))}}this.originPoint[S]=T}),x&&jt.postRender(()=>x(p,m)),dv(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},l=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:S}=m;if(b&&this.currentDirection===null){this.currentDirection=gj(S),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,S),this.updateAxis("y",m.point,S),this.visualElement.render(),w&&w(p,m)},c=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m,this.stop(p,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>hr(p=>this.getAnimationState(p)==="paused"&&this.getAxisMotionValue(p).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new W_(e,{onSessionStart:i,onStart:o,onMove:l,onSessionEnd:c,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:G_(this.visualElement)})}stop(e,t){const s=e||this.latestPointerEvent,r=t||this.latestPanInfo,i=this.isDragging;if(this.cancel(),!i||!r||!s)return;const{velocity:o}=r;this.startAnimation(o);const{onDragEnd:l}=this.getProps();l&&jt.postRender(()=>l(s,r))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,s){const{drag:r}=this.getProps();if(!s||!Bp(e,r,this.currentDirection))return;const i=this.getAxisMotionValue(e);let o=this.originPoint[e]+s[e];this.constraints&&this.constraints[e]&&(o=lj(o,this.constraints[e],this.elastic[e])),i.set(o)}resolveConstraints(){const{dragConstraints:e,dragElastic:t}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;e&&yc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&s?this.constraints=cj(s.layoutBox,e):this.constraints=!1,this.elastic=fj(t),r!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&hr(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=dj(s.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!yc(e))return!1;const s=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const i=y4(s,r.root,this.visualElement.getTransformPagePoint());let o=uj(r.layout.layoutBox,i);if(t){const l=t(p4(o));this.hasMutatedConstraints=!!l,l&&(o=N_(l))}return o}startAnimation(e){const{drag:t,dragMomentum:s,dragElastic:r,dragTransition:i,dragSnapToOrigin:o,onDragTransitionEnd:l}=this.getProps(),c=this.constraints||{},h=hr(d=>{if(!Bp(d,t,this.currentDirection))return;let p=c&&c[d]||{};o&&(p={min:0,max:0});const m=r?200:1e6,y=r?40:1e7,b={type:"inertia",velocity:s?e[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...i,...p};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(l)}startAxisValueAnimation(e,t){const s=this.getAxisMotionValue(e);return dv(this.visualElement,e),s.start(Hw(e,s,0,t,this.visualElement,!1))}stopAnimation(){hr(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){hr(e=>this.getAxisMotionValue(e).animation?.pause())}getAnimationState(e){return this.getAxisMotionValue(e).animation?.state}getAxisMotionValue(e){const t=`_drag${e.toUpperCase()}`,s=this.visualElement.getProps(),r=s[t];return r||this.visualElement.getValue(e,(s.initial?s.initial[e]:void 0)||0)}snapToCursor(e){hr(t=>{const{drag:s}=this.getProps();if(!Bp(t,s,this.currentDirection))return;const{projection:r}=this.visualElement,i=this.getAxisMotionValue(t);if(r&&r.layout){const{min:o,max:l}=r.layout.layoutBox[t];i.set(e[t]-qt(o,l,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:s}=this.visualElement;if(!yc(t)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};hr(o=>{const l=this.getAxisMotionValue(o);if(l&&this.constraints!==!1){const c=l.get();r[o]=hj({min:c,max:c},this.constraints[o])}});const{transformTemplate:i}=this.visualElement.getProps();this.visualElement.current.style.transform=i?i({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),hr(o=>{if(!Bp(o,e,null))return;const l=this.getAxisMotionValue(o),{min:c,max:h}=this.constraints[o];l.set(qt(c,h,r[o]))})}addListeners(){if(!this.visualElement.current)return;pj.set(this.visualElement,this);const e=this.visualElement.current,t=gh(e,"pointerdown",c=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(c)}),s=()=>{const{dragConstraints:c}=this.getProps();yc(c)&&c.current&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,i=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),jt.read(s);const o=Nh(window,"resize",()=>this.scalePositionWithinConstraints()),l=r.addEventListener("didUpdate",(({delta:c,hasLayoutChanged:h})=>{this.isDragging&&h&&(hr(d=>{const p=this.getAxisMotionValue(d);p&&(this.originPoint[d]+=c[d].translate,p.set(p.get()+c[d].translate))}),this.visualElement.render())}));return()=>{o(),t(),i(),l&&l()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:i=!1,dragElastic:o=pv,dragMomentum:l=!0}=e;return{...e,drag:t,dragDirectionLock:s,dragPropagation:r,dragConstraints:i,dragElastic:o,dragMomentum:l}}}function Bp(n,e,t){return(e===!0||e===n)&&(t===null||t===n)}function gj(n,e=10){let t=null;return Math.abs(n.y)>e?t="y":Math.abs(n.x)>e&&(t="x"),t}class yj extends jo{constructor(e){super(e),this.removeGroupControls=br,this.removeListeners=br,this.controls=new mj(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||br}unmount(){this.removeGroupControls(),this.removeListeners()}}const RE=n=>(e,t)=>{n&&jt.postRender(()=>n(e,t))};class bj extends jo{constructor(){super(...arguments),this.removePointerDownListener=br}onPointerDown(e){this.session=new W_(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:G_(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:RE(e),onStart:RE(t),onMove:s,onEnd:(i,o)=>{delete this.session,r&&jt.postRender(()=>r(i,o))}}}mount(){this.removePointerDownListener=gh(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const am={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let dx=!1;class xj extends Se.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s,layoutId:r}=this.props,{projection:i}=e;i&&(t.group&&t.group.add(i),s&&s.register&&r&&s.register(i),dx&&i.root.didUpdate(),i.addEventListener("animationComplete",()=>{this.safeToRemove()}),i.setOptions({...i.options,onExitComplete:()=>this.safeToRemove()})),am.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:s,drag:r,isPresent:i}=this.props,{projection:o}=s;return o&&(o.isPresent=i,dx=!0,r||e.layoutDependency!==t||t===void 0||e.isPresent!==i?o.willUpdate():this.safeToRemove(),e.isPresent!==i&&(i?o.promote():o.relegate()||jt.postRender(()=>{const l=o.getStack();(!l||!l.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),Mw.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s}=this.props,{projection:r}=e;dx=!0,r&&(r.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function q_(n){const[e,t]=m_(),s=Se.useContext(pw);return oe.jsx(xj,{...n,layoutGroup:s,switchLayoutGroup:Se.useContext(E_),isPresent:e,safeToRemove:t})}function vj(n,e,t){const s=ns(n)?n:Nc(n);return s.start(Hw("",s,e,t)),s.animation}const wj=(n,e)=>n.depth-e.depth;class Sj{constructor(){this.children=[],this.isDirty=!1}add(e){yw(this.children,e),this.isDirty=!0}remove(e){bw(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(wj),this.isDirty=!1,this.children.forEach(e)}}function Cj(n,e){const t=Is.now(),s=({timestamp:r})=>{const i=r-t;i>=e&&(Mo(s),n(i-e))};return jt.setup(s,!0),()=>Mo(s)}const K_=["TopLeft","TopRight","BottomLeft","BottomRight"],Tj=K_.length,DE=n=>typeof n=="string"?parseFloat(n):n,OE=n=>typeof n=="number"||He.test(n);function kj(n,e,t,s,r,i){r?(n.opacity=qt(0,t.opacity??1,$j(s)),n.opacityExit=qt(e.opacity??1,0,Ej(s))):i&&(n.opacity=qt(e.opacity??1,t.opacity??1,s));for(let o=0;o<Tj;o++){const l=`border${K_[o]}Radius`;let c=ME(e,l),h=ME(t,l);if(c===void 0&&h===void 0)continue;c||(c=0),h||(h=0),c===0||h===0||OE(c)===OE(h)?(n[l]=Math.max(qt(DE(c),DE(h),s),0),(oi.test(h)||oi.test(c))&&(n[l]+="%")):n[l]=h}(e.rotate||t.rotate)&&(n.rotate=qt(e.rotate||0,t.rotate||0,s))}function ME(n,e){return n[e]!==void 0?n[e]:n.borderRadius}const $j=X_(0,.5,OA),Ej=X_(.5,.95,br);function X_(n,e,t){return s=>s<n?0:s>e?1:t(kh(n,e,s))}function FE(n,e){n.min=e.min,n.max=e.max}function Ar(n,e){FE(n.x,e.x),FE(n.y,e.y)}function LE(n,e){n.translate=e.translate,n.scale=e.scale,n.originPoint=e.originPoint,n.origin=e.origin}function PE(n,e,t,s,r){return n-=e,n=wm(n,1/t,s),r!==void 0&&(n=wm(n,1/r,s)),n}function Ij(n,e=0,t=1,s=.5,r,i=n,o=n){if(oi.test(e)&&(e=parseFloat(e),e=qt(o.min,o.max,e/100)-o.min),typeof e!="number")return;let l=qt(i.min,i.max,s);n===i&&(l-=e),n.min=PE(n.min,e,t,l,r),n.max=PE(n.max,e,t,l,r)}function zE(n,e,[t,s,r],i,o){Ij(n,e[t],e[s],e[r],e.scale,i,o)}const Nj=["x","scaleX","originX"],Aj=["y","scaleY","originY"];function BE(n,e,t,s){zE(n.x,e,Nj,t?t.x:void 0,s?s.x:void 0),zE(n.y,e,Aj,t?t.y:void 0,s?s.y:void 0)}function VE(n){return n.translate===0&&n.scale===1}function Y_(n){return VE(n.x)&&VE(n.y)}function UE(n,e){return n.min===e.min&&n.max===e.max}function _j(n,e){return UE(n.x,e.x)&&UE(n.y,e.y)}function jE(n,e){return Math.round(n.min)===Math.round(e.min)&&Math.round(n.max)===Math.round(e.max)}function J_(n,e){return jE(n.x,e.x)&&jE(n.y,e.y)}function GE(n){return ps(n.x)/ps(n.y)}function WE(n,e){return n.translate===e.translate&&n.scale===e.scale&&n.originPoint===e.originPoint}class Rj{constructor(){this.members=[]}add(e){yw(this.members,e),e.scheduleRender()}remove(e){if(bw(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(e){const t=this.members.findIndex(r=>e===r);if(t===0)return!1;let s;for(let r=t;r>=0;r--){const i=this.members[r];if(i.isPresent!==!1){s=i;break}}return s?(this.promote(s),!0):!1}promote(e,t){const s=this.lead;if(e!==s&&(this.prevLead=s,this.lead=e,e.show(),s)){s.instance&&s.scheduleRender(),e.scheduleRender(),e.resumeFrom=s,t&&(e.resumeFrom.preserveOpacity=!0),s.snapshot&&(e.snapshot=s.snapshot,e.snapshot.latestValues=s.animationValues||s.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:t,resumingFrom:s}=e;t.onExitComplete&&t.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function Dj(n,e,t){let s="";const r=n.x.translate/e.x,i=n.y.translate/e.y,o=t?.z||0;if((r||i||o)&&(s=`translate3d(${r}px, ${i}px, ${o}px) `),(e.x!==1||e.y!==1)&&(s+=`scale(${1/e.x}, ${1/e.y}) `),t){const{transformPerspective:h,rotate:d,rotateX:p,rotateY:m,skewX:y,skewY:b}=t;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),p&&(s+=`rotateX(${p}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const l=n.x.scale*e.x,c=n.y.scale*e.y;return(l!==1||c!==1)&&(s+=`scale(${l}, ${c})`),s||"none"}const fx=["","X","Y","Z"],Oj=1e3;let Mj=0;function px(n,e,t,s){const{latestValues:r}=e;r[n]&&(t[n]=r[n],e.setStaticValue(n,0),s&&(s[n]=0))}function Z_(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:e}=n.options;if(!e)return;const t=L_(e);if(window.MotionHasOptimisedAnimation(t,"transform")){const{layout:r,layoutId:i}=n.options;window.MotionCancelOptimisedAnimation(t,"transform",jt,!(r||i))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&Z_(s)}function Q_({attachResizeListener:n,defaultParent:e,measureScroll:t,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(o={},l=e?.()){this.id=Mj++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(Pj),this.nodes.forEach(Uj),this.nodes.forEach(jj),this.nodes.forEach(zj)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=l?l.root||l:this,this.path=l?[...l.path,l]:[],this.parent=l,this.depth=l?l.depth+1:0;for(let c=0;c<this.path.length;c++)this.path[c].shouldResetTransform=!0;this.root===this&&(this.nodes=new Sj)}addEventListener(o,l){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new ww),this.eventHandlers.get(o).add(l)}notifyListeners(o,...l){const c=this.eventHandlers.get(o);c&&c.notify(...l)}hasListeners(o){return this.eventHandlers.has(o)}mount(o){if(this.instance)return;this.isSVG=p_(o)&&!$U(o),this.instance=o;const{layoutId:l,layout:c,visualElement:h}=this.options;if(h&&!h.current&&h.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(c||l)&&(this.isLayoutDirty=!0),n){let d,p=0;const m=()=>this.root.updateBlockedByResize=!1;jt.read(()=>{p=window.innerWidth}),n(o,()=>{const y=window.innerWidth;y!==p&&(p=y,this.root.updateBlockedByResize=!0,d&&d(),d=Cj(m,250),am.hasAnimatedSinceResize&&(am.hasAnimatedSinceResize=!1,this.nodes.forEach(KE)))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&h&&(l||c)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:p,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||Kj,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),S=!this.targetLayout||!J_(this.targetLayout,y),T=!p&&m;if(this.options.layoutRoot||this.resumeFrom||T||p&&(S||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const k={...Dw(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(k.delay=0,k.type=!1),this.startAnimation(k),this.setAnimationOrigin(d,T)}else p||KE(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),Mo(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Gj),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&Z_(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const p=this.path[d];p.shouldResetTransform=!0,p.updateScroll("snapshot"),p.options.layoutRoot&&p.willUpdate(!1)}const{layoutId:l,layout:c}=this.options;if(l===void 0&&!c)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(HE);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(qE);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(Vj),this.nodes.forEach(Fj),this.nodes.forEach(Lj)):this.nodes.forEach(qE),this.clearAllSnapshots();const l=Is.now();Wn.delta=Ui(0,1e3/60,l-Wn.timestamp),Wn.timestamp=l,Wn.isProcessing=!0,nx.update.process(Wn),nx.preRender.process(Wn),nx.render.process(Wn),Wn.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Mw.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Bj),this.sharedNodes.forEach(Wj)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,jt.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){jt.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!ps(this.snapshot.measuredBox.x)&&!ps(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let c=0;c<this.path.length;c++)this.path[c].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=kn(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:l}=this.options;l&&l.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let l=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(l=!1),l&&this.instance){const c=s(this.instance);this.scroll={animationId:this.root.animationId,phase:o,isRoot:c,offset:t(this.instance),wasRoot:this.scroll?this.scroll.isRoot:c}}}resetTransform(){if(!r)return;const o=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,l=this.projectionDelta&&!Y_(this.projectionDelta),c=this.getTransformTemplate(),h=c?c(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;o&&this.instance&&(l||Ea(this.latestValues)||d)&&(r(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const l=this.measurePageBox();let c=this.removeElementScroll(l);return o&&(c=this.removeTransform(c)),Xj(c),{animationId:this.root.animationId,measuredBox:l,layoutBox:c,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:o}=this.options;if(!o)return kn();const l=o.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(Yj))){const{scroll:h}=this.root;h&&(bc(l.x,h.offset.x),bc(l.y,h.offset.y))}return l}removeElementScroll(o){const l=kn();if(Ar(l,o),this.scroll?.wasRoot)return l;for(let c=0;c<this.path.length;c++){const h=this.path[c],{scroll:d,options:p}=h;h!==this.root&&d&&p.layoutScroll&&(d.wasRoot&&Ar(l,o),bc(l.x,d.offset.x),bc(l.y,d.offset.y))}return l}applyTransform(o,l=!1){const c=kn();Ar(c,o);for(let h=0;h<this.path.length;h++){const d=this.path[h];!l&&d.options.layoutScroll&&d.scroll&&d!==d.root&&xc(c,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),Ea(d.latestValues)&&xc(c,d.latestValues)}return Ea(this.latestValues)&&xc(c,this.latestValues),c}removeTransform(o){const l=kn();Ar(l,o);for(let c=0;c<this.path.length;c++){const h=this.path[c];if(!h.instance||!Ea(h.latestValues))continue;lv(h.latestValues)&&h.updateSnapshot();const d=kn(),p=h.measurePageBox();Ar(d,p),BE(l,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return Ea(this.latestValues)&&BE(l,this.latestValues),l}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==Wn.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const c=!!this.resumingFrom||this!==l;if(!(o||c&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:p}=this.options;if(!this.layout||!(d||p))return;this.resolvedRelativeTargetAt=Wn.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=kn(),this.targetWithTransforms=kn()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),rj(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Ar(this.target,this.layout.layoutBox),__(this.target,this.targetDelta)):Ar(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||lv(this.parent.latestValues)||A_(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(o,l,c){this.relativeParent=o,this.linkedParentVersion=o.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=kn(),this.relativeTargetOrigin=kn(),Sm(this.relativeTargetOrigin,l,c),Ar(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const o=this.getLead(),l=!!this.resumingFrom||this!==o;let c=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(c=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(c=!1),this.resolvedRelativeTargetAt===Wn.timestamp&&(c=!1),c)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;Ar(this.layoutCorrected,this.layout.layoutBox);const p=this.treeScale.x,m=this.treeScale.y;g4(this.layoutCorrected,this.treeScale,this.path,l),o.layout&&!o.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(o.target=o.layout.layoutBox,o.targetWithTransforms=kn());const{target:y}=o;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(LE(this.prevProjectionDelta.x,this.projectionDelta.x),LE(this.prevProjectionDelta.y,this.projectionDelta.y)),yh(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==p||this.treeScale.y!==m||!WE(this.projectionDelta.x,this.prevProjectionDelta.x)||!WE(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){if(this.options.visualElement?.scheduleRender(),o){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=vc(),this.projectionDelta=vc(),this.projectionDeltaWithTransform=vc()}setAnimationOrigin(o,l=!1){const c=this.snapshot,h=c?c.latestValues:{},d={...this.latestValues},p=vc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!l;const m=kn(),y=c?c.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),S=!w||w.members.length<=1,T=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(qj));this.animationProgress=0;let k;this.mixTargetDelta=$=>{const E=$/1e3;XE(p.x,o.x,E),XE(p.y,o.y,E),this.setTargetDelta(p),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Sm(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),Hj(this.relativeTarget,this.relativeTargetOrigin,m,E),k&&_j(this.relativeTarget,k)&&(this.isProjectionDirty=!1),k||(k=kn()),Ar(k,this.relativeTarget)),x&&(this.animationValues=d,kj(d,h,this.latestValues,E,T,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(Mo(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=jt.update(()=>{am.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Nc(0)),this.currentAnimation=vj(this.motionValue,[0,1e3],{...o,velocity:0,isSync:!0,onUpdate:l=>{this.mixTargetDelta(l),o.onUpdate&&o.onUpdate(l)},onStop:()=>{},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(Oj),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:l,target:c,layout:h,latestValues:d}=o;if(!(!l||!c||!h)){if(this!==o&&this.layout&&h&&eR(this.options.animationType,this.layout.layoutBox,h.layoutBox)){c=this.target||kn();const p=ps(this.layout.layoutBox.x);c.x.min=o.target.x.min,c.x.max=c.x.min+p;const m=ps(this.layout.layoutBox.y);c.y.min=o.target.y.min,c.y.max=c.y.min+m}Ar(l,c),xc(l,d),yh(this.projectionDeltaWithTransform,this.layoutCorrected,l,d)}}registerSharedNode(o,l){this.sharedNodes.has(o)||this.sharedNodes.set(o,new Rj),this.sharedNodes.get(o).add(l);const h=l.options.initialPromotionConfig;l.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(l):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){const{layoutId:o}=this.options;return o?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:o}=this.options;return o?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:l,preserveFollowOpacity:c}={}){const h=this.getStack();h&&h.promote(this,c),o&&(this.projectionDelta=void 0,this.needsReset=!0),l&&this.setOptions({transition:l})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetSkewAndRotation(){const{visualElement:o}=this.options;if(!o)return;let l=!1;const{latestValues:c}=o;if((c.z||c.rotate||c.rotateX||c.rotateY||c.rotateZ||c.skewX||c.skewY)&&(l=!0),!l)return;const h={};c.z&&px("z",o,h,this.animationValues);for(let d=0;d<fx.length;d++)px(`rotate${fx[d]}`,o,h,this.animationValues),px(`skew${fx[d]}`,o,h,this.animationValues);o.render();for(const d in h)o.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);o.scheduleRender()}applyProjectionStyles(o,l){if(!this.instance||this.isSVG)return;if(!this.isVisible){o.visibility="hidden";return}const c=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,o.visibility="",o.opacity="",o.pointerEvents=om(l?.pointerEvents)||"",o.transform=c?c(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(o.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,o.pointerEvents=om(l?.pointerEvents)||""),this.hasProjected&&!Ea(this.latestValues)&&(o.transform=c?c({},""):"none",this.hasProjected=!1);return}o.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let p=Dj(this.projectionDeltaWithTransform,this.treeScale,d);c&&(p=c(d,p)),o.transform=p;const{x:m,y}=this.projectionDelta;o.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?o.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:o.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in av){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:S}=av[b],T=p==="none"?d[b]:x(d[b],h);if(w){const k=w.length;for(let $=0;$<k;$++)o[w[$]]=T}else S?this.options.visualElement.renderState.vars[b]=T:o[b]=T}this.options.layoutId&&(o.pointerEvents=h===this?om(l?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>o.currentAnimation?.stop()),this.root.nodes.forEach(HE),this.root.sharedNodes.clear()}}}function Fj(n){n.updateLayout()}function Lj(n){const e=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&e&&n.hasListeners("didUpdate")){const{layoutBox:t,measuredBox:s}=n.layout,{animationType:r}=n.options,i=e.source!==n.layout.source;r==="size"?hr(d=>{const p=i?e.measuredBox[d]:e.layoutBox[d],m=ps(p);p.min=t[d].min,p.max=p.min+m}):eR(r,e.layoutBox,t)&&hr(d=>{const p=i?e.measuredBox[d]:e.layoutBox[d],m=ps(t[d]);p.max=p.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const o=vc();yh(o,t,e.layoutBox);const l=vc();i?yh(l,n.applyTransform(s,!0),e.measuredBox):yh(l,t,e.layoutBox);const c=!Y_(o);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:p,layout:m}=d;if(p&&m){const y=kn();Sm(y,e.layoutBox,p.layoutBox);const b=kn();Sm(b,t,m.layoutBox),J_(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:t,snapshot:e,delta:l,layoutDelta:o,hasLayoutChanged:c,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:t}=n.options;t&&t()}n.options.transition=void 0}function Pj(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function zj(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Bj(n){n.clearSnapshot()}function HE(n){n.clearMeasurements()}function qE(n){n.isLayoutDirty=!1}function Vj(n){const{visualElement:e}=n.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),n.resetTransform()}function KE(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function Uj(n){n.resolveTargetDelta()}function jj(n){n.calcProjection()}function Gj(n){n.resetSkewAndRotation()}function Wj(n){n.removeLeadSnapshot()}function XE(n,e,t){n.translate=qt(e.translate,0,t),n.scale=qt(e.scale,1,t),n.origin=e.origin,n.originPoint=e.originPoint}function YE(n,e,t,s){n.min=qt(e.min,t.min,s),n.max=qt(e.max,t.max,s)}function Hj(n,e,t,s){YE(n.x,e.x,t.x,s),YE(n.y,e.y,t.y,s)}function qj(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const Kj={duration:.45,ease:[.4,0,.1,1]},JE=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),ZE=JE("applewebkit/")&&!JE("chrome/")?Math.round:br;function QE(n){n.min=ZE(n.min),n.max=ZE(n.max)}function Xj(n){QE(n.x),QE(n.y)}function eR(n,e,t){return n==="position"||n==="preserve-aspect"&&!sj(GE(e),GE(t),.2)}function Yj(n){return n!==n.root&&n.scroll?.wasRoot}const Jj=Q_({attachResizeListener:(n,e)=>Nh(n,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),mx={current:void 0},tR=Q_({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!mx.current){const n=new Jj({});n.mount(window),n.setOptions({layoutScroll:!0}),mx.current=n}return mx.current},resetTransform:(n,e)=>{n.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),Zj={pan:{Feature:bj},drag:{Feature:yj,ProjectionNode:tR,MeasureLayout:q_}};function eI(n,e,t){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",t==="Start");const r="onHover"+t,i=s[r];i&&jt.postRender(()=>i(e,Zh(e)))}class Qj extends jo{mount(){const{current:e}=this.node;e&&(this.unmount=wU(e,(t,s)=>(eI(this.node,s,"Start"),r=>eI(this.node,r,"End"))))}unmount(){}}class eG extends jo{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Xh(Nh(this.node.current,"focus",()=>this.onFocus()),Nh(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function tI(n,e,t){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",t==="Start");const r="onTap"+(t==="End"?"":t),i=s[r];i&&jt.postRender(()=>i(e,Zh(e)))}class tG extends jo{mount(){const{current:e}=this.node;e&&(this.unmount=kU(e,(t,s)=>(tI(this.node,s,"Start"),(r,{success:i})=>tI(this.node,r,i?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const mv=new WeakMap,gx=new WeakMap,nG=n=>{const e=mv.get(n.target);e&&e(n)},sG=n=>{n.forEach(nG)};function rG({root:n,...e}){const t=n||document;gx.has(t)||gx.set(t,{});const s=gx.get(t),r=JSON.stringify(e);return s[r]||(s[r]=new IntersectionObserver(sG,{root:n,...e})),s[r]}function iG(n,e,t){const s=rG(e);return mv.set(n,t),s.observe(n),()=>{mv.delete(n),s.unobserve(n)}}const oG={some:0,all:1};class aG extends jo{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:s,amount:r="some",once:i}=e,o={root:t?t.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:oG[r]},l=c=>{const{isIntersecting:h}=c;if(this.isInView===h||(this.isInView=h,i&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:p}=this.node.getProps(),m=h?d:p;m&&m(c)};return iG(this.node.current,o,l)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(lG(e,t))&&this.startObserver()}unmount(){}}function lG({viewport:n={}},{viewport:e={}}={}){return t=>n[t]!==e[t]}const cG={inView:{Feature:aG},tap:{Feature:tG},focus:{Feature:eG},hover:{Feature:Qj}},uG={layout:{ProjectionNode:tR,MeasureLayout:q_}},hG={...J4,...cG,...Zj,...uG},wa=f4(hG,$4);const dG=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),fG=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,s)=>s?s.toUpperCase():t.toLowerCase()),nI=n=>{const e=fG(n);return e.charAt(0).toUpperCase()+e.slice(1)},nR=(...n)=>n.filter((e,t,s)=>!!e&&e.trim()!==""&&s.indexOf(e)===t).join(" ").trim(),pG=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var mG={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const gG=Se.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:t=2,absoluteStrokeWidth:s,className:r="",children:i,iconNode:o,...l},c)=>Se.createElement("svg",{ref:c,...mG,width:e,height:e,stroke:n,strokeWidth:s?Number(t)*24/Number(e):t,className:nR("lucide",r),...!i&&!pG(l)&&{"aria-hidden":"true"},...l},[...o.map(([h,d])=>Se.createElement(h,d)),...Array.isArray(i)?i:[i]]));const is=(n,e)=>{const t=Se.forwardRef(({className:s,...r},i)=>Se.createElement(gG,{ref:i,iconNode:e,className:nR(`lucide-${dG(nI(n))}`,`lucide-${n}`,s),...r}));return t.displayName=nI(n),t};const yG=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],bG=is("activity",yG);const xG=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],vG=is("circle-check",xG);const wG=[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]],SG=is("copy",wG);const CG=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],TG=is("cpu",CG);const kG=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],sI=is("history",kG);const $G=[["path",{d:"M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",key:"zw3jo"}],["path",{d:"M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",key:"1wduqc"}],["path",{d:"M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",key:"kqbvx6"}]],EG=is("layers",$G);const IG=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],rI=is("lock",IG);const NG=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],AG=is("log-out",NG);const _G=[["path",{d:"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",key:"1a8usu"}],["path",{d:"m15 5 4 4",key:"1mk7zo"}]],RG=is("pencil",_G);const DG=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],OG=is("search",DG);const MG=[["circle",{cx:"18",cy:"5",r:"3",key:"gq8acd"}],["circle",{cx:"6",cy:"12",r:"3",key:"w7nqdw"}],["circle",{cx:"18",cy:"19",r:"3",key:"1xt0gg"}],["line",{x1:"8.59",x2:"15.42",y1:"13.51",y2:"17.49",key:"47mynk"}],["line",{x1:"15.41",x2:"8.59",y1:"6.51",y2:"10.49",key:"1n3mei"}]],FG=is("share-2",MG);const LG=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],iI=is("trending-down",LG);const PG=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],oI=is("trending-up",PG);const zG=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],BG=is("triangle-alert",zG);const VG=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],UG=is("trophy",VG);const jG=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],aI=is("zap",jG);function og(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t}function GG(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function l(d){try{h(s.next(d))}catch(p){o(p)}}function c(d){try{h(s.throw(d))}catch(p){o(p)}}function h(d){d.done?i(d.value):r(d.value).then(l,c)}h((s=s.apply(n,e||[])).next())})}const WG=n=>n?(...e)=>n(...e):(...e)=>fetch(...e);class qw extends Error{constructor(e,t="FunctionsError",s){super(e),this.name=t,this.context=s}}class HG extends qw{constructor(e){super("Failed to send a request to the Edge Function","FunctionsFetchError",e)}}class lI extends qw{constructor(e){super("Relay Error invoking the Edge Function","FunctionsRelayError",e)}}class cI extends qw{constructor(e){super("Edge Function returned a non-2xx status code","FunctionsHttpError",e)}}var gv;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(gv||(gv={}));class qG{constructor(e,{headers:t={},customFetch:s,region:r=gv.Any}={}){this.url=e,this.headers=t,this.region=r,this.fetch=WG(s)}setAuth(e){this.headers.Authorization=`Bearer ${e}`}invoke(e){return GG(this,arguments,void 0,function*(t,s={}){var r;let i,o;try{const{headers:l,method:c,body:h,signal:d,timeout:p}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${t}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(l&&!Object.prototype.hasOwnProperty.call(l,"Content-Type")||!l)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;p&&(o=new AbortController,i=setTimeout(()=>o.abort(),p),d?(w=o.signal,d.addEventListener("abort",()=>o.abort())):w=o.signal);const S=yield this.fetch(b.toString(),{method:c||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),l),body:x,signal:w}).catch(E=>{throw new HG(E)}),T=S.headers.get("x-relay-error");if(T&&T==="true")throw new lI(S);if(!S.ok)throw new cI(S);let k=((r=S.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),$;return k==="application/json"?$=yield S.json():k==="application/octet-stream"||k==="application/pdf"?$=yield S.blob():k==="text/event-stream"?$=S:k==="multipart/form-data"?$=yield S.formData():$=yield S.text(),{data:$,error:null,response:S}}catch(l){return{data:null,error:l,response:l instanceof cI||l instanceof lI?l.context:void 0}}finally{i&&clearTimeout(i)}})}}var KG=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},XG=class{constructor(n){var e,t;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(e=n.shouldThrowOnError)!==null&&e!==void 0?e:!1,this.signal=n.signal,this.isMaybeSingle=(t=n.isMaybeSingle)!==null&&t!==void 0?t:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,e){return this.headers=new Headers(this.headers),this.headers.set(n,e),this}then(n,e){var t=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let r=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async i=>{let o=null,l=null,c=null,h=i.status,d=i.statusText;if(i.ok){var p,m;if(t.method!=="HEAD"){var y;const S=await i.text();S===""||(t.headers.get("Accept")==="text/csv"||t.headers.get("Accept")&&(!((y=t.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?l=S:l=JSON.parse(S))}const x=(p=t.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),w=(m=i.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(c=parseInt(w[1])),t.isMaybeSingle&&t.method==="GET"&&Array.isArray(l)&&(l.length>1?(o={code:"PGRST116",details:`Results contain ${l.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},l=null,c=null,h=406,d="Not Acceptable"):l.length===1?l=l[0]:l=null)}else{var b;const x=await i.text();try{o=JSON.parse(x),Array.isArray(o)&&i.status===404&&(l=[],o=null,h=200,d="OK")}catch{i.status===404&&x===""?(h=204,d="No Content"):o={message:x}}if(o&&t.isMaybeSingle&&(!(o==null||(b=o.details)===null||b===void 0)&&b.includes("0 rows"))&&(o=null,h=200,d="OK"),o&&t.shouldThrowOnError)throw new KG(o)}return{error:o,data:l,count:c,status:h,statusText:d}});return this.shouldThrowOnError||(r=r.catch(i=>{var o;let l="";const c=i?.cause;if(c){var h,d,p,m;const b=(h=c?.message)!==null&&h!==void 0?h:"",x=(d=c?.code)!==null&&d!==void 0?d:"";l=`${(p=i?.name)!==null&&p!==void 0?p:"FetchError"}: ${i?.message}`,l+=`

Caused by: ${(m=c?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(l+=` (${x})`),c?.stack&&(l+=`
${c.stack}`)}else{var y;l=(y=i?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(o=i?.name)!==null&&o!==void 0?o:"FetchError"}: ${i?.message}`,details:l,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(n,e)}returns(){return this}overrideTypes(){return this}},YG=class extends XG{select(n){let e=!1;const t=(n??"*").split("").map(s=>/\s/.test(s)&&!e?"":(s==='"'&&(e=!e),s)).join("");return this.url.searchParams.set("select",t),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:e=!0,nullsFirst:t,foreignTable:s,referencedTable:r=s}={}){const i=r?`${r}.order`:"order",o=this.url.searchParams.get(i);return this.url.searchParams.set(i,`${o?`${o},`:""}${n}.${e?"asc":"desc"}${t===void 0?"":t?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:e,referencedTable:t=e}={}){const s=typeof t>"u"?"limit":`${t}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,e,{foreignTable:t,referencedTable:s=t}={}){const r=typeof s>"u"?"offset":`${s}.offset`,i=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(r,`${n}`),this.url.searchParams.set(i,`${e-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:e=!1,settings:t=!1,buffers:s=!1,wal:r=!1,format:i="text"}={}){var o;const l=[n?"analyze":null,e?"verbose":null,t?"settings":null,s?"buffers":null,r?"wal":null].filter(Boolean).join("|"),c=(o=this.headers.get("Accept"))!==null&&o!==void 0?o:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${i}; for="${c}"; options=${l};`),i==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const uI=new RegExp("[,()]");var uc=class extends YG{eq(n,e){return this.url.searchParams.append(n,`eq.${e}`),this}neq(n,e){return this.url.searchParams.append(n,`neq.${e}`),this}gt(n,e){return this.url.searchParams.append(n,`gt.${e}`),this}gte(n,e){return this.url.searchParams.append(n,`gte.${e}`),this}lt(n,e){return this.url.searchParams.append(n,`lt.${e}`),this}lte(n,e){return this.url.searchParams.append(n,`lte.${e}`),this}like(n,e){return this.url.searchParams.append(n,`like.${e}`),this}likeAllOf(n,e){return this.url.searchParams.append(n,`like(all).{${e.join(",")}}`),this}likeAnyOf(n,e){return this.url.searchParams.append(n,`like(any).{${e.join(",")}}`),this}ilike(n,e){return this.url.searchParams.append(n,`ilike.${e}`),this}ilikeAllOf(n,e){return this.url.searchParams.append(n,`ilike(all).{${e.join(",")}}`),this}ilikeAnyOf(n,e){return this.url.searchParams.append(n,`ilike(any).{${e.join(",")}}`),this}regexMatch(n,e){return this.url.searchParams.append(n,`match.${e}`),this}regexIMatch(n,e){return this.url.searchParams.append(n,`imatch.${e}`),this}is(n,e){return this.url.searchParams.append(n,`is.${e}`),this}isDistinct(n,e){return this.url.searchParams.append(n,`isdistinct.${e}`),this}in(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&uI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${t})`),this}notIn(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&uI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${t})`),this}contains(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cs.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cs.{${e.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(e)}`),this}containedBy(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cd.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cd.{${e.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(e)}`),this}rangeGt(n,e){return this.url.searchParams.append(n,`sr.${e}`),this}rangeGte(n,e){return this.url.searchParams.append(n,`nxl.${e}`),this}rangeLt(n,e){return this.url.searchParams.append(n,`sl.${e}`),this}rangeLte(n,e){return this.url.searchParams.append(n,`nxr.${e}`),this}rangeAdjacent(n,e){return this.url.searchParams.append(n,`adj.${e}`),this}overlaps(n,e){return typeof e=="string"?this.url.searchParams.append(n,`ov.${e}`):this.url.searchParams.append(n,`ov.{${e.join(",")}}`),this}textSearch(n,e,{config:t,type:s}={}){let r="";s==="plain"?r="pl":s==="phrase"?r="ph":s==="websearch"&&(r="w");const i=t===void 0?"":`(${t})`;return this.url.searchParams.append(n,`${r}fts${i}.${e}`),this}match(n){return Object.entries(n).forEach(([e,t])=>{this.url.searchParams.append(e,`eq.${t}`)}),this}not(n,e,t){return this.url.searchParams.append(n,`not.${e}.${t}`),this}or(n,{foreignTable:e,referencedTable:t=e}={}){const s=t?`${t}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,e,t){return this.url.searchParams.append(n,`${e}.${t}`),this}},JG=class{constructor(n,{headers:e={},schema:t,fetch:s}){this.url=n,this.headers=new Headers(e),this.schema=t,this.fetch=s}select(n,e){const{head:t=!1,count:s}=e??{},r=t?"HEAD":"GET";let i=!1;const o=(n??"*").split("").map(l=>/\s/.test(l)&&!i?"":(l==='"'&&(i=!i),l)).join("");return this.url.searchParams.set("select",o),s&&this.headers.append("Prefer",`count=${s}`),new uc({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:e,defaultToNull:t=!0}={}){var s;const r="POST";if(e&&this.headers.append("Prefer",`count=${e}`),t||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const i=n.reduce((o,l)=>o.concat(Object.keys(l)),[]);if(i.length>0){const o=[...new Set(i)].map(l=>`"${l}"`);this.url.searchParams.set("columns",o.join(","))}}return new uc({method:r,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:e,ignoreDuplicates:t=!1,count:s,defaultToNull:r=!0}={}){var i;const o="POST";if(this.headers.append("Prefer",`resolution=${t?"ignore":"merge"}-duplicates`),e!==void 0&&this.url.searchParams.set("on_conflict",e),s&&this.headers.append("Prefer",`count=${s}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const l=n.reduce((c,h)=>c.concat(Object.keys(h)),[]);if(l.length>0){const c=[...new Set(l)].map(h=>`"${h}"`);this.url.searchParams.set("columns",c.join(","))}}return new uc({method:o,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}update(n,{count:e}={}){var t;const s="PATCH";return e&&this.headers.append("Prefer",`count=${e}`),new uc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}delete({count:n}={}){var e;const t="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new uc({method:t,url:this.url,headers:this.headers,schema:this.schema,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}},ZG=class sR{constructor(e,{headers:t={},schema:s,fetch:r}={}){this.url=e,this.headers=new Headers(t),this.schemaName=s,this.fetch=r}from(e){if(!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new JG(new URL(`${this.url}/${e}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(e){return new sR(this.url,{headers:this.headers,schema:e,fetch:this.fetch})}rpc(e,t={},{head:s=!1,get:r=!1,count:i}={}){var o;let l;const c=new URL(`${this.url}/rpc/${e}`);let h;s||r?(l=s?"HEAD":"GET",Object.entries(t).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{c.searchParams.append(p,m)})):(l="POST",h=t);const d=new Headers(this.headers);return i&&d.set("Prefer",`count=${i}`),new uc({method:l,url:c,headers:d,schema:this.schemaName,body:h,fetch:(o=this.fetch)!==null&&o!==void 0?o:fetch})}};class QG{constructor(){}static detectEnvironment(){var e;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((e=navigator.userAgent)===null||e===void 0)&&e.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const t=process.versions;if(t&&t.node){const s=t.node,r=parseInt(s.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const e=this.detectEnvironment();if(e.constructor)return e.constructor;let t=e.error||"WebSocket not supported in this environment.";throw e.workaround&&(t+=`

Suggested solution: ${e.workaround}`),new Error(t)}static createWebSocket(e,t){const s=this.getWebSocketConstructor();return new s(e,t)}static isWebSocketSupported(){try{const e=this.detectEnvironment();return e.type==="native"||e.type==="ws"}catch{return!1}}}const eW="2.89.0",tW=`realtime-js/${eW}`,rR="1.0.0",nW="2.0.0",hI=rR,yv=1e4,sW=1e3,rW=100;var ko;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(ko||(ko={}));var Tn;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(Tn||(Tn={}));var Fr;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(Fr||(Fr={}));var bv;(function(n){n.websocket="websocket"})(bv||(bv={}));var Aa;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(Aa||(Aa={}));class iW{constructor(e){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=e??[]}encode(e,t){if(e.event===this.BROADCAST_EVENT&&!(e.payload instanceof ArrayBuffer)&&typeof e.payload.event=="string")return t(this._binaryEncodeUserBroadcastPush(e));let s=[e.join_ref,e.ref,e.topic,e.event,e.payload];return t(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(e){var t;return this._isArrayBuffer((t=e.payload)===null||t===void 0?void 0:t.payload)?this._encodeBinaryUserBroadcastPush(e):this._encodeJsonUserBroadcastPush(e)}_encodeBinaryUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(e,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:{},o=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(e,this.JSON_ENCODING,o)}_encodeUserBroadcastPush(e,t,s){var r,i;const o=e.topic,l=(r=e.ref)!==null&&r!==void 0?r:"",c=(i=e.join_ref)!==null&&i!==void 0?i:"",h=e.payload.event,d=this.allowedMetadataKeys?this._pick(e.payload,this.allowedMetadataKeys):{},p=Object.keys(d).length===0?"":JSON.stringify(d);if(c.length>255)throw new Error(`joinRef length ${c.length} exceeds maximum of 255`);if(l.length>255)throw new Error(`ref length ${l.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`topic length ${o.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+c.length+l.length+o.length+h.length+p.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,c.length),b.setUint8(x++,l.length),b.setUint8(x++,o.length),b.setUint8(x++,h.length),b.setUint8(x++,p.length),b.setUint8(x++,t),Array.from(c,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(l,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(o,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(h,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(p,S=>b.setUint8(x++,S.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(e,t){if(this._isArrayBuffer(e)){let s=this._binaryDecode(e);return t(s)}if(typeof e=="string"){const s=JSON.parse(e),[r,i,o,l,c]=s;return t({join_ref:r,ref:i,topic:o,event:l,payload:c})}return t({})}_binaryDecode(e){const t=new DataView(e),s=t.getUint8(0),r=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(e,t,r)}_decodeUserBroadcast(e,t,s){const r=t.getUint8(1),i=t.getUint8(2),o=t.getUint8(3),l=t.getUint8(4);let c=this.HEADER_LENGTH+4;const h=s.decode(e.slice(c,c+r));c=c+r;const d=s.decode(e.slice(c,c+i));c=c+i;const p=s.decode(e.slice(c,c+o));c=c+o;const m=e.slice(c,e.byteLength),y=l===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return o>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(e){var t;return e instanceof ArrayBuffer||((t=e?.constructor)===null||t===void 0?void 0:t.name)==="ArrayBuffer"}_pick(e,t){return!e||typeof e!="object"?{}:Object.fromEntries(Object.entries(e).filter(([s])=>t.includes(s)))}}class iR{constructor(e,t){this.callback=e,this.timerCalc=t,this.timer=void 0,this.tries=0,this.callback=e,this.timerCalc=t}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Mt;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Mt||(Mt={}));const dI=(n,e,t={})=>{var s;const r=(s=t.skipTypes)!==null&&s!==void 0?s:[];return e?Object.keys(e).reduce((i,o)=>(i[o]=oW(o,n,e,r),i),{}):{}},oW=(n,e,t,s)=>{const r=e.find(l=>l.name===n),i=r?.type,o=t[n];return i&&!s.includes(i)?oR(i,o):xv(o)},oR=(n,e)=>{if(n.charAt(0)==="_"){const t=n.slice(1,n.length);return uW(e,t)}switch(n){case Mt.bool:return aW(e);case Mt.float4:case Mt.float8:case Mt.int2:case Mt.int4:case Mt.int8:case Mt.numeric:case Mt.oid:return lW(e);case Mt.json:case Mt.jsonb:return cW(e);case Mt.timestamp:return hW(e);case Mt.abstime:case Mt.date:case Mt.daterange:case Mt.int4range:case Mt.int8range:case Mt.money:case Mt.reltime:case Mt.text:case Mt.time:case Mt.timestamptz:case Mt.timetz:case Mt.tsrange:case Mt.tstzrange:return xv(e);default:return xv(e)}},xv=n=>n,aW=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},lW=n=>{if(typeof n=="string"){const e=parseFloat(n);if(!Number.isNaN(e))return e}return n},cW=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},uW=(n,e)=>{if(typeof n!="string")return n;const t=n.length-1,s=n[t];if(n[0]==="{"&&s==="}"){let i;const o=n.slice(1,t);try{i=JSON.parse("["+o+"]")}catch{i=o?o.split(","):[]}return i.map(l=>oR(e,l))}return n},hW=n=>typeof n=="string"?n.replace(" ","T"):n,aR=n=>{const e=new URL(n);return e.protocol=e.protocol.replace(/^ws/i,"http"),e.pathname=e.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),e.pathname===""||e.pathname==="/"?e.pathname="/api/broadcast":e.pathname=e.pathname+"/api/broadcast",e.href};class yx{constructor(e,t,s={},r=yv){this.channel=e,this.event=t,this.payload=s,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(e){this.timeout=e,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(e){this.payload=Object.assign(Object.assign({},this.payload),e)}receive(e,t){var s;return this._hasReceived(e)&&t((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:e,callback:t}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const e=t=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=t,this._matchReceive(t)};this.channel._on(this.refEvent,{},e),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(e,t){this.refEvent&&this.channel._trigger(this.refEvent,{status:e,response:t})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:e,response:t}){this.recHooks.filter(s=>s.status===e).forEach(s=>s.callback(t))}_hasReceived(e){return this.receivedResp&&this.receivedResp.status===e}}var fI;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(fI||(fI={}));class bh{constructor(e,t){this.channel=e,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=t?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},r=>{const{onJoin:i,onLeave:o,onSync:l}=this.caller;this.joinRef=this.channel._joinRef(),this.state=bh.syncState(this.state,r,i,o),this.pendingDiffs.forEach(c=>{this.state=bh.syncDiff(this.state,c,i,o)}),this.pendingDiffs=[],l()}),this.channel._on(s.diff,{},r=>{const{onJoin:i,onLeave:o,onSync:l}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=bh.syncDiff(this.state,r,i,o),l())}),this.onJoin((r,i,o)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:i,newPresences:o})}),this.onLeave((r,i,o)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:i,leftPresences:o})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(e,t,s,r){const i=this.cloneDeep(e),o=this.transformState(t),l={},c={};return this.map(i,(h,d)=>{o[h]||(c[h]=d)}),this.map(o,(h,d)=>{const p=i[h];if(p){const m=d.map(w=>w.presence_ref),y=p.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=p.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(l[h]=b),x.length>0&&(c[h]=x)}else l[h]=d}),this.syncDiff(i,{joins:l,leaves:c},s,r)}static syncDiff(e,t,s,r){const{joins:i,leaves:o}={joins:this.transformState(t.joins),leaves:this.transformState(t.leaves)};return s||(s=()=>{}),r||(r=()=>{}),this.map(i,(l,c)=>{var h;const d=(h=e[l])!==null&&h!==void 0?h:[];if(e[l]=this.cloneDeep(c),d.length>0){const p=e[l].map(y=>y.presence_ref),m=d.filter(y=>p.indexOf(y.presence_ref)<0);e[l].unshift(...m)}s(l,d,c)}),this.map(o,(l,c)=>{let h=e[l];if(!h)return;const d=c.map(p=>p.presence_ref);h=h.filter(p=>d.indexOf(p.presence_ref)<0),e[l]=h,r(l,h,c),h.length===0&&delete e[l]}),e}static map(e,t){return Object.getOwnPropertyNames(e).map(s=>t(s,e[s]))}static transformState(e){return e=this.cloneDeep(e),Object.getOwnPropertyNames(e).reduce((t,s)=>{const r=e[s];return"metas"in r?t[s]=r.metas.map(i=>(i.presence_ref=i.phx_ref,delete i.phx_ref,delete i.phx_ref_prev,i)):t[s]=r,t},{})}static cloneDeep(e){return JSON.parse(JSON.stringify(e))}onJoin(e){this.caller.onJoin=e}onLeave(e){this.caller.onLeave=e}onSync(e){this.caller.onSync=e}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var pI;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(pI||(pI={}));var xh;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(xh||(xh={}));var Pi;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(Pi||(Pi={}));class wc{constructor(e,t={config:{}},s){var r,i;if(this.topic=e,this.params=t,this.socket=s,this.bindings={},this.state=Tn.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=e.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},t.config),this.timeout=this.socket.timeout,this.joinPush=new yx(this,Fr.join,this.params,this.timeout),this.rejoinTimer=new iR(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Tn.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=Tn.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=Tn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Tn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=Tn.errored,this.rejoinTimer.scheduleTimeout())}),this._on(Fr.reply,{},(o,l)=>{this._trigger(this._replyEventName(l),o)}),this.presence=new bh(this),this.broadcastEndpointURL=aR(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((i=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||i===void 0)&&i.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(e,t=this.timeout){var s,r,i;if(this.socket.isConnected()||this.socket.connect(),this.state==Tn.closed){const{config:{broadcast:o,presence:l,private:c}}=this.params,h=(r=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&r!==void 0?r:[],d=!!this.bindings[xh.PRESENCE]&&this.bindings[xh.PRESENCE].length>0||((i=this.params.config.presence)===null||i===void 0?void 0:i.enabled)===!0,p={},m={broadcast:o,presence:Object.assign(Object.assign({},l),{enabled:d}),postgres_changes:h,private:c};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(y=>e?.(Pi.CHANNEL_ERROR,y)),this._onClose(()=>e?.(Pi.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){e?.(Pi.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,S=[];for(let T=0;T<w;T++){const k=x[T],{filter:{event:$,schema:E,table:N,filter:_}}=k,R=y&&y[T];if(R&&R.event===$&&wc.isFilterValueEqual(R.schema,E)&&wc.isFilterValueEqual(R.table,N)&&wc.isFilterValueEqual(R.filter,_))S.push(Object.assign(Object.assign({},k),{id:R.id}));else{this.unsubscribe(),this.state=Tn.errored,e?.(Pi.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=S,e&&e(Pi.SUBSCRIBED);return}}).receive("error",y=>{this.state=Tn.errored,e?.(Pi.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{e?.(Pi.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(e,t={}){return await this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)}async untrack(e={}){return await this.send({type:"presence",event:"untrack"},e)}on(e,t,s){return this.state===Tn.joined&&e===xh.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(e,t,s)}async httpSend(e,t,s={}){var r;if(t==null)return Promise.reject("Payload is required for httpSend()");const i={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(i.Authorization=`Bearer ${this.socket.accessTokenValue}`);const o={method:"POST",headers:i,body:JSON.stringify({messages:[{topic:this.subTopic,event:e,payload:t,private:this.private}]})},l=await this._fetchWithTimeout(this.broadcastEndpointURL,o,(r=s.timeout)!==null&&r!==void 0?r:this.timeout);if(l.status===202)return{success:!0};let c=l.statusText;try{const h=await l.json();c=h.error||h.message||c}catch{}return Promise.reject(new Error(c))}async send(e,t={}){var s,r;if(!this._canPush()&&e.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:i,payload:o}=e,l={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(l.Authorization=`Bearer ${this.socket.accessTokenValue}`);const c={method:"POST",headers:l,body:JSON.stringify({messages:[{topic:this.subTopic,event:i,payload:o,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,c,(s=t.timeout)!==null&&s!==void 0?s:this.timeout);return await((r=h.body)===null||r===void 0?void 0:r.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(i=>{var o,l,c;const h=this._push(e.type,e,t.timeout||this.timeout);e.type==="broadcast"&&!(!((c=(l=(o=this.params)===null||o===void 0?void 0:o.config)===null||l===void 0?void 0:l.broadcast)===null||c===void 0)&&c.ack)&&i("ok"),h.receive("ok",()=>i("ok")),h.receive("error",()=>i("error")),h.receive("timeout",()=>i("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=Tn.leaving;const t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(Fr.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(r=>{s=new yx(this,Fr.leave,{},e),s.receive("ok",()=>{t(),r("ok")}).receive("timeout",()=>{t(),r("timed out")}).receive("error",()=>{r("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(e=>e.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=Tn.closed,this.bindings={}}async _fetchWithTimeout(e,t,s){const r=new AbortController,i=setTimeout(()=>r.abort(),s),o=await this.socket.fetch(e,Object.assign(Object.assign({},t),{signal:r.signal}));return clearTimeout(i),o}_push(e,t,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new yx(this,e,t,s);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(e){if(e.startTimeout(),this.pushBuffer.push(e),this.pushBuffer.length>rW){const t=this.pushBuffer.shift();t&&(t.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${t.event}`,t.payload))}}_onMessage(e,t,s){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,s){var r,i;const o=e.toLocaleLowerCase(),{close:l,error:c,leave:h,join:d}=Fr;if(s&&[l,c,h,d].indexOf(o)>=0&&s!==this._joinRef())return;let m=this._onMessage(o,t,s);if(t&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===o}).map(y=>y.callback(m,s)):(i=this.bindings[o])===null||i===void 0||i.filter(y=>{var b,x,w,S,T,k;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in y){const $=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return $&&((x=t.ids)===null||x===void 0?void 0:x.includes($))&&(E==="*"||E?.toLocaleLowerCase()===((w=t.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const $=(T=(S=y?.filter)===null||S===void 0?void 0:S.event)===null||T===void 0?void 0:T.toLocaleLowerCase();return $==="*"||$===((k=t?.event)===null||k===void 0?void 0:k.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===o}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:S,type:T,errors:k}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:S,eventType:T,new:{},old:{},errors:k}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===Tn.closed}_isJoined(){return this.state===Tn.joined}_isJoining(){return this.state===Tn.joining}_isLeaving(){return this.state===Tn.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,s){const r=e.toLocaleLowerCase(),i={type:r,filter:t,callback:s};return this.bindings[r]?this.bindings[r].push(i):this.bindings[r]=[i],this}_off(e,t){const s=e.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(r=>{var i;return!(((i=r.type)===null||i===void 0?void 0:i.toLocaleLowerCase())===s&&wc.isEqual(r.filter,t))})),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const s in e)if(e[s]!==t[s])return!1;return!0}static isFilterValueEqual(e,t){return(e??void 0)===(t??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(Fr.close,{},e)}_onError(e){this._on(Fr.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=Tn.joining,this.joinPush.resend(e))}_getPayloadRecords(e){const t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=dI(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=dI(e.columns,e.old_record)),t}}const bx=()=>{},Vp={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},dW=[1e3,2e3,5e3,1e4],fW=1e4,pW=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class mW{constructor(e,t){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=yv,this.transport=null,this.heartbeatIntervalMs=Vp.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=bx,this.ref=0,this.reconnectTimer=null,this.vsn=hI,this.logger=bx,this.conn=null,this.sendBuffer=[],this.serializer=new iW,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...i)=>r(...i):(...i)=>fetch(...i),!(!((s=t?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=t.params.apikey,this.endPoint=`${e}/${bv.websocket}`,this.httpEndpoint=aR(e),this._initializeOptions(t),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(t?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=QG.createWebSocket(this.endpointURL())}catch(e){this._setConnectionState("disconnected");const t=e.message;throw t.includes("Node.js")?new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${t}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(e,t){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(e?this.conn.close(e,t??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,s){this.logger(e,t,s)}connectionState(){switch(this.conn&&this.conn.readyState){case ko.connecting:return Aa.Connecting;case ko.open:return Aa.Open;case ko.closing:return Aa.Closing;default:return Aa.Closed}}isConnected(){return this.connectionState()===Aa.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(e,t={config:{}}){const s=`realtime:${e}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new wc(`realtime:${e}`,t,this);return this.channels.push(i),i}}push(e){const{topic:t,event:s,payload:r,ref:i}=e,o=()=>{this.encode(e,l=>{var c;(c=this.conn)===null||c===void 0||c.send(l)})};this.log("push",`${t} ${s} (${i})`,r),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(e=null){this._authPromise=this._performAuth(e);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var e;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(t){this.log("error","error in heartbeat callback",t)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(t){this.log("error","error in heartbeat callback",t)}this._wasManualDisconnect=!1,(e=this.conn)===null||e===void 0||e.close(sW,"heartbeat timeout"),setTimeout(()=>{var t;this.isConnected()||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout()},Vp.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(t){this.log("error","error in heartbeat callback",t)}this._setAuthSafely("heartbeat")}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(s=>s.topic===e&&(s._isJoined()||s._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}_onConnMessage(e){this.decode(e.data,t=>{if(t.topic==="phoenix"&&t.event==="phx_reply")try{this.heartbeatCallback(t.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}t.ref&&t.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:r,payload:i,ref:o}=t,l=o?`(${o})`:"",c=i.status||"";this.log("receive",`${c} ${s} ${r} ${l}`.trim(),i),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(r,i,o)),this._triggerStateCallbacks("message",t)})}_clearTimer(e){var t;e==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):e==="reconnect"&&((t=this.reconnectTimer)===null||t===void 0||t.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e),this.conn.readyState===ko.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===ko.open||this.conn.readyState===ko.connecting)try{this.conn.close()}catch(e){this.log("error","Error closing connection",e)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(e=>e.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(t=>{this.log("error","error waiting for auth on connect",t),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this._terminateWorker()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(e){var t;this._setConnectionState("disconnected"),this.log("transport","close",e),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout(),this._triggerStateCallbacks("close",e)}_onConnError(e){this._setConnectionState("disconnected"),this.log("transport",`${e}`),this._triggerChanError(),this._triggerStateCallbacks("error",e)}_triggerChanError(){this.channels.forEach(e=>e._trigger(Fr.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const s=e.match(/\?/)?"&":"?",r=new URLSearchParams(t);return`${e}${s}${r}`}_workerObjectUrl(e){let t;if(e)t=e;else{const s=new Blob([pW],{type:"application/javascript"});t=URL.createObjectURL(s)}return t}_setConnectionState(e,t=!1){this._connectionState=e,e==="connecting"?this._wasManualDisconnect=!1:e==="disconnecting"&&(this._wasManualDisconnect=t)}async _performAuth(e=null){let t,s=!1;if(e)t=e,s=!0;else if(this.accessToken)try{t=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),t=this.accessTokenValue}else t=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(r=>{const i={access_token:t,version:tW};t&&r.updateJoinPayload(i),r.joinedOnce&&r._isJoined()&&r._push(Fr.access_token,{access_token:t})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(e="general"){this._isManualToken()||this.setAuth().catch(t=>{this.log("error",`Error setting auth in ${e}`,t)})}_triggerStateCallbacks(e,t){try{this.stateChangeCallbacks[e].forEach(s=>{try{s(t)}catch(r){this.log("error",`error in ${e} callback`,r)}})}catch(s){this.log("error",`error triggering ${e} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new iR(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},Vp.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(e){var t,s,r,i,o,l,c,h,d,p,m,y;switch(this.transport=(t=e?.transport)!==null&&t!==void 0?t:null,this.timeout=(s=e?.timeout)!==null&&s!==void 0?s:yv,this.heartbeatIntervalMs=(r=e?.heartbeatIntervalMs)!==null&&r!==void 0?r:Vp.HEARTBEAT_INTERVAL,this.worker=(i=e?.worker)!==null&&i!==void 0?i:!1,this.accessToken=(o=e?.accessToken)!==null&&o!==void 0?o:null,this.heartbeatCallback=(l=e?.heartbeatCallback)!==null&&l!==void 0?l:bx,this.vsn=(c=e?.vsn)!==null&&c!==void 0?c:hI,e?.params&&(this.params=e.params),e?.logger&&(this.logger=e.logger),(e?.logLevel||e?.log_level)&&(this.logLevel=e.logLevel||e.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=e?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>dW[b-1]||fW),this.vsn){case rR:this.encode=(d=e?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(p=e?.decode)!==null&&p!==void 0?p:((b,x)=>x(JSON.parse(b)));break;case nW:this.encode=(m=e?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=e?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=e?.workerUrl}}}var Ah=class extends Error{constructor(n,e){super(n),this.name="IcebergError",this.status=e.status,this.icebergType=e.icebergType,this.icebergCode=e.icebergCode,this.details=e.details,this.isCommitStateUnknown=e.icebergType==="CommitStateUnknownException"||[500,502,504].includes(e.status)&&e.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function gW(n,e,t){const s=new URL(e,n);if(t)for(const[r,i]of Object.entries(t))i!==void 0&&s.searchParams.set(r,i);return s.toString()}async function yW(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function bW(n){const e=n.fetchImpl??globalThis.fetch;return{async request({method:t,path:s,query:r,body:i,headers:o}){const l=gW(n.baseUrl,s,r),c=await yW(n.auth),h=await e(l,{method:t,headers:{...i?{"Content-Type":"application/json"}:{},...c,...o},body:i?JSON.stringify(i):void 0}),d=await h.text(),p=(h.headers.get("content-type")||"").includes("application/json"),m=p&&d?JSON.parse(d):d;if(!h.ok){const y=p?m:void 0,b=y?.error;throw new Ah(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function Up(n){return n.join("")}var xW=class{constructor(n,e=""){this.client=n,this.prefix=e}async listNamespaces(n){const e=n?{parent:Up(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:e})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,e){const t={namespace:n.namespace,properties:e?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:t})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${Up(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${Up(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${Up(n.namespace)}`}),!0}catch(e){if(e instanceof Ah&&e.status===404)return!1;throw e}}async createNamespaceIfNotExists(n,e){try{return await this.createNamespace(n,e)}catch(t){if(t instanceof Ah&&t.status===409)return;throw t}}};function tc(n){return n.join("")}var vW=class{constructor(n,e="",t){this.client=n,this.prefix=e,this.accessDelegation=t}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${tc(n.namespace)}/tables`})).data.identifiers}async createTable(n,e){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${tc(n.namespace)}/tables`,body:e,headers:t})).data.metadata}async updateTable(n,e){const t=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${tc(n.namespace)}/tables/${n.name}`,body:e});return{"metadata-location":t.data["metadata-location"],metadata:t.data.metadata}}async dropTable(n,e){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${tc(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(e?.purge??!1)}})}async loadTable(n){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${tc(n.namespace)}/tables/${n.name}`,headers:e})).data.metadata}async tableExists(n){const e={};this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${tc(n.namespace)}/tables/${n.name}`,headers:e}),!0}catch(t){if(t instanceof Ah&&t.status===404)return!1;throw t}}async createTableIfNotExists(n,e){try{return await this.createTable(n,e)}catch(t){if(t instanceof Ah&&t.status===409)return await this.loadTable({namespace:n.namespace,name:e.name});throw t}}},wW=class{constructor(n){let e="v1";n.catalogName&&(e+=`/${n.catalogName}`);const t=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=bW({baseUrl:t,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new xW(this.client,e),this.tableOps=new vW(this.client,e,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,e){return this.namespaceOps.createNamespace(n,e)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,e){return this.tableOps.createTable(n,e)}async updateTable(n,e){return this.tableOps.updateTable(n,e)}async dropTable(n,e){await this.tableOps.dropTable(n,e)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,e){return this.namespaceOps.createNamespaceIfNotExists(n,e)}async createTableIfNotExists(n,e){return this.tableOps.createTableIfNotExists(n,e)}},ag=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function Ht(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var SW=class extends ag{constructor(n,e,t){super(n),this.name="StorageApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},vv=class extends ag{constructor(n,e){super(n),this.name="StorageUnknownError",this.originalError=e}};const Kw=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),CW=()=>Response,wv=n=>{if(Array.isArray(n))return n.map(t=>wv(t));if(typeof n=="function"||n!==Object(n))return n;const e={};return Object.entries(n).forEach(([t,s])=>{const r=t.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));e[r]=wv(s)}),e},TW=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},kW=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function _h(n){"@babel/helpers - typeof";return _h=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_h(n)}function $W(n,e){if(_h(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(_h(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function EW(n){var e=$W(n,"string");return _h(e)=="symbol"?e:e+""}function IW(n,e,t){return(e=EW(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function mI(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function je(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?mI(Object(t),!0).forEach(function(s){IW(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):mI(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const xx=n=>{var e;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(e=n.error)===null||e===void 0?void 0:e.message)||JSON.stringify(n)},NW=async(n,e,t)=>{n instanceof await CW()&&!t?.noResolveJson?n.json().then(s=>{const r=n.status||500,i=s?.statusCode||r+"";e(new SW(xx(s),r,i))}).catch(s=>{e(new vv(xx(s),s))}):e(new vv(xx(n),n))},AW=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"||!s?r:(TW(s)?(r.headers=je({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,e?.duplex&&(r.duplex=e.duplex),je(je({},r),t))};async function Qh(n,e,t,s,r,i){return new Promise((o,l)=>{n(t,AW(e,s,r,i)).then(c=>{if(!c.ok)throw c;return s?.noResolveJson?c:c.json()}).then(c=>o(c)).catch(c=>NW(c,l,s))})}async function Rh(n,e,t,s){return Qh(n,"GET",e,t,s)}async function Mr(n,e,t,s,r){return Qh(n,"POST",e,s,r,t)}async function Sv(n,e,t,s,r){return Qh(n,"PUT",e,s,r,t)}async function _W(n,e,t,s){return Qh(n,"HEAD",e,je(je({},t),{},{noResolveJson:!0}),s)}async function Xw(n,e,t,s,r){return Qh(n,"DELETE",e,s,r,t)}var RW=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e}then(n,e){return this.execute().then(n,e)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Ht(e))return{data:null,error:e};throw e}}};let lR;lR=Symbol.toStringTag;var DW=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e,this[lR]="BlobDownloadBuilder",this.promise=null}asStream(){return new RW(this.downloadFn,this.shouldThrowOnError)}then(n,e){return this.getPromise().then(n,e)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Ht(e))return{data:null,error:e};throw e}}};const OW={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},gI={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var MW=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1,this.url=n,this.headers=e,this.bucketId=t,this.fetch=Kw(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,e,t,s){var r=this;try{let i;const o=je(je({},gI),s);let l=je(je({},r.headers),n==="POST"&&{"x-upsert":String(o.upsert)});const c=o.metadata;typeof Blob<"u"&&t instanceof Blob?(i=new FormData,i.append("cacheControl",o.cacheControl),c&&i.append("metadata",r.encodeMetadata(c)),i.append("",t)):typeof FormData<"u"&&t instanceof FormData?(i=t,i.has("cacheControl")||i.append("cacheControl",o.cacheControl),c&&!i.has("metadata")&&i.append("metadata",r.encodeMetadata(c))):(i=t,l["cache-control"]=`max-age=${o.cacheControl}`,l["content-type"]=o.contentType,c&&(l["x-metadata"]=r.toBase64(r.encodeMetadata(c))),(typeof ReadableStream<"u"&&i instanceof ReadableStream||i&&typeof i=="object"&&"pipe"in i&&typeof i.pipe=="function")&&!o.duplex&&(o.duplex="half")),s?.headers&&(l=je(je({},l),s.headers));const h=r._removeEmptyFolders(e),d=r._getFinalPath(h),p=await(n=="PUT"?Sv:Mr)(r.fetch,`${r.url}/object/${d}`,i,je({headers:l},o?.duplex?{duplex:o.duplex}:{}));return{data:{path:h,id:p.Id,fullPath:p.Key},error:null}}catch(i){if(r.shouldThrowOnError)throw i;if(Ht(i))return{data:null,error:i};throw i}}async upload(n,e,t){return this.uploadOrUpdate("POST",n,e,t)}async uploadToSignedUrl(n,e,t,s){var r=this;const i=r._removeEmptyFolders(n),o=r._getFinalPath(i),l=new URL(r.url+`/object/upload/sign/${o}`);l.searchParams.set("token",e);try{let c;const h=je({upsert:gI.upsert},s),d=je(je({},r.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&t instanceof Blob?(c=new FormData,c.append("cacheControl",h.cacheControl),c.append("",t)):typeof FormData<"u"&&t instanceof FormData?(c=t,c.append("cacheControl",h.cacheControl)):(c=t,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:i,fullPath:(await Sv(r.fetch,l.toString(),c,{headers:d})).Key},error:null}}catch(c){if(r.shouldThrowOnError)throw c;if(Ht(c))return{data:null,error:c};throw c}}async createSignedUploadUrl(n,e){var t=this;try{let s=t._getFinalPath(n);const r=je({},t.headers);e?.upsert&&(r["x-upsert"]="true");const i=await Mr(t.fetch,`${t.url}/object/upload/sign/${s}`,{},{headers:r}),o=new URL(t.url+i.url),l=o.searchParams.get("token");if(!l)throw new ag("No token returned by API");return{data:{signedUrl:o.toString(),path:n,token:l},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ht(s))return{data:null,error:s};throw s}}async update(n,e,t){return this.uploadOrUpdate("PUT",n,e,t)}async move(n,e,t){var s=this;try{return{data:await Mr(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers}),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ht(r))return{data:null,error:r};throw r}}async copy(n,e,t){var s=this;try{return{data:{path:(await Mr(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ht(r))return{data:null,error:r};throw r}}async createSignedUrl(n,e,t){var s=this;try{let r=s._getFinalPath(n),i=await Mr(s.fetch,`${s.url}/object/sign/${r}`,je({expiresIn:e},t?.transform?{transform:t.transform}:{}),{headers:s.headers});const o=t?.download?`&download=${t.download===!0?"":t.download}`:"";return i={signedUrl:encodeURI(`${s.url}${i.signedURL}${o}`)},{data:i,error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ht(r))return{data:null,error:r};throw r}}async createSignedUrls(n,e,t){var s=this;try{const r=await Mr(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:e,paths:n},{headers:s.headers}),i=t?.download?`&download=${t.download===!0?"":t.download}`:"";return{data:r.map(o=>je(je({},o),{},{signedUrl:o.signedURL?encodeURI(`${s.url}${o.signedURL}${i}`):null})),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ht(r))return{data:null,error:r};throw r}}download(n,e){const t=typeof e?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(e?.transform||{}),r=s?`?${s}`:"",i=this._getFinalPath(n),o=()=>Rh(this.fetch,`${this.url}/${t}/${i}${r}`,{headers:this.headers,noResolveJson:!0});return new DW(o,this.shouldThrowOnError)}async info(n){var e=this;const t=e._getFinalPath(n);try{return{data:wv(await Rh(e.fetch,`${e.url}/object/info/${t}`,{headers:e.headers})),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ht(s))return{data:null,error:s};throw s}}async exists(n){var e=this;const t=e._getFinalPath(n);try{return await _W(e.fetch,`${e.url}/object/${t}`,{headers:e.headers}),{data:!0,error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ht(s)&&s instanceof vv){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,e){const t=this._getFinalPath(n),s=[],r=e?.download?`download=${e.download===!0?"":e.download}`:"";r!==""&&s.push(r);const i=typeof e?.transform<"u"?"render/image":"object",o=this.transformOptsToQueryString(e?.transform||{});o!==""&&s.push(o);let l=s.join("&");return l!==""&&(l=`?${l}`),{data:{publicUrl:encodeURI(`${this.url}/${i}/public/${t}${l}`)}}}async remove(n){var e=this;try{return{data:await Xw(e.fetch,`${e.url}/object/${e.bucketId}`,{prefixes:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}async list(n,e,t){var s=this;try{const r=je(je(je({},OW),e),{},{prefix:n||""});return{data:await Mr(s.fetch,`${s.url}/object/list/${s.bucketId}`,r,{headers:s.headers},t),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ht(r))return{data:null,error:r};throw r}}async listV2(n,e){var t=this;try{const s=je({},n);return{data:await Mr(t.fetch,`${t.url}/object/list-v2/${t.bucketId}`,s,{headers:t.headers},e),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ht(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const e=[];return n.width&&e.push(`width=${n.width}`),n.height&&e.push(`height=${n.height}`),n.resize&&e.push(`resize=${n.resize}`),n.format&&e.push(`format=${n.format}`),n.quality&&e.push(`quality=${n.quality}`),e.join("&")}};const cR="2.89.0",uR={"X-Client-Info":`storage-js/${cR}`};var FW=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1;const r=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=je(je({},uR),e),this.fetch=Kw(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var e=this;try{const t=e.listBucketOptionsToQueryString(n);return{data:await Rh(e.fetch,`${e.url}/bucket${t}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await Rh(e.fetch,`${e.url}/bucket/${n}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}async createBucket(n,e={public:!1}){var t=this;try{return{data:await Mr(t.fetch,`${t.url}/bucket`,{id:n,name:n,type:e.type,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ht(s))return{data:null,error:s};throw s}}async updateBucket(n,e){var t=this;try{return{data:await Sv(t.fetch,`${t.url}/bucket/${n}`,{id:n,name:n,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ht(s))return{data:null,error:s};throw s}}async emptyBucket(n){var e=this;try{return{data:await Mr(e.fetch,`${e.url}/bucket/${n}/empty`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await Xw(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}listBucketOptionsToQueryString(n){const e={};return n&&("limit"in n&&(e.limit=String(n.limit)),"offset"in n&&(e.offset=String(n.offset)),n.search&&(e.search=n.search),n.sortColumn&&(e.sortColumn=n.sortColumn),n.sortOrder&&(e.sortOrder=n.sortOrder)),Object.keys(e).length>0?"?"+new URLSearchParams(e).toString():""}},LW=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=je(je({},uR),e),this.fetch=Kw(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await Mr(e.fetch,`${e.url}/bucket`,{name:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}async listBuckets(n){var e=this;try{const t=new URLSearchParams;n?.limit!==void 0&&t.set("limit",n.limit.toString()),n?.offset!==void 0&&t.set("offset",n.offset.toString()),n?.sortColumn&&t.set("sortColumn",n.sortColumn),n?.sortOrder&&t.set("sortOrder",n.sortOrder),n?.search&&t.set("search",n.search);const s=t.toString(),r=s?`${e.url}/bucket?${s}`:`${e.url}/bucket`;return{data:await Rh(e.fetch,r,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await Xw(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Ht(t))return{data:null,error:t};throw t}}from(n){var e=this;if(!kW(n))throw new ag("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const t=new wW({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>e.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(t,{get(r,i){const o=r[i];return typeof o!="function"?o:async(...l)=>{try{return{data:await o.apply(r,l),error:null}}catch(c){if(s)throw c;return{data:null,error:c}}}}})}};const Yw={"X-Client-Info":`storage-js/${cR}`,"Content-Type":"application/json"};var hR=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function Gs(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var vx=class extends hR{constructor(n,e,t){super(n),this.name="StorageVectorsApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},PW=class extends hR{constructor(n,e){super(n),this.name="StorageVectorsUnknownError",this.originalError=e}};const Jw=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),zW=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},yI=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),BW=async(n,e,t)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!t?.noResolveJson){const s=n.status||500,r=n;if(typeof r.json=="function")r.json().then(i=>{const o=i?.statusCode||i?.code||s+"";e(new vx(yI(i),s,o))}).catch(()=>{const i=s+"";e(new vx(r.statusText||`HTTP ${s} error`,s,i))});else{const i=s+"";e(new vx(r.statusText||`HTTP ${s} error`,s,i))}}else e(new PW(yI(n),n))},VW=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return s?(zW(s)?(r.headers=je({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,je(je({},r),t)):r};async function UW(n,e,t,s,r,i){return new Promise((o,l)=>{n(t,VW(e,s,r,i)).then(c=>{if(!c.ok)throw c;if(s?.noResolveJson)return c;const h=c.headers.get("content-type");return!h||!h.includes("application/json")?{}:c.json()}).then(c=>o(c)).catch(c=>BW(c,l,s))})}async function Ws(n,e,t,s,r){return UW(n,"POST",e,s,r,t)}var jW=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=je(je({},Yw),e),this.fetch=Jw(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/CreateIndex`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async getIndex(n,e){var t=this;try{return{data:await Ws(t.fetch,`${t.url}/GetIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Gs(s))return{data:null,error:s};throw s}}async listIndexes(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/ListIndexes`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async deleteIndex(n,e){var t=this;try{return{data:await Ws(t.fetch,`${t.url}/DeleteIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers})||{},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Gs(s))return{data:null,error:s};throw s}}},GW=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=je(je({},Yw),e),this.fetch=Jw(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var e=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await Ws(e.fetch,`${e.url}/PutVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async getVectors(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/GetVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async listVectors(n){var e=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await Ws(e.fetch,`${e.url}/ListVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async queryVectors(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/QueryVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async deleteVectors(n){var e=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await Ws(e.fetch,`${e.url}/DeleteVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}},WW=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=je(je({},Yw),e),this.fetch=Jw(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/GetVectorBucket`,{vectorBucketName:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async listBuckets(n={}){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/ListVectorBuckets`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await Ws(e.fetch,`${e.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Gs(t))return{data:null,error:t};throw t}}},HW=class extends WW{constructor(n,e={}){super(n,e.headers||{},e.fetch)}from(n){return new qW(this.url,this.headers,n,this.fetch)}async createBucket(n){var e=()=>super.createBucket,t=this;return e().call(t,n)}async getBucket(n){var e=()=>super.getBucket,t=this;return e().call(t,n)}async listBuckets(n={}){var e=()=>super.listBuckets,t=this;return e().call(t,n)}async deleteBucket(n){var e=()=>super.deleteBucket,t=this;return e().call(t,n)}},qW=class extends jW{constructor(n,e,t,s){super(n,e,s),this.vectorBucketName=t}async createIndex(n){var e=()=>super.createIndex,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName}))}async listIndexes(n={}){var e=()=>super.listIndexes,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName}))}async getIndex(n){var e=()=>super.getIndex,t=this;return e().call(t,t.vectorBucketName,n)}async deleteIndex(n){var e=()=>super.deleteIndex,t=this;return e().call(t,t.vectorBucketName,n)}index(n){return new KW(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},KW=class extends GW{constructor(n,e,t,s,r){super(n,e,r),this.vectorBucketName=t,this.indexName=s}async putVectors(n){var e=()=>super.putVectors,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async getVectors(n){var e=()=>super.getVectors,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async listVectors(n={}){var e=()=>super.listVectors,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async queryVectors(n){var e=()=>super.queryVectors,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async deleteVectors(n){var e=()=>super.deleteVectors,t=this;return e().call(t,je(je({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}},XW=class extends FW{constructor(n,e={},t,s){super(n,e,t,s)}from(n){return new MW(this.url,this.headers,n,this.fetch)}get vectors(){return new HW(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new LW(this.url+"/iceberg",this.headers,this.fetch)}};const dR="2.89.0",hc=30*1e3,Cv=3,wx=Cv*hc,YW="http://localhost:9999",JW="supabase.auth.token",ZW={"X-Client-Info":`gotrue-js/${dR}`},Tv="X-Supabase-Api-Version",fR={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},QW=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,eH=600*1e3;class Dh extends Error{constructor(e,t,s){super(e),this.__isAuthError=!0,this.name="AuthError",this.status=t,this.code=s}}function De(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class tH extends Dh{constructor(e,t,s){super(e,t,s),this.name="AuthApiError",this.status=t,this.code=s}}function nH(n){return De(n)&&n.name==="AuthApiError"}class _a extends Dh{constructor(e,t){super(e),this.name="AuthUnknownError",this.originalError=t}}class Ki extends Dh{constructor(e,t,s,r){super(e,s,r),this.name=t,this.status=s}}class js extends Ki{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function sH(n){return De(n)&&n.name==="AuthSessionMissingError"}class nc extends Ki{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class jp extends Ki{constructor(e){super(e,"AuthInvalidCredentialsError",400,void 0)}}class Gp extends Ki{constructor(e,t=null){super(e,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function rH(n){return De(n)&&n.name==="AuthImplicitGrantRedirectError"}class bI extends Ki{constructor(e,t=null){super(e,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class iH extends Ki{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class kv extends Ki{constructor(e,t){super(e,"AuthRetryableFetchError",t,void 0)}}function Sx(n){return De(n)&&n.name==="AuthRetryableFetchError"}class xI extends Ki{constructor(e,t,s){super(e,"AuthWeakPasswordError",t,"weak_password"),this.reasons=s}}class $v extends Ki{constructor(e){super(e,"AuthInvalidJwtError",400,"invalid_jwt")}}const Cm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),vI=` 	
\r=`.split(""),oH=(()=>{const n=new Array(128);for(let e=0;e<n.length;e+=1)n[e]=-1;for(let e=0;e<vI.length;e+=1)n[vI[e].charCodeAt(0)]=-2;for(let e=0;e<Cm.length;e+=1)n[Cm[e].charCodeAt(0)]=e;return n})();function wI(n,e,t){if(n!==null)for(e.queue=e.queue<<8|n,e.queuedBits+=8;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(Cm[s]),e.queuedBits-=6}else if(e.queuedBits>0)for(e.queue=e.queue<<6-e.queuedBits,e.queuedBits=6;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(Cm[s]),e.queuedBits-=6}}function pR(n,e,t){const s=oH[n];if(s>-1)for(e.queue=e.queue<<6|s,e.queuedBits+=6;e.queuedBits>=8;)t(e.queue>>e.queuedBits-8&255),e.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function SI(n){const e=[],t=o=>{e.push(String.fromCodePoint(o))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=o=>{cH(o,s,t)};for(let o=0;o<n.length;o+=1)pR(n.charCodeAt(o),r,i);return e.join("")}function aH(n,e){if(n<=127){e(n);return}else if(n<=2047){e(192|n>>6),e(128|n&63);return}else if(n<=65535){e(224|n>>12),e(128|n>>6&63),e(128|n&63);return}else if(n<=1114111){e(240|n>>18),e(128|n>>12&63),e(128|n>>6&63),e(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function lH(n,e){for(let t=0;t<n.length;t+=1){let s=n.charCodeAt(t);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(t+1)-56320&65535|r)+65536,t+=1}aH(s,e)}}function cH(n,e,t){if(e.utf8seq===0){if(n<=127){t(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){e.utf8seq=s;break}if(e.utf8seq===2)e.codepoint=n&31;else if(e.utf8seq===3)e.codepoint=n&15;else if(e.utf8seq===4)e.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");e.utf8seq-=1}else if(e.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");e.codepoint=e.codepoint<<6|n&63,e.utf8seq-=1,e.utf8seq===0&&t(e.codepoint)}}function Cc(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};for(let r=0;r<n.length;r+=1)pR(n.charCodeAt(r),t,s);return new Uint8Array(e)}function uH(n){const e=[];return lH(n,t=>e.push(t)),new Uint8Array(e)}function La(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};return n.forEach(r=>wI(r,t,s)),wI(null,t,s),e.join("")}function hH(n){return Math.round(Date.now()/1e3)+n}function dH(){return Symbol("auth-callback")}const Gn=()=>typeof window<"u"&&typeof document<"u",Sa={tested:!1,writable:!1},mR=()=>{if(!Gn())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(Sa.tested)return Sa.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),Sa.tested=!0,Sa.writable=!0}catch{Sa.tested=!0,Sa.writable=!1}return Sa.writable};function fH(n){const e={},t=new URL(n);if(t.hash&&t.hash[0]==="#")try{new URLSearchParams(t.hash.substring(1)).forEach((r,i)=>{e[i]=r})}catch{}return t.searchParams.forEach((s,r)=>{e[r]=s}),e}const gR=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),pH=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",dc=async(n,e,t)=>{await n.setItem(e,JSON.stringify(t))},Ca=async(n,e)=>{const t=await n.getItem(e);if(!t)return null;try{return JSON.parse(t)}catch{return t}},jn=async(n,e)=>{await n.removeItem(e)};class lg{constructor(){this.promise=new lg.promiseConstructor((e,t)=>{this.resolve=e,this.reject=t})}}lg.promiseConstructor=Promise;function Cx(n){const e=n.split(".");if(e.length!==3)throw new $v("Invalid JWT structure");for(let s=0;s<e.length;s++)if(!QW.test(e[s]))throw new $v("JWT not in base64url format");return{header:JSON.parse(SI(e[0])),payload:JSON.parse(SI(e[1])),signature:Cc(e[2]),raw:{header:e[0],payload:e[1]}}}async function mH(n){return await new Promise(e=>{setTimeout(()=>e(null),n)})}function gH(n,e){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const o=await n(i);if(!e(i,null,o)){s(o);return}}catch(o){if(!e(i,o)){r(o);return}}})()})}function yH(n){return("0"+n.toString(16)).substr(-2)}function bH(){const e=new Uint32Array(56);if(typeof crypto>"u"){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=t.length;let r="";for(let i=0;i<56;i++)r+=t.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(e),Array.from(e,yH).join("")}async function xH(n){const t=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",t),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function vH(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const t=await xH(n);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function sc(n,e,t=!1){const s=bH();let r=s;t&&(r+="/PASSWORD_RECOVERY"),await dc(n,`${e}-code-verifier`,r);const i=await vH(s);return[i,s===i?"plain":"s256"]}const wH=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function SH(n){const e=n.headers.get(Tv);if(!e||!e.match(wH))return null;try{return new Date(`${e}T00:00:00.0Z`)}catch{return null}}function CH(n){if(!n)throw new Error("Missing exp claim");const e=Math.floor(Date.now()/1e3);if(n<=e)throw new Error("JWT has expired")}function TH(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const kH=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function rc(n){if(!kH.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function Tx(){const n={};return new Proxy(n,{get:(e,t)=>{if(t==="__isUserNotAvailableProxy")return!0;if(typeof t=="symbol"){const s=t.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`)},set:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function $H(n,e){return new Proxy(n,{get:(t,s,r)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const i=s.toString();if(i==="Symbol(Symbol.toPrimitive)"||i==="Symbol(Symbol.toStringTag)"||i==="Symbol(util.inspect.custom)"||i==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(t,s,r)}return!e.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),e.value=!0),Reflect.get(t,s,r)}})}function CI(n){return JSON.parse(JSON.stringify(n))}const Ia=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),EH=[502,503,504];async function TI(n){var e;if(!pH(n))throw new kv(Ia(n),0);if(EH.includes(n.status))throw new kv(Ia(n),n.status);let t;try{t=await n.json()}catch(i){throw new _a(Ia(i),i)}let s;const r=SH(n);if(r&&r.getTime()>=fR["2024-01-01"].timestamp&&typeof t=="object"&&t&&typeof t.code=="string"?s=t.code:typeof t=="object"&&t&&typeof t.error_code=="string"&&(s=t.error_code),s){if(s==="weak_password")throw new xI(Ia(t),n.status,((e=t.weak_password)===null||e===void 0?void 0:e.reasons)||[]);if(s==="session_not_found")throw new js}else if(typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((i,o)=>i&&typeof o=="string",!0))throw new xI(Ia(t),n.status,t.weak_password.reasons);throw new tH(Ia(t),n.status||500,s)}const IH=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},e?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),t))};async function Ue(n,e,t,s){var r;const i=Object.assign({},s?.headers);i[Tv]||(i[Tv]=fR["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const o=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(o.redirect_to=s.redirectTo);const l=Object.keys(o).length?"?"+new URLSearchParams(o).toString():"",c=await NH(n,e,t+l,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(c):{data:Object.assign({},c),error:null}}async function NH(n,e,t,s,r,i){const o=IH(e,s,r,i);let l;try{l=await n(t,Object.assign({},o))}catch(c){throw console.error(c),new kv(Ia(c),0)}if(l.ok||await TI(l),s?.noResolveJson)return l;try{return await l.json()}catch(c){await TI(c)}}function Rr(n){var e;let t=null;RH(n)&&(t=Object.assign({},n),n.expires_at||(t.expires_at=hH(n.expires_in)));const s=(e=n.user)!==null&&e!==void 0?e:n;return{data:{session:t,user:s},error:null}}function kI(n){const e=Rr(n);return!e.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((t,s)=>t&&typeof s=="string",!0)&&(e.data.weak_password=n.weak_password),e}function Eo(n){var e;return{data:{user:(e=n.user)!==null&&e!==void 0?e:n},error:null}}function AH(n){return{data:n,error:null}}function _H(n){const{action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i}=n,o=og(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),l={action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i},c=Object.assign({},o);return{data:{properties:l,user:c},error:null}}function $I(n){return n}function RH(n){return n.access_token&&n.refresh_token&&n.expires_in}const kx=["global","local","others"];class DH{constructor({url:e="",headers:t={},fetch:s}){this.url=e,this.headers=t,this.fetch=gR(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(e,t=kx[0]){if(kx.indexOf(t)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${kx.join(", ")}`);try{return await Ue(this.fetch,"POST",`${this.url}/logout?scope=${t}`,{headers:this.headers,jwt:e,noResolveJson:!0}),{data:null,error:null}}catch(s){if(De(s))return{data:null,error:s};throw s}}async inviteUserByEmail(e,t={}){try{return await Ue(this.fetch,"POST",`${this.url}/invite`,{body:{email:e,data:t.data},headers:this.headers,redirectTo:t.redirectTo,xform:Eo})}catch(s){if(De(s))return{data:{user:null},error:s};throw s}}async generateLink(e){try{const{options:t}=e,s=og(e,["options"]),r=Object.assign(Object.assign({},s),t);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await Ue(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:_H,redirectTo:t?.redirectTo})}catch(t){if(De(t))return{data:{properties:null,user:null},error:t};throw t}}async createUser(e){try{return await Ue(this.fetch,"POST",`${this.url}/admin/users`,{body:e,headers:this.headers,xform:Eo})}catch(t){if(De(t))return{data:{user:null},error:t};throw t}}async listUsers(e){var t,s,r,i,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Ue(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:$I});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(De(h))return{data:{users:[]},error:h};throw h}}async getUserById(e){rc(e);try{return await Ue(this.fetch,"GET",`${this.url}/admin/users/${e}`,{headers:this.headers,xform:Eo})}catch(t){if(De(t))return{data:{user:null},error:t};throw t}}async updateUserById(e,t){rc(e);try{return await Ue(this.fetch,"PUT",`${this.url}/admin/users/${e}`,{body:t,headers:this.headers,xform:Eo})}catch(s){if(De(s))return{data:{user:null},error:s};throw s}}async deleteUser(e,t=!1){rc(e);try{return await Ue(this.fetch,"DELETE",`${this.url}/admin/users/${e}`,{headers:this.headers,body:{should_soft_delete:t},xform:Eo})}catch(s){if(De(s))return{data:{user:null},error:s};throw s}}async _listFactors(e){rc(e.userId);try{const{data:t,error:s}=await Ue(this.fetch,"GET",`${this.url}/admin/users/${e.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:t,error:s}}catch(t){if(De(t))return{data:null,error:t};throw t}}async _deleteFactor(e){rc(e.userId),rc(e.id);try{return{data:await Ue(this.fetch,"DELETE",`${this.url}/admin/users/${e.userId}/factors/${e.id}`,{headers:this.headers}),error:null}}catch(t){if(De(t))return{data:null,error:t};throw t}}async _listOAuthClients(e){var t,s,r,i,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Ue(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:$I});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(De(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(e){try{return await Ue(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:e,headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(De(t))return{data:null,error:t};throw t}}async _getOAuthClient(e){try{return await Ue(this.fetch,"GET",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(De(t))return{data:null,error:t};throw t}}async _updateOAuthClient(e,t){try{return await Ue(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${e}`,{body:t,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(De(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(e){try{return await Ue(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(t){if(De(t))return{data:null,error:t};throw t}}async _regenerateOAuthClientSecret(e){try{return await Ue(this.fetch,"POST",`${this.url}/admin/oauth/clients/${e}/regenerate_secret`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(De(t))return{data:null,error:t};throw t}}}function EI(n={}){return{getItem:e=>n[e]||null,setItem:(e,t)=>{n[e]=t},removeItem:e=>{delete n[e]}}}const ic={debug:!!(globalThis&&mR()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class yR extends Error{constructor(e){super(e),this.isAcquireTimeout=!0}}class OH extends yR{}async function MH(n,e,t){ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,e);const s=new globalThis.AbortController;return e>0&&setTimeout(()=>{s.abort(),ic.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},e),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,e===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await t()}finally{ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(e===0)throw ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new OH(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(ic.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await t()}}))}function FH(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function bR(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function LH(n){return parseInt(n,16)}function PH(n){const e=new TextEncoder().encode(n);return"0x"+Array.from(e,s=>s.toString(16).padStart(2,"0")).join("")}function zH(n){var e;const{chainId:t,domain:s,expirationTime:r,issuedAt:i=new Date,nonce:o,notBefore:l,requestId:c,resources:h,scheme:d,uri:p,version:m}=n;{if(!Number.isInteger(t))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${t}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(o&&o.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((e=n.statement)===null||e===void 0)&&e.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=bR(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let S=`URI: ${p}
Version: ${m}
Chain ID: ${t}${o?`
Nonce: ${o}`:""}
Issued At: ${i.toISOString()}`;if(r&&(S+=`
Expiration Time: ${r.toISOString()}`),l&&(S+=`
Not Before: ${l.toISOString()}`),c&&(S+=`
Request ID: ${c}`),h){let T=`
Resources:`;for(const k of h){if(!k||typeof k!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${k}`);T+=`
- ${k}`}S+=T}return`${w}
${S}`}class pn extends Error{constructor({message:e,code:t,cause:s,name:r}){var i;super(e,{cause:s}),this.__isWebAuthnError=!0,this.name=(i=r??(s instanceof Error?s.name:void 0))!==null&&i!==void 0?i:"Unknown Error",this.code=t}}class Tm extends pn{constructor(e,t){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:t,message:e}),this.name="WebAuthnUnknownError",this.originalError=t}}function BH({error:n,options:e}){var t,s,r;const{publicKey:i}=e;if(!i)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new pn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((t=i.authenticatorSelection)===null||t===void 0?void 0:t.requireResidentKey)===!0)return new pn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(e.mediation==="conditional"&&((s=i.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new pn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((r=i.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new pn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new pn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new pn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return i.pubKeyCredParams.filter(l=>l.type==="public-key").length===0?new pn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new pn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const o=window.location.hostname;if(xR(o)){if(i.rp.id!==o)return new pn({message:`The RP ID "${i.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new pn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new pn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new pn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new pn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function VH({error:n,options:e}){const{publicKey:t}=e;if(!t)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new pn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new pn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(xR(s)){if(t.rpId!==s)return new pn({message:`The RP ID "${t.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new pn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new pn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new pn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class UH{createNewAbortSignal(){if(this.controller){const t=new Error("Cancelling existing WebAuthn API call for new one");t.name="AbortError",this.controller.abort(t)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}}const jH=new UH;function GH(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:e,user:t,excludeCredentials:s}=n,r=og(n,["challenge","user","excludeCredentials"]),i=Cc(e).buffer,o=Object.assign(Object.assign({},t),{id:Cc(t.id).buffer}),l=Object.assign(Object.assign({},r),{challenge:i,user:o});if(s&&s.length>0){l.excludeCredentials=new Array(s.length);for(let c=0;c<s.length;c++){const h=s[c];l.excludeCredentials[c]=Object.assign(Object.assign({},h),{id:Cc(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return l}function WH(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:e,allowCredentials:t}=n,s=og(n,["challenge","allowCredentials"]),r=Cc(e).buffer,i=Object.assign(Object.assign({},s),{challenge:r});if(t&&t.length>0){i.allowCredentials=new Array(t.length);for(let o=0;o<t.length;o++){const l=t[o];i.allowCredentials[o]=Object.assign(Object.assign({},l),{id:Cc(l.id).buffer,type:l.type||"public-key",transports:l.transports})}}return i}function HH(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n;return{id:n.id,rawId:n.id,response:{attestationObject:La(new Uint8Array(n.response.attestationObject)),clientDataJSON:La(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function qH(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n,s=n.getClientExtensionResults(),r=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:La(new Uint8Array(r.authenticatorData)),clientDataJSON:La(new Uint8Array(r.clientDataJSON)),signature:La(new Uint8Array(r.signature)),userHandle:r.userHandle?La(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function xR(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function II(){var n,e;return!!(Gn()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((e=navigator?.credentials)===null||e===void 0?void 0:e.get)=="function")}async function KH(n){try{const e=await navigator.credentials.create(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new Tm("Browser returned unexpected credential type",e)}:{data:null,error:new Tm("Empty credential response",e)}}catch(e){return{data:null,error:BH({error:e,options:n})}}}async function XH(n){try{const e=await navigator.credentials.get(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new Tm("Browser returned unexpected credential type",e)}:{data:null,error:new Tm("Empty credential response",e)}}catch(e){return{data:null,error:VH({error:e,options:n})}}}const YH={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},JH={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function km(...n){const e=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),t=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),s={};for(const r of n)if(r)for(const i in r){const o=r[i];if(o!==void 0)if(Array.isArray(o))s[i]=o;else if(t(o))s[i]=o;else if(e(o)){const l=s[i];e(l)?s[i]=km(l,o):s[i]=km(o)}else s[i]=o}return s}function ZH(n,e){return km(YH,n,e||{})}function QH(n,e){return km(JH,n,e||{})}class e5{constructor(e){this.client=e,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(e){return this.client.mfa.enroll(Object.assign(Object.assign({},e),{factorType:"webauthn"}))}async _challenge({factorId:e,webauthn:t,friendlyName:s,signal:r},i){try{const{data:o,error:l}=await this.client.mfa.challenge({factorId:e,webauthn:t});if(!o)return{data:null,error:l};const c=r??jH.createNewAbortSignal();if(o.webauthn.type==="create"){const{user:h}=o.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(o.webauthn.type){case"create":{const h=ZH(o.webauthn.credential_options.publicKey,i?.create),{data:d,error:p}=await KH({publicKey:h,signal:c});return d?{data:{factorId:e,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}case"request":{const h=QH(o.webauthn.credential_options.publicKey,i?.request),{data:d,error:p}=await XH(Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:h,signal:c}));return d?{data:{factorId:e,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}}}catch(o){return De(o)?{data:null,error:o}:{data:null,error:new _a("Unexpected error in challenge",o)}}}async _verify({challengeId:e,factorId:t,webauthn:s}){return this.client.mfa.verify({factorId:t,challengeId:e,webauthn:s})}async _authenticate({factorId:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!t)return{data:null,error:new Dh("rpId is required for WebAuthn authentication")};try{if(!II())return{data:null,error:new _a("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this.challenge({factorId:e,webauthn:{rpId:t,rpOrigins:s},signal:r},{request:i});if(!o)return{data:null,error:l};const{webauthn:c}=o;return this._verify({factorId:e,challengeId:o.challengeId,webauthn:{type:c.type,rpId:t,rpOrigins:s,credential_response:c.credential_response}})}catch(o){return De(o)?{data:null,error:o}:{data:null,error:new _a("Unexpected error in authenticate",o)}}}async _register({friendlyName:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!t)return{data:null,error:new Dh("rpId is required for WebAuthn registration")};try{if(!II())return{data:null,error:new _a("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this._enroll({friendlyName:e});if(!o)return await this.client.mfa.listFactors().then(d=>{var p;return(p=d.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===e&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:l};const{data:c,error:h}=await this._challenge({factorId:o.id,friendlyName:o.friendly_name,webauthn:{rpId:t,rpOrigins:s},signal:r},{create:i});return c?this._verify({factorId:o.id,challengeId:c.challengeId,webauthn:{rpId:t,rpOrigins:s,type:c.webauthn.type,credential_response:c.webauthn.credential_response}}):{data:null,error:h}}catch(o){return De(o)?{data:null,error:o}:{data:null,error:new _a("Unexpected error in register",o)}}}}FH();const t5={url:YW,storageKey:JW,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:ZW,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function NI(n,e,t){return await t()}const oc={};class Oh{get jwks(){var e,t;return(t=(e=oc[this.storageKey])===null||e===void 0?void 0:e.jwks)!==null&&t!==void 0?t:{keys:[]}}set jwks(e){oc[this.storageKey]=Object.assign(Object.assign({},oc[this.storageKey]),{jwks:e})}get jwks_cached_at(){var e,t;return(t=(e=oc[this.storageKey])===null||e===void 0?void 0:e.cachedAt)!==null&&t!==void 0?t:Number.MIN_SAFE_INTEGER}set jwks_cached_at(e){oc[this.storageKey]=Object.assign(Object.assign({},oc[this.storageKey]),{cachedAt:e})}constructor(e){var t,s,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const i=Object.assign(Object.assign({},t5),e);if(this.storageKey=i.storageKey,this.instanceID=(t=Oh.nextInstanceID[this.storageKey])!==null&&t!==void 0?t:0,Oh.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!i.debug,typeof i.debug=="function"&&(this.logger=i.debug),this.instanceID>0&&Gn()){const o=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(o),this.logDebugMessages&&console.trace(o)}if(this.persistSession=i.persistSession,this.autoRefreshToken=i.autoRefreshToken,this.admin=new DH({url:i.url,headers:i.headers,fetch:i.fetch}),this.url=i.url,this.headers=i.headers,this.fetch=gR(i.fetch),this.lock=i.lock||NI,this.detectSessionInUrl=i.detectSessionInUrl,this.flowType=i.flowType,this.hasCustomAuthorizationHeader=i.hasCustomAuthorizationHeader,this.throwOnError=i.throwOnError,i.lock?this.lock=i.lock:this.persistSession&&Gn()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=MH:this.lock=NI,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new e5(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(i.storage?this.storage=i.storage:mR()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=EI(this.memoryStorage)),i.userStorage&&(this.userStorage=i.userStorage)):(this.memoryStorage={},this.storage=EI(this.memoryStorage)),Gn()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(o){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",o)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async o=>{this._debug("received broadcast notification from other tab or client",o),await this._notifyAllSubscribers(o.data.event,o.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(e){if(this.throwOnError&&e&&e.error)throw e.error;return e}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${dR}) ${new Date().toISOString()}`}_debug(...e){return this.logDebugMessages&&this.logger(this._logPrefix(),...e),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var e;try{let t={},s="none";if(Gn()&&(t=fH(window.location.href),this._isImplicitGrantCallback(t)?s="implicit":await this._isPKCECallback(t)&&(s="pkce")),Gn()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(t,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),rH(i)){const c=(e=i.details)===null||e===void 0?void 0:e.code;if(c==="identity_already_exists"||c==="identity_not_found"||c==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:o,redirectType:l}=r;return this._debug("#_initialize()","detected session in URL",o,"redirect type",l),await this._saveSession(o),setTimeout(async()=>{l==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",o):await this._notifyAllSubscribers("SIGNED_IN",o)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(t){return De(t)?this._returnResult({error:t}):this._returnResult({error:new _a("Unexpected error during initialization",t)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(e){var t,s,r;try{const i=await Ue(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(t=e?.options)===null||t===void 0?void 0:t.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=e?.options)===null||r===void 0?void 0:r.captchaToken}},xform:Rr}),{data:o,error:l}=i;if(l||!o)return this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(De(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signUp(e){var t,s,r;try{let i;if("email"in e){const{email:d,password:p,options:m}=e;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await sc(this.storage,this.storageKey)),i=await Ue(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:p,data:(t=m?.data)!==null&&t!==void 0?t:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:Rr})}else if("phone"in e){const{phone:d,password:p,options:m}=e;i=await Ue(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:p,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:Rr})}else throw new jp("You must provide either an email or phone number and a password");const{data:o,error:l}=i;if(l||!o)return await jn(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signInWithPassword(e){try{let t;if("email"in e){const{email:i,password:o,options:l}=e;t=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:kI})}else if("phone"in e){const{phone:i,password:o,options:l}=e;t=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:kI})}else throw new jp("You must provide either an email or phone number and a password");const{data:s,error:r}=t;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!s||!s.session||!s.user){const i=new nc;return this._returnResult({data:{user:null,session:null},error:i})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(t){if(De(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOAuth(e){var t,s,r,i;return await this._handleProviderSignIn(e.provider,{redirectTo:(t=e.options)===null||t===void 0?void 0:t.redirectTo,scopes:(s=e.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=e.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=e.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(e){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(e))}async signInWithWeb3(e){const{chain:t}=e;switch(t){case"ethereum":return await this.signInWithEthereum(e);case"solana":return await this.signInWithSolana(e);default:throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`)}}async signInWithEthereum(e){var t,s,r,i,o,l,c,h,d,p,m;let y,b;if("message"in e)y=e.message,b=e.signature;else{const{chain:x,wallet:w,statement:S,options:T}=e;let k;if(Gn())if(typeof w=="object")k=w;else{const D=window;if("ethereum"in D&&typeof D.ethereum=="object"&&"request"in D.ethereum&&typeof D.ethereum.request=="function")k=D.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!T?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=w}const $=new URL((t=T?.url)!==null&&t!==void 0?t:window.location.href),E=await k.request({method:"eth_requestAccounts"}).then(D=>D).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const N=bR(E[0]);let _=(s=T?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!_){const D=await k.request({method:"eth_chainId"});_=LH(D)}const R={domain:$.host,address:N,statement:S,uri:$.href,version:"1",chainId:_,nonce:(r=T?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(o=(i=T?.signInWithEthereum)===null||i===void 0?void 0:i.issuedAt)!==null&&o!==void 0?o:new Date,expirationTime:(l=T?.signInWithEthereum)===null||l===void 0?void 0:l.expirationTime,notBefore:(c=T?.signInWithEthereum)===null||c===void 0?void 0:c.notBefore,requestId:(h=T?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=T?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=zH(R),b=await k.request({method:"personal_sign",params:[PH(y),N]})}try{const{data:x,error:w}=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((p=e.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=e.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:Rr});if(w)throw w;if(!x||!x.session||!x.user){const S=new nc;return this._returnResult({data:{user:null,session:null},error:S})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(De(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(e){var t,s,r,i,o,l,c,h,d,p,m,y;let b,x;if("message"in e)b=e.message,x=e.signature;else{const{chain:w,wallet:S,statement:T,options:k}=e;let $;if(Gn())if(typeof S=="object")$=S;else{const N=window;if("solana"in N&&typeof N.solana=="object"&&("signIn"in N.solana&&typeof N.solana.signIn=="function"||"signMessage"in N.solana&&typeof N.solana.signMessage=="function"))$=N.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof S!="object"||!k?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");$=S}const E=new URL((t=k?.url)!==null&&t!==void 0?t:window.location.href);if("signIn"in $&&$.signIn){const N=await $.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},k?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),T?{statement:T}:null));let _;if(Array.isArray(N)&&N[0]&&typeof N[0]=="object")_=N[0];else if(N&&typeof N=="object"&&"signedMessage"in N&&"signature"in N)_=N;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in _&&"signature"in _&&(typeof _.signedMessage=="string"||_.signedMessage instanceof Uint8Array)&&_.signature instanceof Uint8Array)b=typeof _.signedMessage=="string"?_.signedMessage:new TextDecoder().decode(_.signedMessage),x=_.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in $)||typeof $.signMessage!="function"||!("publicKey"in $)||typeof $!="object"||!$.publicKey||!("toBase58"in $.publicKey)||typeof $.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,$.publicKey.toBase58(),...T?["",T,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(r=(s=k?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=k?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${k.signInWithSolana.notBefore}`]:[],...!((o=k?.signInWithSolana)===null||o===void 0)&&o.expirationTime?[`Expiration Time: ${k.signInWithSolana.expirationTime}`]:[],...!((l=k?.signInWithSolana)===null||l===void 0)&&l.chainId?[`Chain ID: ${k.signInWithSolana.chainId}`]:[],...!((c=k?.signInWithSolana)===null||c===void 0)&&c.nonce?[`Nonce: ${k.signInWithSolana.nonce}`]:[],...!((h=k?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${k.signInWithSolana.requestId}`]:[],...!((p=(d=k?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||p===void 0)&&p.length?["Resources",...k.signInWithSolana.resources.map(_=>`- ${_}`)]:[]].join(`
`);const N=await $.signMessage(new TextEncoder().encode(b),"utf8");if(!N||!(N instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=N}}try{const{data:w,error:S}=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:La(x)},!((m=e.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=e.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:Rr});if(S)throw S;if(!w||!w.session||!w.user){const T=new nc;return this._returnResult({data:{user:null,session:null},error:T})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:S})}catch(w){if(De(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(e){const t=await Ca(this.storage,`${this.storageKey}-code-verifier`),[s,r]=(t??"").split("/");try{if(!s&&this.flowType==="pkce")throw new iH;const{data:i,error:o}=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:e,code_verifier:s},xform:Rr});if(await jn(this.storage,`${this.storageKey}-code-verifier`),o)throw o;if(!i||!i.session||!i.user){const l=new nc;return this._returnResult({data:{user:null,session:null,redirectType:null},error:l})}return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",i.session)),this._returnResult({data:Object.assign(Object.assign({},i),{redirectType:r??null}),error:o})}catch(i){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(i))return this._returnResult({data:{user:null,session:null,redirectType:null},error:i});throw i}}async signInWithIdToken(e){try{const{options:t,provider:s,token:r,access_token:i,nonce:o}=e,l=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:r,access_token:i,nonce:o,gotrue_meta_security:{captcha_token:t?.captchaToken}},xform:Rr}),{data:c,error:h}=l;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!c||!c.session||!c.user){const d=new nc;return this._returnResult({data:{user:null,session:null},error:d})}return c.session&&(await this._saveSession(c.session),await this._notifyAllSubscribers("SIGNED_IN",c.session)),this._returnResult({data:c,error:h})}catch(t){if(De(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOtp(e){var t,s,r,i,o;try{if("email"in e){const{email:l,options:c}=e;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await sc(this.storage,this.storageKey));const{error:p}=await Ue(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:l,data:(t=c?.data)!==null&&t!==void 0?t:{},create_user:(s=c?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:c?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in e){const{phone:l,options:c}=e,{data:h,error:d}=await Ue(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:l,data:(r=c?.data)!==null&&r!==void 0?r:{},create_user:(i=c?.shouldCreateUser)!==null&&i!==void 0?i:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},channel:(o=c?.channel)!==null&&o!==void 0?o:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new jp("You must provide either an email or phone number.")}catch(l){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(l))return this._returnResult({data:{user:null,session:null},error:l});throw l}}async verifyOtp(e){var t,s;try{let r,i;"options"in e&&(r=(t=e.options)===null||t===void 0?void 0:t.redirectTo,i=(s=e.options)===null||s===void 0?void 0:s.captchaToken);const{data:o,error:l}=await Ue(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},e),{gotrue_meta_security:{captcha_token:i}}),redirectTo:r,xform:Rr});if(l)throw l;if(!o)throw new Error("An error occurred on token verification.");const c=o.session,h=o.user;return c?.access_token&&(await this._saveSession(c),await this._notifyAllSubscribers(e.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(r){if(De(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(e){var t,s,r,i,o;try{let l=null,c=null;this.flowType==="pkce"&&([l,c]=await sc(this.storage,this.storageKey));const h=await Ue(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in e?{provider_id:e.providerId}:null),"domain"in e?{domain:e.domain}:null),{redirect_to:(s=(t=e.options)===null||t===void 0?void 0:t.redirectTo)!==null&&s!==void 0?s:void 0}),!((r=e?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:e.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:l,code_challenge_method:c}),headers:this.headers,xform:AH});return!((i=h.data)===null||i===void 0)&&i.url&&Gn()&&!(!((o=e.options)===null||o===void 0)&&o.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(l){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(l))return this._returnResult({data:null,error:l});throw l}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;if(s)throw s;if(!t)throw new js;const{error:r}=await Ue(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:t.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(e){if(De(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async resend(e){try{const t=`${this.url}/resend`;if("email"in e){const{email:s,type:r,options:i}=e,{error:o}=await Ue(this.fetch,"POST",t,{headers:this.headers,body:{email:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}},redirectTo:i?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:o})}else if("phone"in e){const{phone:s,type:r,options:i}=e,{data:o,error:l}=await Ue(this.fetch,"POST",t,{headers:this.headers,body:{phone:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:o?.message_id},error:l})}throw new jp("You must provide either an email or phone number and a type")}catch(t){if(De(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async t=>t))}async _acquireLock(e,t){this._debug("#_acquireLock","begin",e);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await s,await t()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,e,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=t();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(e){this._debug("#_useSession","begin");try{const t=await this.__loadSession();return await e(t)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let e=null;const t=await Ca(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",t),t!==null&&(this._isValidSession(t)?e=t:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!e)return{data:{session:null},error:null};const s=e.expires_at?e.expires_at*1e3-Date.now()<wx:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",e.expires_at),!s){if(this.userStorage){const o=await Ca(this.userStorage,this.storageKey+"-user");o?.user?e.user=o.user:e.user=Tx()}if(this.storage.isServer&&e.user&&!e.user.__isUserNotAvailableProxy){const o={value:this.suppressGetSessionWarning};e.user=$H(e.user,o),o.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:e},error:null}}const{data:r,error:i}=await this._callRefreshToken(e.refresh_token);return i?this._returnResult({data:{session:null},error:i}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(e){if(e)return await this._getUser(e);await this.initializePromise;const t=await this._acquireLock(-1,async()=>await this._getUser());return t.data.user&&(this.suppressGetSessionWarning=!0),t}async _getUser(e){try{return e?await Ue(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:e,xform:Eo}):await this._useSession(async t=>{var s,r,i;const{data:o,error:l}=t;if(l)throw l;return!(!((s=o.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new js}:await Ue(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(i=(r=o.session)===null||r===void 0?void 0:r.access_token)!==null&&i!==void 0?i:void 0,xform:Eo})})}catch(t){if(De(t))return sH(t)&&(await this._removeSession(),await jn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:t});throw t}}async updateUser(e,t={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(e,t))}async _updateUser(e,t={}){try{return await this._useSession(async s=>{const{data:r,error:i}=s;if(i)throw i;if(!r.session)throw new js;const o=r.session;let l=null,c=null;this.flowType==="pkce"&&e.email!=null&&([l,c]=await sc(this.storage,this.storageKey));const{data:h,error:d}=await Ue(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:t?.emailRedirectTo,body:Object.assign(Object.assign({},e),{code_challenge:l,code_challenge_method:c}),jwt:o.access_token,xform:Eo});if(d)throw d;return o.user=h.user,await this._saveSession(o),await this._notifyAllSubscribers("USER_UPDATED",o),this._returnResult({data:{user:o.user},error:null})})}catch(s){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(e))}async _setSession(e){try{if(!e.access_token||!e.refresh_token)throw new js;const t=Date.now()/1e3;let s=t,r=!0,i=null;const{payload:o}=Cx(e.access_token);if(o.exp&&(s=o.exp,r=s<=t),r){const{data:l,error:c}=await this._callRefreshToken(e.refresh_token);if(c)return this._returnResult({data:{user:null,session:null},error:c});if(!l)return{data:{user:null,session:null},error:null};i=l}else{const{data:l,error:c}=await this._getUser(e.access_token);if(c)throw c;i={access_token:e.access_token,refresh_token:e.refresh_token,user:l.user,token_type:"bearer",expires_in:s-t,expires_at:s},await this._saveSession(i),await this._notifyAllSubscribers("SIGNED_IN",i)}return this._returnResult({data:{user:i.user,session:i},error:null})}catch(t){if(De(t))return this._returnResult({data:{session:null,user:null},error:t});throw t}}async refreshSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(e))}async _refreshSession(e){try{return await this._useSession(async t=>{var s;if(!e){const{data:o,error:l}=t;if(l)throw l;e=(s=o.session)!==null&&s!==void 0?s:void 0}if(!e?.refresh_token)throw new js;const{data:r,error:i}=await this._callRefreshToken(e.refresh_token);return i?this._returnResult({data:{user:null,session:null},error:i}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(t){if(De(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async _getSessionFromURL(e,t){try{if(!Gn())throw new Gp("No browser detected.");if(e.error||e.error_description||e.error_code)throw new Gp(e.error_description||"Error in URL with unspecified error_description",{error:e.error||"unspecified_error",code:e.error_code||"unspecified_code"});switch(t){case"implicit":if(this.flowType==="pkce")throw new bI("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Gp("Not a valid implicit grant flow url.");break;default:}if(t==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!e.code)throw new bI("No code detected.");const{data:T,error:k}=await this._exchangeCodeForSession(e.code);if(k)throw k;const $=new URL(window.location.href);return $.searchParams.delete("code"),window.history.replaceState(window.history.state,"",$.toString()),{data:{session:T.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:r,access_token:i,refresh_token:o,expires_in:l,expires_at:c,token_type:h}=e;if(!i||!l||!o||!h)throw new Gp("No session defined in URL");const d=Math.round(Date.now()/1e3),p=parseInt(l);let m=d+p;c&&(m=parseInt(c));const y=m-d;y*1e3<=hc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${p}s`);const b=m-p;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(i);if(w)throw w;const S={provider_token:s,provider_refresh_token:r,access_token:i,expires_in:p,expires_at:m,refresh_token:o,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:S,redirectType:e.type},error:null})}catch(s){if(De(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(e){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),e):!!(e.access_token||e.error_description)}async _isPKCECallback(e){const t=await Ca(this.storage,`${this.storageKey}-code-verifier`);return!!(e.code&&t)}async signOut(e={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(e))}async _signOut({scope:e}={scope:"global"}){return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({error:i});const o=(s=r.session)===null||s===void 0?void 0:s.access_token;if(o){const{error:l}=await this.admin.signOut(o,e);if(l&&!(nH(l)&&(l.status===404||l.status===401||l.status===403)))return this._returnResult({error:l})}return e!=="others"&&(await this._removeSession(),await jn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(e){const t=dH(),s={id:t,callback:e,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",t),this.stateChangeEmitters.delete(t)}};return this._debug("#onAuthStateChange()","registered callback with id",t),this.stateChangeEmitters.set(t,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(t)})))(),{data:{subscription:s}}}async _emitInitialSession(e){return await this._useSession(async t=>{var s,r;try{const{data:{session:i},error:o}=t;if(o)throw o;await((s=this.stateChangeEmitters.get(e))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",i)),this._debug("INITIAL_SESSION","callback id",e,"session",i)}catch(i){await((r=this.stateChangeEmitters.get(e))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",e,"error",i),console.error(i)}})}async resetPasswordForEmail(e,t={}){let s=null,r=null;this.flowType==="pkce"&&([s,r]=await sc(this.storage,this.storageKey,!0));try{return await Ue(this.fetch,"POST",`${this.url}/recover`,{body:{email:e,code_challenge:s,code_challenge_method:r,gotrue_meta_security:{captcha_token:t.captchaToken}},headers:this.headers,redirectTo:t.redirectTo})}catch(i){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(i))return this._returnResult({data:null,error:i});throw i}}async getUserIdentities(){var e;try{const{data:t,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(e=t.user.identities)!==null&&e!==void 0?e:[]},error:null})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}}async linkIdentity(e){return"token"in e?this.linkIdentityIdToken(e):this.linkIdentityOAuth(e)}async linkIdentityOAuth(e){var t;try{const{data:s,error:r}=await this._useSession(async i=>{var o,l,c,h,d;const{data:p,error:m}=i;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,e.provider,{redirectTo:(o=e.options)===null||o===void 0?void 0:o.redirectTo,scopes:(l=e.options)===null||l===void 0?void 0:l.scopes,queryParams:(c=e.options)===null||c===void 0?void 0:c.queryParams,skipBrowserRedirect:!0});return await Ue(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=p.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(r)throw r;return Gn()&&!(!((t=e.options)===null||t===void 0)&&t.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:e.provider,url:s?.url},error:null})}catch(s){if(De(s))return this._returnResult({data:{provider:e.provider,url:null},error:s});throw s}}async linkIdentityIdToken(e){return await this._useSession(async t=>{var s;try{const{error:r,data:{session:i}}=t;if(r)throw r;const{options:o,provider:l,token:c,access_token:h,nonce:d}=e,p=await Ue(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=i?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:l,id_token:c,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:Rr}),{data:m,error:y}=p;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new nc}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(r){if(await jn(this.storage,`${this.storageKey}-code-verifier`),De(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(e){try{return await this._useSession(async t=>{var s,r;const{data:i,error:o}=t;if(o)throw o;return await Ue(this.fetch,"DELETE",`${this.url}/user/identities/${e.identity_id}`,{headers:this.headers,jwt:(r=(s=i.session)===null||s===void 0?void 0:s.access_token)!==null&&r!==void 0?r:void 0})})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}}async _refreshAccessToken(e){const t=`#_refreshAccessToken(${e.substring(0,5)}...)`;this._debug(t,"begin");try{const s=Date.now();return await gH(async r=>(r>0&&await mH(200*Math.pow(2,r-1)),this._debug(t,"refreshing attempt",r),await Ue(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:e},headers:this.headers,xform:Rr})),(r,i)=>{const o=200*Math.pow(2,r);return i&&Sx(i)&&Date.now()+o-s<hc})}catch(s){if(this._debug(t,"error",s),De(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(t,"end")}}_isValidSession(e){return typeof e=="object"&&e!==null&&"access_token"in e&&"refresh_token"in e&&"expires_at"in e}async _handleProviderSignIn(e,t){const s=await this._getUrlForProvider(`${this.url}/authorize`,e,{redirectTo:t.redirectTo,scopes:t.scopes,queryParams:t.queryParams});return this._debug("#_handleProviderSignIn()","provider",e,"options",t,"url",s),Gn()&&!t.skipBrowserRedirect&&window.location.assign(s),{data:{provider:e,url:s},error:null}}async _recoverAndRefresh(){var e,t;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const r=await Ca(this.storage,this.storageKey);if(r&&this.userStorage){let o=await Ca(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!o&&(o={user:r.user},await dc(this.userStorage,this.storageKey+"-user",o)),r.user=(e=o?.user)!==null&&e!==void 0?e:Tx()}else if(r&&!r.user&&!r.user){const o=await Ca(this.storage,this.storageKey+"-user");o&&o?.user?(r.user=o.user,await jn(this.storage,this.storageKey+"-user"),await dc(this.storage,this.storageKey,r)):r.user=Tx()}if(this._debug(s,"session from storage",r),!this._isValidSession(r)){this._debug(s,"session is not valid"),r!==null&&await this._removeSession();return}const i=((t=r.expires_at)!==null&&t!==void 0?t:1/0)*1e3-Date.now()<wx;if(this._debug(s,`session has${i?"":" not"} expired with margin of ${wx}s`),i){if(this.autoRefreshToken&&r.refresh_token){const{error:o}=await this._callRefreshToken(r.refresh_token);o&&(console.error(o),Sx(o)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",o),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:o,error:l}=await this._getUser(r.access_token);!l&&o?.user?(r.user=o.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(o){console.error("Error getting user data:",o),this._debug(s,"error getting user data, skipping SIGNED_IN notification",o)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(s,"error",r),console.error(r);return}finally{this._debug(s,"end")}}async _callRefreshToken(e){var t,s;if(!e)throw new js;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${e.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new lg;const{data:i,error:o}=await this._refreshAccessToken(e);if(o)throw o;if(!i.session)throw new js;await this._saveSession(i.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",i.session);const l={data:i.session,error:null};return this.refreshingDeferred.resolve(l),l}catch(i){if(this._debug(r,"error",i),De(i)){const o={data:null,error:i};return Sx(i)||await this._removeSession(),(t=this.refreshingDeferred)===null||t===void 0||t.resolve(o),o}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(i),i}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(e,t,s=!0){const r=`#_notifyAllSubscribers(${e})`;this._debug(r,"begin",t,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:e,session:t});const i=[],o=Array.from(this.stateChangeEmitters.values()).map(async l=>{try{await l.callback(e,t)}catch(c){i.push(c)}});if(await Promise.all(o),i.length>0){for(let l=0;l<i.length;l+=1)console.error(i[l]);throw i[0]}}finally{this._debug(r,"end")}}async _saveSession(e){this._debug("#_saveSession()",e),this.suppressGetSessionWarning=!0,await jn(this.storage,`${this.storageKey}-code-verifier`);const t=Object.assign({},e),s=t.user&&t.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&t.user&&await dc(this.userStorage,this.storageKey+"-user",{user:t.user});const r=Object.assign({},t);delete r.user;const i=CI(r);await dc(this.storage,this.storageKey,i)}else{const r=CI(t);await dc(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await jn(this.storage,this.storageKey),await jn(this.storage,this.storageKey+"-code-verifier"),await jn(this.storage,this.storageKey+"-user"),this.userStorage&&await jn(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const e=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{e&&Gn()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",e)}catch(t){console.error("removing visibilitychange callback failed",t)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const e=setInterval(()=>this._autoRefreshTokenTick(),hc);this.autoRefreshTicker=e,e&&typeof e=="object"&&typeof e.unref=="function"?e.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(e),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const e=this.autoRefreshTicker;this.autoRefreshTicker=null,e&&clearInterval(e)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const e=Date.now();try{return await this._useSession(async t=>{const{data:{session:s}}=t;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((s.expires_at*1e3-e)/hc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${hc}ms, refresh threshold is ${Cv} ticks`),r<=Cv&&await this._callRefreshToken(s.refresh_token)})}catch(t){console.error("Auto refresh tick failed with error. This is likely a transient error.",t)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(e){if(e.isAcquireTimeout||e instanceof yR)this._debug("auto refresh token tick lock not available");else throw e}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!Gn()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(e){console.error("_handleVisibilityChange",e)}}async _onVisibilityChanged(e){const t=`#_onVisibilityChanged(${e})`;this._debug(t,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),e||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(t,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(e,t,s){const r=[`provider=${encodeURIComponent(t)}`];if(s?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&r.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[i,o]=await sc(this.storage,this.storageKey),l=new URLSearchParams({code_challenge:`${encodeURIComponent(i)}`,code_challenge_method:`${encodeURIComponent(o)}`});r.push(l.toString())}if(s?.queryParams){const i=new URLSearchParams(s.queryParams);r.push(i.toString())}return s?.skipBrowserRedirect&&r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${e}?${r.join("&")}`}async _unenroll(e){try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;return i?this._returnResult({data:null,error:i}):await Ue(this.fetch,"DELETE",`${this.url}/factors/${e.factorId}`,{headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token})})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}}async _enroll(e){try{return await this._useSession(async t=>{var s,r;const{data:i,error:o}=t;if(o)return this._returnResult({data:null,error:o});const l=Object.assign({friendly_name:e.friendlyName,factor_type:e.factorType},e.factorType==="phone"?{phone:e.phone}:e.factorType==="totp"?{issuer:e.issuer}:{}),{data:c,error:h}=await Ue(this.fetch,"POST",`${this.url}/factors`,{body:l,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(e.factorType==="totp"&&c.type==="totp"&&(!((r=c?.totp)===null||r===void 0)&&r.qr_code)&&(c.totp.qr_code=`data:image/svg+xml;utf-8,${c.totp.qr_code}`),this._returnResult({data:c,error:null}))})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}}async _verify(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({data:null,error:i});const o=Object.assign({challenge_id:e.challengeId},"webauthn"in e?{webauthn:Object.assign(Object.assign({},e.webauthn),{credential_response:e.webauthn.type==="create"?HH(e.webauthn.credential_response):qH(e.webauthn.credential_response)})}:{code:e.code}),{data:l,error:c}=await Ue(this.fetch,"POST",`${this.url}/factors/${e.factorId}/verify`,{body:o,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return c?this._returnResult({data:null,error:c}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+l.expires_in},l)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",l),this._returnResult({data:l,error:c}))})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}})}async _challenge(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({data:null,error:i});const o=await Ue(this.fetch,"POST",`${this.url}/factors/${e.factorId}/challenge`,{body:e,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});if(o.error)return o;const{data:l}=o;if(l.type!=="webauthn")return{data:l,error:null};switch(l.webauthn.type){case"create":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:GH(l.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:WH(l.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}})}async _challengeAndVerify(e){const{data:t,error:s}=await this._challenge({factorId:e.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:e.factorId,challengeId:t.id,code:e.code})}async _listFactors(){var e;const{data:{user:t},error:s}=await this.getUser();if(s)return{data:null,error:s};const r={all:[],phone:[],totp:[],webauthn:[]};for(const i of(e=t?.factors)!==null&&e!==void 0?e:[])r.all.push(i),i.status==="verified"&&r[i.factor_type].push(i);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var e,t;const{data:{session:s},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:i}=Cx(s.access_token);let o=null;i.aal&&(o=i.aal);let l=o;((t=(e=s.user.factors)===null||e===void 0?void 0:e.filter(d=>d.status==="verified"))!==null&&t!==void 0?t:[]).length>0&&(l="aal2");const h=i.amr||[];return{data:{currentLevel:o,nextLevel:l,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?await Ue(this.fetch,"GET",`${this.url}/oauth/authorizations/${e}`,{headers:this.headers,jwt:s.access_token,xform:i=>({data:i,error:null})}):this._returnResult({data:null,error:new js})})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}}async _approveAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new js});const o=await Ue(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Gn()&&!t?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(De(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new js});const o=await Ue(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Gn()&&!t?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(De(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;return s?this._returnResult({data:null,error:s}):t?await Ue(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:t.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new js})})}catch(e){if(De(e))return this._returnResult({data:null,error:e});throw e}}async _revokeOAuthGrant(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?(await Ue(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:e.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new js})})}catch(t){if(De(t))return this._returnResult({data:null,error:t});throw t}}async fetchJwk(e,t={keys:[]}){let s=t.keys.find(l=>l.kid===e);if(s)return s;const r=Date.now();if(s=this.jwks.keys.find(l=>l.kid===e),s&&this.jwks_cached_at+eH>r)return s;const{data:i,error:o}=await Ue(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(o)throw o;return!i.keys||i.keys.length===0||(this.jwks=i,this.jwks_cached_at=r,s=i.keys.find(l=>l.kid===e),!s)?null:s}async getClaims(e,t={}){try{let s=e;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:r,payload:i,signature:o,raw:{header:l,payload:c}}=Cx(s);t?.allowExpired||CH(i.exp);const h=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,t?.keys?{keys:t.keys}:t?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:i,header:r,signature:o},error:null}}const d=TH(r.alg),p=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,p,o,uH(`${l}.${c}`)))throw new $v("Invalid JWT signature");return{data:{claims:i,header:r,signature:o},error:null}}catch(s){if(De(s))return this._returnResult({data:null,error:s});throw s}}}Oh.nextInstanceID={};const n5=Oh,s5="2.89.0";let ah="";typeof Deno<"u"?ah="deno":typeof document<"u"?ah="web":typeof navigator<"u"&&navigator.product==="ReactNative"?ah="react-native":ah="node";const r5={"X-Client-Info":`supabase-js-${ah}/${s5}`},i5={headers:r5},o5={schema:"public"},a5={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},l5={};function Mh(n){"@babel/helpers - typeof";return Mh=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Mh(n)}function c5(n,e){if(Mh(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(Mh(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function u5(n){var e=c5(n,"string");return Mh(e)=="symbol"?e:e+""}function h5(n,e,t){return(e=u5(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function AI(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function Jt(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?AI(Object(t),!0).forEach(function(s){h5(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):AI(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const d5=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),f5=()=>Headers,p5=(n,e,t)=>{const s=d5(t),r=f5();return async(i,o)=>{var l;const c=(l=await e())!==null&&l!==void 0?l:n;let h=new r(o?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${c}`),s(i,Jt(Jt({},o),{},{headers:h}))}};function m5(n){return n.endsWith("/")?n:n+"/"}function g5(n,e){var t,s;const{db:r,auth:i,realtime:o,global:l}=n,{db:c,auth:h,realtime:d,global:p}=e,m={db:Jt(Jt({},c),r),auth:Jt(Jt({},h),i),realtime:Jt(Jt({},d),o),storage:{},global:Jt(Jt(Jt({},p),l),{},{headers:Jt(Jt({},(t=p?.headers)!==null&&t!==void 0?t:{}),(s=l?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function y5(n){const e=n?.trim();if(!e)throw new Error("supabaseUrl is required.");if(!e.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(m5(e))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var b5=class extends n5{constructor(n){super(n)}},x5=class{constructor(n,e,t){var s,r;this.supabaseUrl=n,this.supabaseKey=e;const i=y5(n);if(!e)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",i),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",i),this.storageUrl=new URL("storage/v1",i),this.functionsUrl=new URL("functions/v1",i);const o=`sb-${i.hostname.split(".")[0]}-auth-token`,l={db:o5,realtime:l5,auth:Jt(Jt({},a5),{},{storageKey:o}),global:i5},c=g5(t??{},l);if(this.storageKey=(s=c.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(r=c.global.headers)!==null&&r!==void 0?r:{},c.accessToken)this.accessToken=c.accessToken,this.auth=new Proxy({},{get:(d,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=c.auth)!==null&&h!==void 0?h:{},this.headers,c.global.fetch)}this.fetch=p5(e,this._getAccessToken.bind(this),c.global.fetch),this.realtime=this._initRealtimeClient(Jt({headers:this.headers,accessToken:this._getAccessToken.bind(this)},c.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new ZG(new URL("rest/v1",i).href,{headers:this.headers,schema:c.db.schema,fetch:this.fetch}),this.storage=new XW(this.storageUrl.href,this.headers,this.fetch,t?.storage),c.accessToken||this._listenForAuthEvents()}get functions(){return new qG(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,e={},t={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,e,t)}channel(n,e={config:{}}){return this.realtime.channel(n,e)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,e,t;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(e=(t=s.session)===null||t===void 0?void 0:t.access_token)!==null&&e!==void 0?e:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,storageKey:i,flowType:o,lock:l,debug:c,throwOnError:h},d,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new b5({url:this.authUrl.href,headers:Jt(Jt({},m),d),storageKey:i,autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,flowType:o,lock:l,debug:c,throwOnError:h,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new mW(this.realtimeUrl.href,Jt(Jt({},n),{},{params:Jt(Jt({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,e)=>{this._handleTokenChanged(n,"CLIENT",e?.access_token)})}_handleTokenChanged(n,e,t){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==t?(this.changedAccessToken=t,this.realtime.setAuth(t)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),e=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const v5=(n,e,t)=>new x5(n,e,t);function w5(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const e=n.match(/^v(\d+)\./);return e?parseInt(e[1],10)<=18:!1}w5()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const S5="https://brrjoheinakfhohesogc.supabase.co",C5="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",T5={getItem:n=>typeof chrome<"u"&&chrome.storage&&chrome.storage.local?new Promise(e=>{chrome.storage.local.get([n],t=>e(t[n]||null))}):localStorage.getItem(n),setItem:(n,e)=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.set({[n]:e}):localStorage.setItem(n,e)},removeItem:n=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.remove([n]):localStorage.removeItem(n)}},us=v5(S5,C5,{auth:{storage:T5,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!1}}),vR=Se.createContext(),k5=({children:n})=>{const[e,t]=Se.useState(null),[s,r]=Se.useState(null),[i,o]=Se.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[l,c]=Se.useState(!0);Se.useEffect(()=>{p(),us.auth.getSession().then(({data:{session:y}})=>{t(y?.user||null),y?.user?h(y.user.id,y.user.email):c(!1)});const{data:{subscription:m}}=us.auth.onAuthStateChange((y,b)=>{t(b?.user||null),b?.user?h(b.user.id,b.user.email):(r(null),c(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await us.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:S}=await us.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();S||(b=w)}b&&b.subscription_tier==="pro"&&b.pro_expires_at&&new Date(b.pro_expires_at)<new Date&&(console.log("Pro status expired. Downgrading to free tier..."),await us.from("profiles").update({subscription_tier:"free"}).eq("id",m),b.subscription_tier="free"),r(b)}catch(b){console.error("Profile fetch error:",b)}finally{c(!1)}},d=()=>{e&&h(e.id,e.email)},p=async()=>{try{const{data:m,error:y}=await us.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&o(m)}catch(m){console.error("Neural state sync error:",m)}};return oe.jsx(vR.Provider,{value:{user:e,profile:s,neuralState:i,loading:l,refreshProfile:d,fetchNeuralState:p,setUser:t,setProfile:r,setNeuralState:o},children:n})},$5=()=>Se.useContext(vR),Ev=(n,e)=>{if(!n||n.length<e)return[];const t=[];for(let s=e-1;s<n.length;s++){const r=n.slice(s-e+1,s+1).reduce((i,o)=>i+o,0);t.push(r/e)}return t},vh=(n,e)=>{if(n.length<e)return[];const t=2/(e+1);let s=[n[0]];for(let r=1;r<n.length;r++)s.push(n[r]*t+s[r-1]*(1-t));return s},E5=(n,e=14)=>{if(n.length<e+1)return[];let t=0,s=0;for(let c=1;c<=e;c++){const h=n[c]-n[c-1];h>=0?t+=h:s+=Math.abs(h)}let r=t/e,i=s/e;const o=[];let l=i===0?100:r/i;o.push(100-100/(1+l));for(let c=e+1;c<n.length;c++){const h=n[c]-n[c-1];h>=0?(r=(r*(e-1)+h)/e,i=(i*(e-1)+0)/e):(r=(r*(e-1)+0)/e,i=(i*(e-1)+Math.abs(h))/e),l=i===0?100:r/i,o.push(100-100/(1+l))}return o},I5=(n,e=20,t=2)=>{if(n.length<e)return[];const s=[],r=[],i=Ev(n,e);for(let o=0;o<i.length;o++){const l=n.slice(o,o+e),c=i[o],d=l.map(m=>Math.pow(m-c,2)).reduce((m,y)=>m+y,0)/e,p=Math.sqrt(d);r.push(c+t*p),s.push(c-t*p)}return{basis:i,upper:r,lower:s}},N5=(n,e=12,t=26,s=9)=>{const r=vh(n,e),i=vh(n,t),o=[],l=Math.min(r.length,i.length);for(let d=0;d<l;d++)o.push(r[d]-i[d]);const c=vh(o,s),h=[];for(let d=0;d<Math.min(o.length,c.length);d++)h.push(o[d]-c[d]);return{macdLine:o,signalLine:c,histogram:h}},A5=(n,e=[],t=[],s=[])=>{if(n.length<50)return[{name:"Insufficient Data",sentiment:"Neutral",confidence:0}];const r=n[n.length-1],i=n[n.length-2],o=s.length>0?s[s.length-1]:i,l=e.length>0?e[e.length-1]:Math.max(r,o),c=t.length>0?t[t.length-1]:Math.min(r,o),h=Math.abs(r-o),d=l-c||1e-4,p=(r+o)/2,m=r>o,y=r<o;let b=[];h/d<.1&&(p>l-d*.2?b.push({name:"Dragonfly Doji",sentiment:"Bullish",icon:"zap"}):p<c+d*.2?b.push({name:"Gravestone Doji",sentiment:"Bearish",icon:"trending-down"}):b.push({name:"Doji Star",sentiment:"Neutral",icon:"minus"}));const x=Math.min(o,r)-c,w=l-Math.max(o,r);if(x>h*2&&w<h*.5&&b.push({name:"Hammer",sentiment:"Bullish",icon:"thumbs-up"}),w>h*2&&x<h*.5&&b.push({name:m?"Inverted Hammer":"Shooting Star",sentiment:m?"Bullish":"Bearish",icon:m?"zap":"trending-down"}),s.length>1){const A=s[s.length-2],z=n[n.length-2],W=z<A,Y=z>A;m&&W&&r>A&&o<z?b.push({name:"Bullish Engulfing",sentiment:"Bullish",icon:"zap"}):y&&Y&&r<A&&o>z&&b.push({name:"Bearish Engulfing",sentiment:"Bearish",icon:"trending-down"})}if(s.length>1){const A=s[s.length-2],z=n[n.length-2],W=e[e.length-2]||Math.max(A,z),Y=t[t.length-2]||Math.min(A,z);l<W&&c>Y&&b.push({name:"Harami (Inside Bar)",sentiment:m?"Bullish":"Bearish",icon:"activity"})}h/d>.9&&b.push({name:m?"Bullish Marubozu":"Bearish Marubozu",sentiment:m?"Bullish":"Bearish",icon:"zap"});const S=Ev(n.slice(-20),10),T=Ev(n.slice(-50),40),k=S[S.length-1],$=T[T.length-1],E=k>$,{upper:N,lower:_}=I5(n,20),R=N[N.length-1],D=_[_.length-1];return(R-D)/r<.05&&b.push({name:"Volatility Squeeze",sentiment:"Neutral",icon:"activity"}),b.length===0&&(E?b.push({name:"Bullish Continuation",sentiment:"Bullish",icon:"trending-up"}):b.push({name:"Bearish Continuation",sentiment:"Bearish",icon:"trending-down"})),b},_5=(n,e,t,s=14)=>{let r=[];const i=Array.isArray(n)&&Array.isArray(e)&&Array.isArray(t),o=i||Array.isArray(n)?n.length:0;if(o<s+1)return[];for(let d=1;d<o;d++){let p;if(i){const m=n[d],y=e[d],b=t[d-1];p=Math.max(m-y,Math.abs(m-b),Math.abs(y-b))}else{const m=n[d],y=n[d-1],b=Math.abs(m-y);p=Math.max(b,m*.0075)}r.push(p)}const l=[];let c=r.slice(0,s).reduce((d,p)=>d+p,0)/s;l.push(c);for(let d=s;d<r.length;d++){const p=(l[l.length-1]*(s-1)+r[d])/s;l.push(p)}return[...new Array(o-l.length).fill(l[0]),...l]},R5=(n,e,t)=>{const s=Array.isArray(n)?n:[];if(s.length<20)return{support:Math.min(...s),resistance:Math.max(...s),strength:{s:1,r:1}};const r=Array.isArray(e)&&Array.isArray(t)&&e.length===s.length,i=[],o=5;for(let p=o;p<s.length-o;p++)if(r){const m=e.slice(p-o,p+o+1),y=e[p];m.every(w=>w<=y)&&i.push({price:y,type:"Resistance"});const b=t.slice(p-o,p+o+1),x=t[p];b.every(w=>w>=x)&&i.push({price:x,type:"Support"})}else{const m=s.slice(p-o,p+o+1),y=s[p],b=m.every(w=>w<=y),x=m.every(w=>w>=y);b&&i.push({price:y,type:"Resistance"}),x&&i.push({price:y,type:"Support"})}const l=s[s.length-1],c=(p,m)=>{const y=i.filter(S=>S.type===p&&(p==="Support"?S.price<m:S.price>m));if(y.length===0)return{price:p==="Support"?Math.min(...s):Math.max(...s),strength:1};const x=y.sort((S,T)=>Math.abs(S.price-m)-Math.abs(T.price-m))[0].price,w=i.filter(S=>S.type===p&&Math.abs(S.price-x)/x<.005).length;return{price:x,strength:Math.min(5,w)}},h=c("Support",l),d=c("Resistance",l);return{support:h.price,resistance:d.price,strength:{s:h.strength,r:d.strength}}},D5=(n,e,t,s)=>{if(!s||s.length===0||s.length!==t.length)return t;let r=0,i=0;const o=[];for(let l=0;l<t.length;l++){const c=(n[l]+e[l]+t[l])/3;r+=c*s[l],i+=s[l],o.push(i===0?c:r/i)}return o},O5=n=>{if(!n||n.length<50)return .5;const e=vh(n.slice(-20),10),t=vh(n.slice(-50),40),s=e[e.length-1],r=t[t.length-1];let i=.5;s>r&&(i=.75),s<r&&(i=.25);const o=n[n.length-1];return o>s&&s>r&&(i=.9),o<s&&s<r&&(i=.1),i};const M5=1e-7,F5=1e-4;class wR{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Zw{refCount(e){return $s("refCount")}incRef(e){return $s("incRef")}timerAvailable(){return!0}time(e){return $s("time")}read(e){return $s("read")}readSync(e){return $s("readSync")}readToGPU(e,t){return $s("readToGPU")}numDataIds(){return $s("numDataIds")}disposeData(e,t){return $s("disposeData")}write(e,t,s){return $s("write")}move(e,t,s,r,i){return $s("move")}createTensorFromGPUData(e,t,s){return $s("createTensorFromGPUData")}memory(){return $s("memory")}floatPrecision(){return $s("floatPrecision")}epsilon(){return this.floatPrecision()===32?M5:F5}dispose(){return $s("dispose")}}function $s(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function L5(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,fc(n,e,t)}function Wa(n,e,t){return Math.max(n,Math.min(e,t))}function Qw(n){return n%2===0?n:n+1}function fc(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function P5(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function L(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function e1(n,e,t=""){L(xt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function t1(n){L(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function pe(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function xt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function _c(n){return n%1===0}function Iv(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function Tc(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function _I(n,e=r=>0,t,s){return new Promise((r,i)=>{let o=0;const l=()=>{if(n()){r();return}o++;const c=e(o);if(t!=null&&o>=t){i();return}s!=null?s(l,c):setTimeout(l,c)};l()})}function SR(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function st(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),L(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),L(n.every(s=>_c(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Go(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:st(e,n).sort();let o=0;for(let l=0;l<n.length;++l){if(i!=null){if(i[o]===l&&n[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${n[l]}' is not 1`);(i[o]==null||i[o]>l)&&n[l]===1&&(t.push(n[l]),s.push(l)),i[o]<=l&&o++}n[l]!==1&&(t.push(n[l]),s.push(l))}return{newShape:t,keptDims:s}}function Hn(n,e){return Qt(n,e)}function Qt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function z5(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function B5(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function CR(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function $m(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function V5(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function ed(n){return typeof n=="string"||n instanceof String}function U5(n){return typeof n=="boolean"}function Nv(n){return typeof n=="number"}function Wc(n){return Array.isArray(n)?Wc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Nv(n)?"float32":ed(n)?"string":U5(n)?"bool":"float32"}function Av(n){return!!(n&&n.constructor&&n.call&&n.apply)}function _v(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Oe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function TR(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=t[n+o]}else{const i=e[0],o=e.slice(1),l=o.reduce((c,h)=>c*h)*(s?2:1);for(let c=0;c<i;c++)r[c]=TR(n+c*l,o,t,s)}return r}function Br(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return TR(0,n,e,t)}function j5(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function n1(n,e){const t=qn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function qn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function kR(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Br(n,new Float32Array(t));if(e==="int32")return Br(n,new Int32Array(t));if(e==="bool")return Br(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Xi(n){n.forEach(e=>{L(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ai(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Hc(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function s1(n){return n&&n.then&&typeof n.then=="function"}const RI="tfjsflags";class G5{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=W5,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(s1(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);RI in e&&e[RI].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=q5(r,i)})}}function W5(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(H5(e,s[0],s[1]),s.join("="))),e}function H5(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function q5(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ce(){return $R}let $R=null;function K5(n){$R=n}let $x;function ER(){if($x==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");$x=n}return $x}function X5(){const n=ER();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function r1(n,e){const t=X5();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const cg="Abs",td="Acos",nd="Acosh",qc="Add",i1="AddN",o1="All",a1="Any",ug="ArgMax",hg="ArgMin",sd="Asin",rd="Asinh",id="Atan",od="Atanh",ad="Atan2",dg="AvgPool",l1="AvgPoolGrad",fg="AvgPool3D",c1="AvgPool3DGrad",pg="BatchMatMul",mg="BatchToSpaceND",u1="Bincount",h1="BitwiseAnd",Y5="BroadcastTo",IR="BroadcastArgs",ld="Cast",cd="Ceil",ud="ClipByValue",d1="Complex",gg="ComplexAbs",yg="Concat",bg="Conv2D",f1="Conv2DBackpropFilter",xg="Conv2DBackpropInput",vg="Conv3D",p1="Conv3DBackpropFilterV2",m1="Conv3DBackpropInputV2",hd="Cos",dd="Cosh",g1="Cumprod",wg="Cumsum",y1="CropAndResize",b1="DenseBincount",x1="DepthToSpace",Sg="DepthwiseConv2dNative",v1="DepthwiseConv2dNativeBackpropFilter",w1="DepthwiseConv2dNativeBackpropInput",NR="Diag",Cg="Dilation2D",Rv="Dilation2DBackpropInput",Dv="Dilation2DBackpropFilter",J5="Draw",fd="RealDiv",S1="Einsum",pd="Elu",C1="EluGrad",md="Erf",Tg="Equal",gd="Exp",kg="ExpandDims",yd="Expm1",T1="FFT",k1="Fill",$1="FlipLeftRight",bd="Floor",xd="FloorDiv",$g="FusedBatchNorm",Eg="GatherV2",AR="GatherNd",Ig="Greater",vd="GreaterEqual",wd="Identity",E1="IFFT",I1="Imag",Sd="IsFinite",Cd="IsInf",Td="IsNan",Ng="LeakyRelu",Ag="Less",_g="LessEqual",_R="LinSpace",kd="Log",$d="Log1p",Rg="LogicalAnd",Dg="LogicalNot",Og="LogicalOr",Z5="LogSoftmax",Mg="LRN",N1="LRNGrad",Fg="Max",Ed="Maximum",Lg="MaxPool",A1="MaxPoolGrad",Pg="MaxPool3D",_1="MaxPool3DGrad",RR="MaxPoolWithArgmax",zg="Mean",Bg="Min",Id="Minimum",Vg="MirrorPad",Nd="Mod",DR="Multinomial",Ad="Multiply",Ug="Neg",jg="NotEqual",R1="NonMaxSuppressionV3",D1="NonMaxSuppressionV4",O1="NonMaxSuppressionV5",Gg="OnesLike",Wg="OneHot",Hg="Pack",qg="PadV2",_d="Pow",Kg="Prelu",Xg="Prod",OR="RaggedGather",MR="RaggedRange",FR="RaggedTensorToTensor",M1="Range",F1="Real",Rd="Reciprocal",Dd="Relu",Yg="Reshape",Jg="ResizeNearestNeighbor",L1="ResizeNearestNeighborGrad",Zg="ResizeBilinear",P1="ResizeBilinearGrad",Od="Relu6",Qg="Reverse",Md="Round",Fd="Rsqrt",LR="ScatterNd",PR="TensorScatterUpdate",zR="SearchSorted",e0="Select",Ld="Selu",t0="Slice",Pd="Sin",zd="Sinh",Bd="Sign",Vd="Sigmoid",Ud="Softplus",jd="Sqrt",n0="Sum",s0="SpaceToBatchND",r0="SplitV",i0="Softmax",BR="SparseFillEmptyRows",VR="SparseReshape",UR="SparseSegmentMean",jR="SparseSegmentSum",GR="SparseToDense",Gd="SquaredDifference",z1="Square",B1="StaticRegexReplace",V1="StridedSlice",WR="StringNGrams",HR="StringSplit",qR="StringToHashBucketFast",Wd="Sub",Hd="Tan",qd="Tanh",Kd="Tile",U1="TopK",j1="Transform",kc="Transpose",G1="Unique",o0="Unpack",a0="UnsortedSegmentSum",l0="ZerosLike",Xd="Step",Q5="FromPixels",W1="RotateWithOffset",Em="_FusedMatMul",Im="FusedConv2D",KR="FusedDepthwiseConv2D";function Hs(...n){ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(...n)}function e6(...n){ce().getBool("IS_TEST")||ce().getBool("PROD")||console.log(...n)}const Nm=r1("kernelRegistry",()=>new Map),Ov=r1("gradRegistry",()=>new Map);function DI(n,e){const t=YR(n,e);return Nm.get(t)}function OI(n){return Ov.get(n)}function MI(n){const e=Nm.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[l]=i.split("_");l===n&&t.push(o)}return t}function XR(n){const{kernelName:e,backendName:t}=n,s=YR(e,t);Nm.has(s)&&Hs(`The kernel '${e}' for backend '${t}' is already registered`),Nm.set(s,n)}function t6(n){const{kernelName:e}=n;Ov.has(e)&&ce().getBool("DEBUG")&&Hs(`Overriding the gradient for '${e}'`),Ov.set(e,n)}function YR(n,e){return`${e}_${n}`}function JR(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Ex,FI;function n6(){if(FI)return Ex;FI=1,Ex=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(M,A,z){this.low=M|0,this.high=A|0,this.unsigned=!!z}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(M){return(M&&M.__isLong__)===!0}e.isLong=t;var s={},r={};function i(M,A){var z,W,Y;return A?(M>>>=0,(Y=0<=M&&M<256)&&(W=r[M],W)?W:(z=l(M,(M|0)<0?-1:0,!0),Y&&(r[M]=z),z)):(M|=0,(Y=-128<=M&&M<128)&&(W=s[M],W)?W:(z=l(M,M<0?-1:0,!1),Y&&(s[M]=z),z))}e.fromInt=i;function o(M,A){if(isNaN(M))return A?T:S;if(A){if(M<0)return T;if(M>=b)return _}else{if(M<=-x)return R;if(M+1>=x)return N}return M<0?o(-M,A).neg():l(M%y|0,M/y|0,A)}e.fromNumber=o;function l(M,A,z){return new e(M,A,z)}e.fromBits=l;var c=Math.pow;function h(M,A,z){if(M.length===0)throw Error("empty string");if(M==="NaN"||M==="Infinity"||M==="+Infinity"||M==="-Infinity")return S;if(typeof A=="number"?(z=A,A=!1):A=!!A,z=z||10,z<2||36<z)throw RangeError("radix");var W;if((W=M.indexOf("-"))>0)throw Error("interior hyphen");if(W===0)return h(M.substring(1),A,z).neg();for(var Y=o(c(z,8)),K=S,P=0;P<M.length;P+=8){var B=Math.min(8,M.length-P),G=parseInt(M.substring(P,P+B),z);if(B<8){var ee=o(c(z,B));K=K.mul(ee).add(o(G))}else K=K.mul(Y),K=K.add(o(G))}return K.unsigned=A,K}e.fromString=h;function d(M,A){return typeof M=="number"?o(M,A):typeof M=="string"?h(M,A):l(M.low,M.high,typeof A=="boolean"?A:M.unsigned)}e.fromValue=d;var p=65536,m=1<<24,y=p*p,b=y*y,x=b/2,w=i(m),S=i(0);e.ZERO=S;var T=i(0,!0);e.UZERO=T;var k=i(1);e.ONE=k;var $=i(1,!0);e.UONE=$;var E=i(-1);e.NEG_ONE=E;var N=l(-1,2147483647,!1);e.MAX_VALUE=N;var _=l(-1,-1,!0);e.MAX_UNSIGNED_VALUE=_;var R=l(0,-2147483648,!1);e.MIN_VALUE=R;var D=e.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},D.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var z=o(A),W=this.div(z),Y=W.mul(z).sub(this);return W.toString(A)+Y.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var K=o(c(A,6),this.unsigned),P=this,B="";;){var G=P.div(K),ee=P.sub(G.mul(K)).toInt()>>>0,Z=ee.toString(A);if(P=G,P.isZero())return Z+B;for(;Z.length<6;)Z="0"+Z;B=""+Z+B}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,z=31;z>0&&(A&1<<z)==0;z--);return this.high!=0?z+33:z+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(A){return t(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},D.eq=D.equals,D.notEquals=function(A){return!this.eq(A)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(A){return this.comp(A)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(A){return this.comp(A)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(A){return this.comp(A)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(A){return this.comp(A)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(A){if(t(A)||(A=d(A)),this.eq(A))return 0;var z=this.isNegative(),W=A.isNegative();return z&&!W?-1:!z&&W?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(k)},D.neg=D.negate,D.add=function(A){t(A)||(A=d(A));var z=this.high>>>16,W=this.high&65535,Y=this.low>>>16,K=this.low&65535,P=A.high>>>16,B=A.high&65535,G=A.low>>>16,ee=A.low&65535,Z=0,F=0,V=0,Q=0;return Q+=K+ee,V+=Q>>>16,Q&=65535,V+=Y+G,F+=V>>>16,V&=65535,F+=W+B,Z+=F>>>16,F&=65535,Z+=z+P,Z&=65535,l(V<<16|Q,Z<<16|F,this.unsigned)},D.subtract=function(A){return t(A)||(A=d(A)),this.add(A.neg())},D.sub=D.subtract,D.multiply=function(A){if(this.isZero())return S;if(t(A)||(A=d(A)),n){var z=n.mul(this.low,this.high,A.low,A.high);return l(z,n.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(R))return A.isOdd()?R:S;if(A.eq(R))return this.isOdd()?R:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return o(this.toNumber()*A.toNumber(),this.unsigned);var W=this.high>>>16,Y=this.high&65535,K=this.low>>>16,P=this.low&65535,B=A.high>>>16,G=A.high&65535,ee=A.low>>>16,Z=A.low&65535,F=0,V=0,Q=0,re=0;return re+=P*Z,Q+=re>>>16,re&=65535,Q+=K*Z,V+=Q>>>16,Q&=65535,Q+=P*ee,V+=Q>>>16,Q&=65535,V+=Y*Z,F+=V>>>16,V&=65535,V+=K*ee,F+=V>>>16,V&=65535,V+=P*G,F+=V>>>16,V&=65535,F+=W*Z+Y*ee+K*G+P*B,F&=65535,l(Q<<16|re,F<<16|V,this.unsigned)},D.mul=D.multiply,D.divide=function(A){if(t(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var z=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return l(z,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:S;var W,Y,K;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return T;if(A.gt(this.shru(1)))return $;K=T}else{if(this.eq(R)){if(A.eq(k)||A.eq(E))return R;if(A.eq(R))return k;var P=this.shr(1);return W=P.div(A).shl(1),W.eq(S)?A.isNegative()?k:E:(Y=this.sub(A.mul(W)),K=W.add(Y.div(A)),K)}else if(A.eq(R))return this.unsigned?T:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();K=S}for(Y=this;Y.gte(A);){W=Math.max(1,Math.floor(Y.toNumber()/A.toNumber()));for(var B=Math.ceil(Math.log(W)/Math.LN2),G=B<=48?1:c(2,B-48),ee=o(W),Z=ee.mul(A);Z.isNegative()||Z.gt(Y);)W-=G,ee=o(W,this.unsigned),Z=ee.mul(A);ee.isZero()&&(ee=k),K=K.add(ee),Y=Y.sub(Z)}return K},D.div=D.divide,D.modulo=function(A){if(t(A)||(A=d(A)),n){var z=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return l(z,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return l(~this.low,~this.high,this.unsigned)},D.and=function(A){return t(A)||(A=d(A)),l(this.low&A.low,this.high&A.high,this.unsigned)},D.or=function(A){return t(A)||(A=d(A)),l(this.low|A.low,this.high|A.high,this.unsigned)},D.xor=function(A){return t(A)||(A=d(A)),l(this.low^A.low,this.high^A.high,this.unsigned)},D.shiftLeft=function(A){return t(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):l(0,this.low<<A-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(A){return t(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):l(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(A){if(t(A)&&(A=A.toInt()),A&=63,A===0)return this;var z=this.high;if(A<32){var W=this.low;return l(W>>>A|z<<32-A,z>>>A,this.unsigned)}else return A===32?l(z,0,this.unsigned):l(z>>>A-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},D.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var A=this.high,z=this.low;return[z&255,z>>>8&255,z>>>16&255,z>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},D.toBytesBE=function(){var A=this.high,z=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,z>>>24,z>>>16&255,z>>>8&255,z&255]},e.fromBytes=function(A,z,W){return W?e.fromBytesLE(A,z):e.fromBytesBE(A,z)},e.fromBytesLE=function(A,z){return new e(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,z)},e.fromBytesBE=function(A,z){return new e(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],z)},Ex}var ZR=n6();const QR=dw(ZR),s6=xB({__proto__:null,default:QR},[ZR]);const Ra=QR||s6;function c0(n){return Ra.fromString(n,!0,16)}const eD=c0("c3a5c85c97cb3127"),Na=c0("b492b66fbe98f273"),es=c0("9ae16a3b2f90404f");function Mv(n){return n.xor(n.shru(47))}function tD(n,e,t){const s=n.slice(e,e+t);return Ra.fromBytes(Array.from(s),!0,!0)}function Rt(n,e){return tD(n,e,8)}function LI(n,e){return tD(n,e,4)}function En(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function _o(n,e,t=c0("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function r6(n,e,t,s,r,i){r=r.add(n),i=En(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),i=i.add(En(r,44)),[r.add(s),i.add(o)]}function Wp(n,e,t,s){return r6(Rt(n,e),Rt(n,e+8),Rt(n,e+16),Rt(n,e+24),t,s)}function i6(n,e=n.length){if(e>=8){const t=es.add(e*2),s=Rt(n,0).add(es),r=Rt(n,e-8),i=En(r,37).mul(t).add(s),o=En(s,25).add(r).mul(t);return _o(i,o,t)}if(e>=4){const t=es.add(e*2),s=LI(n,0);return _o(s.shl(3).add(e),LI(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),o=e+(r<<2);return Mv(es.mul(i).xor(eD.mul(o))).mul(es)}return es}function o6(n,e=n.length){const t=es.add(e*2),s=Rt(n,0).mul(Na),r=Rt(n,8),i=Rt(n,e-8).mul(t),o=Rt(n,e-16).mul(es);return _o(En(s.add(r),43).add(En(i,30)).add(o),s.add(En(r.add(es),18)).add(i),t)}function a6(n,e=n.length){const t=es.add(e*2),s=Rt(n,0).mul(es),r=Rt(n,8),i=Rt(n,e-8).mul(t),o=Rt(n,e-16).mul(es),l=En(s.add(r),43).add(En(i,30)).add(o),c=_o(l,s.add(En(r.add(es),18)).add(i),t),h=Rt(n,16).mul(t),d=Rt(n,24),p=l.add(Rt(n,e-32)).mul(t),m=c.add(Rt(n,e-24)).mul(t);return _o(En(h.add(d),43).add(En(p,30)).add(m),h.add(En(d.add(s),18)).add(p),t)}function l6(n,e=n.length){const t=Ra.fromNumber(81,!0);if(e<=32)return e<=16?i6(n,e):o6(n,e);if(e<=64)return a6(n,e);let s=t,r=t.mul(Na).add(113),i=Mv(r.mul(es).add(113)).mul(es),o=[Ra.UZERO,Ra.UZERO],l=[Ra.UZERO,Ra.UZERO];s=s.mul(es).add(Rt(n,0));let c=0;const h=(e-1>>6)*64,d=h+(e-1&63)-63;do s=En(s.add(r).add(o[0]).add(Rt(n,c+8)),37).mul(Na),r=En(r.add(o[1]).add(Rt(n,c+48)),42).mul(Na),s=s.xor(l[1]),r=r.add(o[0]).add(Rt(n,c+40)),i=En(i.add(l[0]),33).mul(Na),o=Wp(n,c,o[1].mul(Na),s.add(l[0])),l=Wp(n,c+32,i.add(l[1]),r.add(Rt(n,c+16))),[i,s]=[s,i],c+=64;while(c!==h);const p=Na.add(i.and(255).shl(1));return c=d,l[0]=l[0].add(e-1&63),o[0]=o[0].add(l[0]),l[0]=l[0].add(o[0]),s=En(s.add(r).add(o[0]).add(Rt(n,c+8)),37).mul(p),r=En(r.add(o[1]).add(Rt(n,c+48)),42).mul(p),s=s.xor(l[1].mul(9)),r=r.add(o[0].mul(9).add(Rt(n,c+40))),i=En(i.add(l[0]),33).mul(p),o=Wp(n,c,o[1].mul(p),s.add(l[0])),l=Wp(n,c+32,i.add(l[1]),r.add(Rt(n,c+16))),[i,s]=[s,i],_o(_o(o[0],l[0],p).add(Mv(r).mul(eD)).add(i),_o(o[1],l[1],p).add(s),p)}function Wo(n,e){return e==="string"?Ro(n):ol([n],e)}function c6(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function ol(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ha(n)),ce().getBool("DEBUG")&&z5(n,e),c6(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function hs(){return ce().platform.now()}function Ro(n,e="utf-8"){return e=e||"utf-8",ce().platform.encode(n,e)}function Lo(n,e="utf-8"){return e=e||"utf-8",ce().platform.decode(n,e)}function xr(n){return ce().platform.isTypedArray!=null?ce().platform.isTypedArray(n):JR(n)}function Ha(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||s1(n)||n==null||xr(n)&&t)e.push(n);else if(Array.isArray(n)||xr(n))for(let s=0;s<n.length;++s)Ha(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ha(n[r],e,t)}return e}class u6{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new d6)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let o;const l=hs();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const h of r)h.dataSync();o=Promise.resolve({kernelMs:hs()-l})}if(ce().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(p=>{h6(p,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(h=>h.kernelMs),extraInfo:o.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(l=>{Promise.all([l.data(),r,o]).then(c=>{this.logger.logKernelProfile(t,l,c[0],c[1],i,c[2])})})}}function h6(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class d6{logKernelProfile(e,t,s,r,i,o){const l=typeof r=="number"?Tc(`${r}ms`,9):r.error,c=Tc(e,25),h=t.rank,d=t.size,p=Tc(t.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const x=b.shape||t.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${c}	%c${l}	%c${h}D ${p}	%c${d}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function f6(n,e,t){const s={},r={};for(let c=0;c<e.length;c++)s[e[c].id]=!0;for(let c=0;c<n.length;c++){const h=n[c],d=h.inputs;for(const p in d){const m=d[p];let y=!1;for(let b=0;b<e.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const i={};i[t.id]=!0;const o={};for(let c=n.length-1;c>=0;c--){const h=n[c],d=h.inputs;for(let p=0;p<h.outputs.length;p++)if(i[h.outputs[p].id]){for(const m in d)i[d[m].id]=!0,o[h.id]=!0;break}}const l=[];for(let c=0;c<n.length;c++){const h=n[c];if(r[h.id]&&o[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const p=Object.assign({},h);p.inputs=d,p.outputs=h.outputs,l.push(p)}}return l}function p6(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(c=>{const h=n[c.id];h!=null?o.push(h):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const c in i.inputs){if(!(c in l))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(l)}.`);const h=t(()=>l[c]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${h.dtype}'`);const d=i.inputs[c];if(!xt(h.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${c}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const p=n[d.id];n[d.id]=s(p,h),p.dispose()}}}}const PI=20,nh=3,Ix=7;function m6(n,e,t,s){const r=Oe(e),i=g6(n,e,t,r),o=e.length,l=lm(n,e,t,r,i),c=["Tensor"];return s&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${o}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(l.map(h=>"    "+h).join(`
`)),c.join(`
`)}function g6(n,e,t,s){const r=pe(e),i=s[s.length-1],o=new Array(i).fill(0),l=e.length,c=t==="complex64"?ch(n):n;if(l>1)for(let h=0;h<r/i;h++){const d=h*i;for(let p=0;p<i;p++)o[p]=Math.max(o[p],lh(c[d+p],0,t).length)}return o}function lh(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Ix))} + ${parseFloat(n[1].toFixed(Ix))}j`:ed(n)?s=`'${n}'`:t==="bool"?s=nD(n):s=parseFloat(n.toFixed(Ix)).toString(),Tc(s,e)}function nD(n){return n===0?"false":"true"}function lm(n,e,t,s,r,i=!0){const o=t==="complex64"?2:1,l=e[0],c=e.length;if(c===0){if(t==="complex64"){const x=ch(n);return[lh(x[0],0,t)]}return t==="bool"?[nD(n[0])]:[n[0].toString()]}if(c===1){if(l>PI){const w=nh*o;let S=Array.from(n.slice(0,w)),T=Array.from(n.slice((l-nh)*o,l*o));return t==="complex64"&&(S=ch(S),T=ch(T)),["["+S.map((k,$)=>lh(k,r[$],t)).join(", ")+", ..., "+T.map((k,$)=>lh(k,r[l-nh+$],t)).join(", ")+"]"]}return["["+(t==="complex64"?ch(n):Array.from(n)).map((w,S)=>lh(w,r[S],t)).join(", ")+"]"]}const h=e.slice(1),d=s.slice(1),p=s[0]*o,m=[];if(l>PI){for(let x=0;x<nh;x++){const w=x*p,S=w+p;m.push(...lm(n.slice(w,S),h,t,d,r,!1))}m.push("...");for(let x=l-nh;x<l;x++){const w=x*p,S=w+p;m.push(...lm(n.slice(w,S),h,t,d,r,x===l-1))}}else for(let x=0;x<l;x++){const w=x*p,S=w+p;m.push(...lm(n.slice(w,S),h,t,d,r,x===l-1))}const y=c===2?",":"";m[0]="["+(l>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<c;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function ch(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class On{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=pe(e),s!=null){const r=s.length;L(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Qt(t,this.size),this.strides=Oe(e)}set(e,...t){t.length===0&&(t=[0]),L(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Lr().makeTensor(this.values,this.shape,this.dtype)}}let Lr=null,pc=null;function y6(n){Lr=n}function b6(n){pc=n}class gn{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=pe(e),this.strides=Oe(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return pc.buffer(this.shape,this.dtype,e)}bufferSync(){return pc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Br(this.shape,e,this.dtype==="complex64")}arraySync(){return Br(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Lr().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Lo(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Lr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Lr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Lo(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Lr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Lr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return pc.print(this,e)}clone(){return this.throwIfDisposed(),pc.clone(this)}toString(e=!1){const t=this.dataSync();return m6(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),pc.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Lr().makeVariable(this,e,t,s)}}Object.defineProperty(gn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function fe(){return r1("Tensor",()=>gn)}fe();class Am extends gn{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!xt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Lr().disposeTensor(this),this.dataId=e.dataId,Lr().incRef(this,null)}dispose(){Lr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Am,Symbol.hasInstance,{value:n=>n instanceof gn&&n.assign!=null&&n.assign instanceof Function});var zI;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(zI||(zI={}));var Fv;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Fv||(Fv={}));var Lv;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Lv||(Lv={}));var Pv;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Pv||(Pv={}));var zv;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(zv||(zv={}));const x6={float32:Pv,int32:Fv,bool:Lv,complex64:zv};function As(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return x6[n][e]}function H1(n){return As(n,"int32")}function sD(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function rD(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function tn(n,e){if(n.dtype===e.dtype)return[n,e];const t=As(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function iD(n){const e=[];return oD(n,e,new Set),e}function oD(n,e,t){if(n==null)return;if(n instanceof gn){e.push(n);return}if(!v6(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),oD(i,e,t))}}function v6(n){return Array.isArray(n)||typeof n=="object"}function Nx(n){return n.kernelName!=null}class BI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Rc{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new BI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Hs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new u6(this.backendInstance),!0}setupRegisteredKernels(){MI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){MI(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Zw)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Hs(`Initialization of backend ${e} failed`),Hs(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Hs(`Initialization of backend ${e} failed`),Hs(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Rc.nextTensorId++}nextVariableId(){return Rc.nextVariableId++}clone(e){const t=J.runKernel(wd,{x:e}),s={x:e},r=o=>({x:()=>{const l="float32",c={x:o},h={dtype:l};return J.runKernel(ld,c,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(DI(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(c=>{i+=c.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-t-i-o;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let c;const h=Nx(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Nx(e)){const{kernelName:b,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const S=DI(b,this.backendName);L(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),l=()=>{const T=this.backend.numDataIds();c=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const k=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,T,k);const $=k.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(b,x,$);s=this.saveTensorsForBackwardMode(E)}return $}}else{const{forwardFunc:b}=e,x=w=>{r&&(s=w.map(S=>this.keep(this.clone(S))))};l=()=>{const w=this.backend.numDataIds();c=this.tidy(()=>b(this.backend,x));const S=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,S),S}}const{inputs:d,attrs:p}=e,m=Nx(e)?null:e.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=l():(y=this.profiler.profileKernel(h,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),t=y.outputs)}),r&&this.addTapeNode(h,d,t,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=OI(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let l;r.saveAllInputs?(L(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(t).map(h=>t[h])):l=i.map(h=>t[h]);const c=s.filter((h,d)=>o[d]);return l.concat(c)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&ed(e[0])&&(i=e.map(c=>Ro(c)));const o=r.write(i,t,s),l=new gn(t,s,o,this.nextTensorId());if(this.trackTensor(l,r),s==="string"){const c=this.state.tensorInfo.get(o),h=V5(i);this.state.numBytes+=h-c.bytes,c.bytes=h}return l}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,o=new gn(r,i,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new Am(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*$m(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Am||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*$m(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,o){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},c=OI(e);c!=null&&(r=c.gradFunc),r!=null&&(l.gradient=h=>(h=h.map((d,p)=>{if(d==null){const m=s[p],y=qn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],i,o))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=iD(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(L(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));L(i instanceof gn,()=>"The result y returned by f() must be a tensor.");const o=f6(this.state.activeTape,t,i);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??w6(i.shape),p6(l,o,h=>this.tidy(h),S6);const c=t.map(h=>l[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(e){return L(Av(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{L(t.every(l=>l instanceof gn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((l,c)=>{r[c]=l});const i=(l,c)=>(s=e(...t,c),L(s.value instanceof gn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),L(Av(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(l,c)=>{const h=s.gradFunc(l,c),d=Array.isArray(h)?h:[h];L(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),L(d.every(m=>m instanceof gn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,y)=>{p[y]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=hs(),s=await this.backend.time(e);return s.wallMs=hs()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new BI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Rc.nextTensorId=0;Rc.nextVariableId=0;function w6(n){const e=n1(pe(n),"float32");return J.makeTensor(e,n,"float32")}function aD(){const n=ER();if(n._tfengine==null){const e=new G5(n);n._tfengine=new Rc(e)}return K5(n._tfengine.ENV),y6(()=>n._tfengine),n._tfengine}const J=aD();function S6(n,e){const t={a:n,b:e};return J.runKernel(qc,t)}function C6(){return typeof navigator<"u"&&navigator!=null}function lD(n){if(n||C6()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function cD(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const gs=ce();gs.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});gs.registerFlag("IS_BROWSER",()=>cD());gs.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");gs.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));gs.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));gs.registerFlag("PROD",()=>!1);gs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>gs.getBool("DEBUG"));gs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);gs.registerFlag("IS_TEST",()=>!1);gs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>gs.getBool("DEBUG"));gs.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);gs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);gs.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Yd(n,e){let t=n;if(xr(n))return e==="string"?[]:[n.length];if(sD(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(rD(n))return[n.buffer.size/(e==null?4:$m(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||xr(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ce().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&uD(n,s,[]),s}function uD(n,e,t){if(t=t||[],!Array.isArray(n)&&!xr(n)){L(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}L(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),L(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)uD(n[r],s,t.concat(r))}function VI(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function U(n,e,t,s="numeric"){if(n instanceof fe())return VI(s,n.dtype,e,t),n;let r=Wc(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),VI(s,r,e,t),n==null||!xr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}const i=Yd(n,r);!xr(n)&&!Array.isArray(n)&&(n=[n]);const l=r!=="string"?ol(n,r):Ha(n,[],!0);return J.makeTensor(l,i,r)}function hD(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>U(i,`${e}[${o}]`,t,s))}const T6="__op";function ne(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+T6;const r=(...i)=>{J.startScope(t);try{const o=s(...i);return s1(o)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(o),o}catch(o){throw J.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function k6(n,e){const t=U(n,"real","complex"),s=U(e,"imag","complex");e1(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return J.runKernel(d1,r)}const qa=ne({complex_:k6});function Jd(n,e,t,s){if(s==null)s=Wc(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(rD(n)||sD(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return J.backend.createTensorFromGPUData(n,e||t,s)}if(!xr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Xi(e);const r=pe(e),i=pe(t);L(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<t.length;++o){const l=t[o],c=o===t.length-1?l!==pe(e.slice(o)):!0;L(t[o]===e[o]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!xr(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?ol(n,s):Ha(n,[],!0),J.makeTensor(n,e,s)}function wh(n,e,t){const s=Yd(n,t);return Jd(n,e,s,t)}const _m={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ho{static join(e){return new Ho(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>xr(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),o=new Uint8Array(i);let l=0;for(let c=s;c<this.shards.length;c++){const h=this.shards[c],p=e+l-h.start,m=l,b=Math.min(t,h.end)-h.start,x=new Uint8Array(h.buffer,p,b-p);if(o.set(x,m),l+=x.length,t<h.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=$6(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function $6(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}function Qr(){return J}function UI(){return J.memory()}function ie(n,e){return J.tidy(n,e)}function tt(n){iD(n).forEach(t=>t.dispose())}function li(n){return J.keep(n)}function jI(n){return J.setBackend(n)}function E6(){return J.ready()}function dD(n,e,t=1){return J.registerBackend(n,e,t)}function I6(){return J.backend}const Dc=4;async function GI(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const l=r[o],c=Array.isArray(n)?n[o].tensor:n[l];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${c.dtype}`);const h={name:l,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const d=new Promise(async p=>{const m=await c.bytes(),y=m.reduce((w,S)=>w+S.length,0)+Dc*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const S=m[w],T=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(T,x),x+=Dc,b.set(S,x),x+=S.length}p(b)});s.push(d)}else s.push(c.data());e!=null&&(h.group=e),t.push(h)}const i=await Promise.all(s);return{data:R6(i),specs:t}}function N6(n,e){const t=new Ho(n),s={};let r=0;for(const i of e){const o=A6(i,(l,c)=>t.slice(r+l,r+c));s[i.name]=_6(i,t.slice(r,r+o)),r+=o}return s}function A6(n,e){const t=pe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=_m[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Dc+new Uint32Array(e(r,r+Dc))[0];return r}else s=_m[n.dtype];return t*s}function _6(n,e){const t=n.name,s=n.dtype,r=n.shape,i=pe(r);let o,l=0;if("quantization"in n){const c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=_m[c.dtype],d=c.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){o=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=m*c.scale+c.min}}else if(c.dtype==="float16")o=U6()(d);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(s==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);o=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=Math.round(m*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);l+=i*h}else if(s==="string"){const c=pe(n.shape);o=[];for(let h=0;h<c;h++){const d=new Uint32Array(e.slice(l,l+Dc))[0];l+=Dc;const p=new Uint8Array(e.slice(l,l+d));o.push(p),l+=d}}else{const c=_m[s];if(s==="float32")o=new Float32Array(e);else if(s==="int32")o=new Int32Array(e);else if(s==="bool")o=new Uint8Array(e);else if(s==="complex64"){o=new Float32Array(e);const h=new Float32Array(o.length/2),d=new Float32Array(o.length/2);for(let b=0;b<h.length;b++)h[b]=o[b*2],d[b]=o[b*2+1];const p=wh(h,r,"float32"),m=wh(d,r,"float32"),y=qa(p,m);return p.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);l+=i*c}return wh(o,r,s)}function R6(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const q1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function WI(n){return q1?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function D6(n){if(q1)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function O6(n){if(q1){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function M6(n){return Ho.join(n)}function F6(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function L6(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function P6(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),L6(n,t,s)}function K1(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:WI(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:WI(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Ho(n.weightData).byteLength}}function HI(n){const e=[];for(const t of n)e.push(...t.weights);return e}function z6(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function B6(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function V6(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function U6(){const n=z6(),e=B6(),t=V6();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const l=s[o],c=n[t[l>>10]+(l&1023)]+e[l>>10];i[o]=c}return new Float32Array(r)}}class $n{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return $n.instance==null&&($n.instance=new $n),$n.instance}static registerSaveRouter(e){$n.getInstance().saveRouters.push(e)}static registerLoadRouter(e){$n.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return $n.getHandlers(e,"save")}static getLoadHandlers(e,t){return $n.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?$n.getInstance().loadRouters:$n.getInstance().saveRouters).forEach(o=>{const l=o(e,s);l!==null&&r.push(l)}),r}}const j6=n=>$n.getSaveHandlers(n),G6=(n,e)=>$n.getLoadHandlers(n,e);const Bv="tensorflowjs",Vv=1,Pa="models_store",Io="model_info_store";function fD(){if(!ce().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Uv(n){const e=n.result;e.createObjectStore(Pa,{keyPath:"modelPath"}),e.createObjectStore(Io,{keyPath:"modelPath"})}class Ka{constructor(e){if(this.indexedDB=fD(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(Bv,Vv);i.onupgradeneeded=()=>Uv(i),i.onsuccess=()=>{const o=i.result;if(t==null){const l=o.transaction(Pa,"readonly"),h=l.objectStore(Pa).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(o.close(),r(h.error)),l.oncomplete=()=>o.close()}else{t.weightData=Ho.join(t.weightData);const l=K1(t),c=o.transaction(Io,"readwrite");let h=c.objectStore(Io),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(m){return r(m)}let p;d.onsuccess=()=>{p=o.transaction(Pa,"readwrite");const m=p.objectStore(Pa);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:l})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:l}),y.onerror=b=>{h=c.objectStore(Io);const x=h.delete(this.modelPath);x.onsuccess=()=>(o.close(),r(y.error)),x.onerror=w=>(o.close(),r(y.error))}},d.onerror=m=>(o.close(),r(d.error)),c.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Ka.URL_SCHEME="indexeddb://";const pD=n=>ce().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ka.URL_SCHEME)?W6(n.slice(Ka.URL_SCHEME.length)):null;$n.registerSaveRouter(pD);$n.registerLoadRouter(pD);function W6(n){return new Ka(n)}function H6(n){return n.startsWith(Ka.URL_SCHEME)?n.slice(Ka.URL_SCHEME.length):n}class q6{constructor(){this.indexedDB=fD()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Bv,Vv);s.onupgradeneeded=()=>Uv(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Io,"readonly"),l=i.objectStore(Io).getAll();l.onsuccess=()=>{const c={};for(const h of l.result)c[h.modelPath]=h.modelArtifactsInfo;e(c)},l.onerror=c=>(r.close(),t(l.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=H6(e),new Promise((t,s)=>{const r=this.indexedDB.open(Bv,Vv);r.onupgradeneeded=()=>Uv(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Io,"readwrite"),l=o.objectStore(Io),c=l.get(e);let h;c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=l.delete(e),p=()=>{h=i.transaction(Pa,"readwrite");const y=h.objectStore(Pa).delete(e);y.onsuccess=()=>t(c.result.modelArtifactsInfo),y.onerror=b=>s(c.error)};d.onsuccess=p,d.onerror=m=>(p(),i.close(),s(c.error))}},c.onerror=d=>(i.close(),s(c.error)),o.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const Bi="/",mc="tensorflowjs_models",mD="info",K6="model_topology",X6="weight_specs",Y6="weight_data",J6="model_metadata";function gD(n){return{info:[mc,n,mD].join(Bi),topology:[mc,n,K6].join(Bi),weightSpecs:[mc,n,X6].join(Bi),weightData:[mc,n,Y6].join(Bi),modelMetadata:[mc,n,J6].join(Bi)}}function yD(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Z6(n){const e=n.split(Bi);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Bi)}function Q6(n){return n.startsWith(Xa.URL_SCHEME)?n.slice(Xa.URL_SCHEME.length):n}class Xa{constructor(e){if(!ce().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=gD(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=K1(e),i=Ho.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,D6(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw yD(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const l=JSON.parse(i);t.format=l.format,t.generatedBy=l.generatedBy,t.convertedBy=l.convertedBy,l.signature!=null&&(t.signature=l.signature),l.userDefinedMetadata!=null&&(t.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(t.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(t.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(t.trainingConfig=l.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=O6(o),t}}Xa.URL_SCHEME="localstorage://";const bD=n=>ce().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xa.URL_SCHEME)?eq(n.slice(Xa.URL_SCHEME.length)):null;$n.registerSaveRouter(bD);$n.registerLoadRouter(bD);function eq(n){return new Xa(n)}class tq{constructor(){L(ce().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),L(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=mc+Bi,s=Bi+mD;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const o=Z6(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=Q6(e);const t=gD(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return yD(t),s}}const qI="://";class ei{constructor(){this.managers={}}static getInstance(){return ei.instance==null&&(ei.instance=new ei),ei.instance}static registerManager(e,t){L(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(qI)&&(e=e.slice(0,e.indexOf(qI))),L(e.length>0,()=>"scheme must not be an empty string.");const s=ei.getInstance();L(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=ei.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ei.getInstance().managers)}}class nq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ce().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return JR(e)}}if(ce().get("IS_BROWSER")){ce().setPlatform("browser",new nq);try{ei.registerManager(Xa.URL_SCHEME,new tq)}catch{}try{ei.registerManager(Ka.URL_SCHEME,new q6)}catch{}}const sq={importFetch:()=>require("node-fetch")};let Ax;class rq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ce().global.fetch!=null?ce().global.fetch(e,t):(Ax==null&&(Ax=sq.importFetch()),Ax(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ce().get("IS_NODE")&&!ce().get("IS_BROWSER")&&ce().setPlatform("node",new rq);function nt(n,e="float32",t){return e=e||"float32",Xi(n),new On(n,e,t)}function iq(n,e){const t=U(n,"x","cast");if(!B5(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return J.runKernel(ld,s,r)}const Ee=ne({cast_:iq});function oq(n){const t={x:U(n,"x","clone","string_or_numeric")};return J.runKernel(wd,t)}const Ua=ne({clone_:oq});function aq(n,e=!1){console.log(n.toString(e))}aD();const lq={buffer:nt,cast:Ee,clone:Ua,print:aq};b6(lq);function cq(n,e){let t=U(n,"a","add"),s=U(e,"b","add");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(qc,r)}const ve=ne({add_:cq});function uq(n,e){let t=U(n,"a","floorDiv"),s=U(e,"b","floorDiv");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(xd,r)}const xD=ne({floorDiv_:uq});function hq(n,e){let t=U(n,"a","div"),s=U(e,"b","div");if([t,s]=tn(t,s),t.dtype==="int32"&&s.dtype==="int32")return xD(t,s);const r={a:t,b:s},i={};return J.runKernel(fd,r,i)}const Le=ne({div_:hq});function dq(n,e){let t=U(n,"a","mul"),s=U(e,"b","mul");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(Ad,r)}const X=ne({mul_:dq});function fq(n){const e=U(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return J.runKernel(gg,t)}else{const t={x:e};return J.runKernel(cg,t)}}const Qn=ne({abs_:fq});function pq(n){const t={x:U(n,"x","acos")};return J.runKernel(td,t)}const mq=ne({acos_:pq});function gq(n){const t={x:U(n,"x","acosh")};return J.runKernel(nd,t)}const yq=ne({acosh_:gq});function bq(n,e=null,t=!1){const r={x:U(n,"x","all","bool")},i={axis:e,keepDims:t};return J.runKernel(o1,r,i)}const vD=ne({all_:bq});function xq(n,e=null,t=!1){const r={x:U(n,"x","any","bool")},i={axis:e,keepDims:t};return J.runKernel(a1,r,i)}const jv=ne({any_:xq});function vq(n,e=0){const s={x:U(n,"x","argMax")},r={axis:e};return J.runKernel(ug,s,r)}const Fh=ne({argMax_:vq});function wq(n,e=0){const s={x:U(n,"x","argMin")},r={axis:e};return J.runKernel(hg,s,r)}const Sq=ne({argMin_:wq});function Cq(n){const t={x:U(n,"x","asin")};return J.runKernel(sd,t)}const Tq=ne({asin_:Cq});function kq(n){const t={x:U(n,"x","asinh")};return J.runKernel(rd,t)}const $q=ne({asinh_:kq});function Eq(n){const t={x:U(n,"x","atan")};return J.runKernel(id,t)}const Iq=ne({atan_:Eq});function Nq(n,e){let t=U(n,"a","atan2"),s=U(e,"b","atan2");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(ad,r)}const Aq=ne({atan2_:Nq});function _q(n){const t={x:U(n,"x","atanh")};return J.runKernel(od,t)}const Rq=ne({atanh_:_q});function Zd(n,e,t,s,r="NHWC",i){const o=n[3],l=[...e,o],c=Ji(r);return Mn(n,l,t,i,s,null,null,c)}function wr(n,e,t,s,r,i,o="channelsLast"){const[l,c]=Lh(e);let h;if(o==="channelsLast")h=[l,c,n[3],n[3]];else if(o==="channelsFirst")h=[l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Mn(n,h,t,s,r,i,!1,o)}function Yi(n,e,t,s,r,i,o="NDHWC"){const[l,c,h]=Gv(e);let d,p;if(o==="NDHWC")p="channelsLast",d=[l,c,h,n[4],n[4]];else if(o==="NCDHW")p="channelsFirst",d=[l,c,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return qo(n,d,t,s,r,!1,p,i)}function Mn(n,e,t,s,r,i,o=!1,l="channelsLast"){let[c,h,d,p]=[-1,-1,-1,-1];if(l==="channelsLast")[c,h,d,p]=n;else if(l==="channelsFirst")[c,p,h,d]=n;else throw new Error(`Unknown dataFormat ${l}`);const[m,y,,b]=e,[x,w]=Lh(t),[S,T]=Lh(s),k=$c(m,S),$=$c(y,T),{padInfo:E,outHeight:N,outWidth:_}=Mq(r,h,d,x,w,k,$,i,l),R=o?b*p:b;let D;return l==="channelsFirst"?D=[c,R,N,_]:l==="channelsLast"&&(D=[c,N,_,R]),{batchSize:c,dataFormat:l,inHeight:h,inWidth:d,inChannels:p,outHeight:N,outWidth:_,outChannels:R,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:k,effectiveFilterWidth:$,dilationHeight:S,dilationWidth:T,inShape:n,outShape:D,filterShape:e}}function qo(n,e,t,s,r,i=!1,o="channelsLast",l){let[c,h,d,p,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[c,h,d,p,m]=n;else if(o==="channelsFirst")[c,m,h,d,p]=n;else throw new Error(`Unknown dataFormat ${o}`);const[y,b,x,,w]=e,[S,T,k]=Gv(t),[$,E,N]=Gv(s),_=$c(y,$),R=$c(b,E),D=$c(x,N),{padInfo:M,outDepth:A,outHeight:z,outWidth:W}=Fq(r,h,d,p,S,T,k,_,R,D,l),Y=i?w*m:w;let K;return o==="channelsFirst"?K=[c,Y,A,z,W]:o==="channelsLast"&&(K=[c,A,z,W,Y]),{batchSize:c,dataFormat:o,inDepth:h,inHeight:d,inWidth:p,inChannels:m,outDepth:A,outHeight:z,outWidth:W,outChannels:Y,padInfo:M,strideDepth:S,strideHeight:T,strideWidth:k,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:_,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:$,dilationHeight:E,dilationWidth:N,inShape:n,outShape:K,filterShape:e}}function Dq(n,e,t,s,r){s==null&&(s=X1(n,e,t));const i=n[0],o=n[1],l=Ph((i-e+2*s)/t+1,r),c=Ph((o-e+2*s)/t+1,r);return[l,c]}function Oq(n,e,t,s,r,i){r==null&&(r=X1(n,e[0],s[0]));const o=[0,0,0,t];for(let l=0;l<3;l++)n[l]+2*r>=e[l]&&(o[l]=Ph((n[l]-e[l]+2*r)/s[l]+1,i));return o}function X1(n,e,t,s=1){const r=$c(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function Lh(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Gv(n){return typeof n=="number"?[n,n,n]:n}function $c(n,e){return e<=1?n:n+(n-1)*(e-1)}function Mq(n,e,t,s,r,i,o,l,c){let h,d,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=Dq([e,t],i,s,n,l);d=y[0],p=y[1]}else if(n==="same"){d=Math.ceil(e/s),p=Math.ceil(t/r);const m=Math.max(0,(d-1)*s+i-e),y=Math.max(0,(p-1)*r+o-t),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),S=y-w;h={top:b,bottom:x,left:w,right:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-i+1)/s),p=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const m=c==="channelsLast"?n[1][0]:n[2][0],y=c==="channelsLast"?n[1][1]:n[2][1],b=c==="channelsLast"?n[2][0]:n[3][0],x=c==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=Ph((e-i+m+y)/s+1,l),p=Ph((t-o+b+x)/r+1,l)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:p}}function Fq(n,e,t,s,r,i,o,l,c,h,d){let p,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=Oq([e,t,s,1],[l,c,h],1,[r,i,o],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(e/r),y=Math.ceil(t/i),b=Math.ceil(s/o);const x=(m-1)*r+l-e,w=(y-1)*i+c-t,S=(b-1)*o+h-s,T=Math.floor(x/2),k=x-T,$=Math.floor(w/2),E=w-$,N=Math.floor(S/2),_=S-N;p={top:$,bottom:E,left:N,right:_,front:T,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:y,outWidth:b}}function Ph(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ya(n){const[e,t,s]=Lh(n);return e===1&&t===1&&s===1}function Xn(n,e){return Ya(n)||Ya(e)}function Ja(n){return Lh(n).every(e=>e>0)}function Ji(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function bs(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")L(_c(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{L(_c(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function Lq(n,e){const s={x:U(n,"x","reshape","string_or_numeric")},r={shape:e};return J.runKernel(Yg,s,r)}const te=ne({reshape_:Lq});function Pq(n,e,t,s,r){const i=U(n,"x","avgPool","float32"),o=1;L(Xn(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let l=i,c=!1;i.rank===3&&(c=!0,l=te(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),bs("avgPool",s,r);const h={x:l},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let p=J.runKernel(dg,h,d);return p=Ee(p,i.dtype),c?te(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Y1=ne({avgPool_:Pq});function zq(n,e,t,s,r,i="NDHWC"){const o=U(n,"x","avgPool3d","float32");let l=o,c=!1;o.rank===4&&(c=!0,l=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),L(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),L(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),bs("avgPool3d",s,r);const h={x:l},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let p=J.runKernel(fg,h,d);return p=Ee(p,l.dtype),c?te(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Bq=ne({avgPool3d_:zq});function Vq(n,e=0){L(n.length>=1,()=>"Pass at least one tensor to concat");const t=hD(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return Ua(t[0]);const s=t,r={axis:e};return J.runKernel(yg,s,r)}const ms=ne({concat_:Vq});function Uq(n,e,t=!1,s=!1){let r=U(n,"a","matMul"),i=U(e,"b","matMul");[r,i]=tn(r,i);const o={a:r,b:i},l={transposeA:t,transposeB:s};return J.runKernel(pg,o,l)}const yt=ne({matMul_:Uq});function jq(n){const t={x:U(n,"x","sigmoid","float32")};return J.runKernel(Vd,t)}const Kc=ne({sigmoid_:jq});function Gq(n,e,t){const s=U(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return J.runKernel(t0,r,i)}const Dt=ne({slice_:Gq});function Wq(n){const t={x:U(n,"x","tanh","float32")};return J.runKernel(qd,t)}const u0=ne({tanh_:Wq});function Hq(n,e,t){const s=U(n,"x","batchToSpaceND"),r=e.reduce((l,c)=>l*c);L(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),L(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),L(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:t};return J.runKernel(mg,i,o)}const J1=ne({batchToSpaceND_:Hq});function qq(n){let e;return n.rank===0||n.rank===1?e=te(n,[1,1,1,n.size]):n.rank===2?e=te(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=te(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function Kq(n,e,t,s,r,i){i==null&&(i=.001);const o=U(n,"x","batchNorm"),l=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;s!=null&&(d=U(s,"offset","batchNorm")),L(l.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(h==null||l.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:qq(o),scale:h,offset:d,mean:l,variance:c},y={varianceEpsilon:i},b=J.runKernel($g,m,y);return te(b,o.shape)}const h0=ne({batchNorm_:Kq});function Xq(n,e,t,s,r,i){const o=U(n,"x","batchNorm"),l=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),L(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),L(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),L(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),h0(o,l,c,d,h,i)}const Yq=ne({batchNorm2d_:Xq});function Jq(n,e,t,s,r,i){const o=U(n,"x","batchNorm"),l=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),L(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),L(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),L(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),h0(o,l,c,d,h,i)}const Zq=ne({batchNorm3d_:Jq});function Qq(n,e,t,s,r,i){const o=U(n,"x","batchNorm"),l=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),L(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),L(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),L(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),h0(o,l,c,d,h,i)}const e8=ne({batchNorm4d_:Qq});function t8(n,e,t){const s=U(n,"x","bincount"),r=U(e,"weights","bincount");L(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),L(t>=0,()=>`size must be non-negative, but got ${t}.`),L(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:t};return J.runKernel(u1,i,o)}const n8=ne({bincount_:t8});function s8(n,e){let t=U(n,"broadcastTo","x");const s=t.shape;if(Xi(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=te(t,h)}const r=t.shape,i=Array.from(e);for(let h=e.length-1;h>=0;h--)if(r[h]===e[h])i[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Ua(t);const l={x:t},c={reps:i};return J.runKernel(Kd,l,c)}const Sh=ne({broadcastTo_:s8});function r8(n){const t={x:U(n,"x","ceil","float32")};return J.runKernel(cd,t)}const i8=ne({ceil_:r8});function d0(n,e,t){Xi(n),t=t||Wc(e);const s={shape:n,value:e,dtype:t};return J.runKernel(k1,{},s)}function o8(n,e,t){const s=U(n,"x","clipByValue");if(L(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return d0(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return J.runKernel(ud,r,i)}const Xs=ne({clipByValue_:o8});function a8(n){return ms(n,0)}const l8=ne({concat1d_:a8});function c8(n,e){return ms(n,e)}const u8=ne({concat2d_:c8});function h8(n,e){return ms(n,e)}const d8=ne({concat3d_:h8});function f8(n,e){return ms(n,e)}const p8=ne({concat4d_:f8});function m8(n,e,t,s,r="NHWC",i=[1,1],o){const l=U(n,"x","conv2d","float32"),c=U(e,"filter","conv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=te(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),L(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),bs("conv2d",s,o);const p=r==="NHWC"?h.shape[3]:h.shape[1];L(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),L(Xn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),L(Ja(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),L(Ja(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:c},y={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=J.runKernel(bg,m,y);return d?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Za=ne({conv2d_:m8});function g8(n,e,t,s,r="NWC",i=1,o){const l=U(n,"x","conv1d"),c=U(e,"filter","conv1d");let h=l,d=!1;l.rank===2&&(d=!0,h=te(l,[1,l.shape[0],l.shape[1]])),L(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),L(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),bs("conv1d",s,o),L(h.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${c.shape[1]}.`),L(Xn(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),L(Ja(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),L(Ja(t),()=>"Error in conv1D: Stride should be larger than 0."),L(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=te(c,[1,c.shape[0],c.shape[1],c.shape[2]]),m=te(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=Za(m,p,[1,t],s,"NHWC",[1,i],o);return d?te(w,[w.shape[2],w.shape[3]]):te(w,[w.shape[0],w.shape[2],w.shape[3]])}const wD=ne({conv1d_:g8});function y8(n,e,t,s,r,i="NHWC",o){L(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let l=n,c=e,h=!1;e.rank===3&&(h=!0,c=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]),l=[1,n[0],n[1],n[2]]),L(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),L(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),L(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=i==="NHWC"?l[3]:l[1],p=i==="NHWC"?c.shape[3]:c.shape[1];L(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),L(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),bs("conv2dDerInput",r,o);const m={dy:c,filter:t},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:l},b=J.runKernel(xg,m,y);return h?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Z1=ne({conv2DBackpropInput_:y8});function b8(n,e,t,s,r,i){const o=U(n,"x","conv2dTranspose"),l=U(e,"filter","conv2dTranspose");return Z1(t,o,l,s,r,"NHWC",i)}const SD=ne({conv2dTranspose_:b8});function x8(n,e,t,s,r="NDHWC",i=[1,1,1]){const o=U(n,"x","conv3d"),l=U(e,"filter","conv3d");let c=o,h=!1;o.rank===4&&(h=!0,c=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),L(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),L(c.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${l.shape[3]}.`),L(Xn(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),L(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),L(Ja(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),L(Ja(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:i},m=J.runKernel(vg,d,p);return h?te(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const v8=ne({conv3d_:x8});function w8(n,e,t,s,r){L(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,l=!1;e.rank===4&&(l=!0,o=te(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const c=i[4],h=o.shape[4];L(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),L(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),L(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),L(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),L(h===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[4]}.`);const d={dy:o,filter:t},p={pad:r,strides:s,inputShape:i},m=J.runKernel(m1,d,p);return l?te(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const CD=ne({conv3DBackpropInput_:w8});function S8(n,e,t,s,r){const i=U(n,"x","conv3dTranspose"),o=U(e,"filter","conv3dTranspose");return CD(t,i,o,s,r)}const C8=ne({conv3dTranspose_:S8});function T8(n){const t={x:U(n,"x","cos","float32")};return J.runKernel(hd,t)}const Q1=ne({cos_:T8});function k8(n){const t={x:U(n,"x","cosh","float32")};return J.runKernel(dd,t)}const TD=ne({cosh_:k8});function $8(n,e=0,t=!1,s=!1){const i={x:U(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return J.runKernel(g1,i,o)}const Wv=ne({cumprod_:$8});function E8(n,e=0,t=!1,s=!1){const i={x:U(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return J.runKernel(wg,i,o)}const kD=ne({cumsum_:E8});function I8(n,e,t,s=!1){const r=U(n,"x","denseBincount"),i=U(e,"weights","denseBincount");L(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),L(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),L(t>=0,()=>`size must be non-negative, but got ${t}.`),L(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},l={size:t,binaryOutput:s};return J.runKernel(b1,o,l)}const KI=ne({denseBincount_:I8});function N8(n,e,t="NHWC"){const s=U(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];L(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),L(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),L(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),L(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const l={x:s},c={blockSize:e,dataFormat:t};return J.runKernel(x1,l,c)}const A8=ne({depthToSpace_:N8});function _8(n,e,t,s,r="NHWC",i=[1,1],o){const l=U(n,"x","depthwiseConv2d","float32"),c=U(e,"filter","depthwiseConv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=te(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),L(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const p=r==="NHWC"?h.shape[3]:h.shape[1];L(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),bs("depthwiseConv2d",s,o);const m={x:h,filter:c},y={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=J.runKernel(Sg,m,y);return d?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const eS=ne({depthwiseConv2d_:_8});function R8(n,e,t,s,r=[1,1],i="NHWC"){const o=U(n,"x","dilation2d"),l=U(e,"filter","dilation2d");L(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),L(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),L(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let c=o,h=!1;o.rank===3&&(c=te(o,[1,o.shape[0],o.shape[1],o.shape[2]]),h=!0),L(c.shape[3]===l.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${l.shape[2]}`);const d={x:c,filter:l},p={strides:t,pad:s,dilations:r},m=J.runKernel(Cg,d,p);return h?te(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const D8=ne({dilation2d_:R8});function Oc(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,o=n[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function wn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&t.unshift(i)}return t}function Ye(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)s[t-r-1]=o;else if(o===1)s[t-r-1]=i;else if(i!==o){const l=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(l)}else s[t-r-1]=i}return s}function O8(n,e){let t=U(n,"a","equal","string_or_numeric"),s=U(e,"b","equal","string_or_numeric");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Tg,r)}const fi=ne({equal_:O8});function M8(n,e,t){const s=U(e,"a","where"),r=U(t,"b","where"),i=U(n,"condition","where","bool"),o=Ye(Ye(i.shape,s.shape),r.shape),l=Sh(i,o),c=Sh(s,o),h=Sh(r,o),d={condition:l,t:c,e:h};return J.runKernel(e0,d)}const ss=ne({where_:M8});function F8(n){const t={x:U(n,"x","zerosLike")};return J.runKernel(l0,t)}const ht=ne({zerosLike_:F8});function L8(n,e){let t=U(n,"a","div"),s=U(e,"b","div");[t,s]=tn(t,s);const r=Le(t,s),i=ht(r),o=fi(s,i);return ss(o,i,r)}const P8=ne({divNoNan_:L8});function z8(n,e){const t=U(n,"t1","dot"),s=U(e,"t2","dot");L((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(L(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const o=te(t,[1,-1]),l=te(s,[-1,1]),c=yt(o,l);return te(c,[])}else if(t.rank===1&&s.rank===2){const o=te(t,[1,-1]),l=te(s,[s.shape[0],s.shape[1]]),c=yt(o,l);return te(c,[c.size])}else if(t.rank===2&&s.rank===1){const o=te(s,[-1,1]),l=yt(t,o);return te(l,[l.size])}else{const o=te(s,[s.shape[0],s.shape[1]]);return yt(t,o)}}const B8=ne({dot_:z8});function V8(n,...e){const t=e.map((r,i)=>U(r,`tensors${i}`,"einsum")),s={equation:n};return J.runKernel(S1,t,s)}const sh=ne({einsum_:V8});function U8(n){const t={x:U(n,"x","elu","float32")};return J.runKernel(pd,t)}const f0=ne({elu_:U8});function j8(n){let e=U(n,"x","erf");L(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ee(e,"float32"));const t={x:e};return J.runKernel(md,t)}const $D=ne({erf_:j8});function tS(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function ED(n,e,t){const s=n.length+e.length,r=[];let i=0,o=0;for(let l=0;l<s;l++)t.indexOf(l)===-1?r.push(n[i++]):r.push(e[o++]);return r}function An(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function cn(n,e){const t=e.map(s=>1);return ED(n,t,e)}function Fn(n,e,t){L(tS(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Wt(n,e){if(tS(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Ko(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function nn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function G8(n,e=null,t=!1){const r={x:U(n,"x","max")},i={reductionIndices:e,keepDims:t};return J.runKernel(Fg,r,i)}const Vr=ne({max_:G8});function W8(n,e=null,t=!1){const r={x:U(n,"x","min")},i={axis:e,keepDims:t};return J.runKernel(Bg,r,i)}const Rm=ne({min_:W8});function H8(n,e){let t=U(n,"base","pow"),s=U(e,"exp","pow");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(_d,r)}const Qa=ne({pow_:H8});function bt(n,e){if((xr(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&xr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Jd(n,[],[],e)}function q8(n){const t={x:U(n,"x","sqrt","float32")};return J.runKernel(jd,t)}const Kn=ne({sqrt_:q8});function K8(n){const e=U(n,"x","square"),t={};return J.runKernel("Square",{x:e},t)}const Ft=ne({square_:K8});function X8(n,e=null,t=!1){let s=U(n,"x","sum");s.dtype==="bool"&&(s=Ee(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return J.runKernel(n0,r,i)}const Me=ne({sum_:X8});function Y8(n,e="euclidean",t=null,s=!1){n=U(n,"x","norm");const r=ID(n,e,t);let i=r.shape;if(s){const o=st(t,n.shape);i=cn(r.shape,o)}return te(r,i)}function ID(n,e,t=null){if(n.rank===0)return Qn(n);if(n.rank!==1&&t===null)return ID(te(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Me(Qn(n),t);if(e===1/0)return Vr(Qn(n),t);if(e===-1/0)return Rm(Qn(n),t);if(e==="euclidean"||e===2)return Kn(Me(Qa(Qn(n),bt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Vr(Me(Qn(n),t[0]),t[1]-1);if(e===1/0)return Vr(Me(Qn(n),t[1]),t[0]);if(e===-1/0)return Rm(Me(Qn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Kn(Me(Ft(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const p0=ne({norm_:Y8});function J8(n,e=null,t=!1){return p0(n,"euclidean",e,t)}const Z8=ne({euclideanNorm_:J8});function Q8(n){const t={x:U(n,"x","exp")};return J.runKernel(gd,t)}const pi=ne({exp_:Q8});function eK(n,e=0){const t=U(n,"x","expandDims","string_or_numeric");L(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return J.runKernel(kg,s,r)}const ds=ne({expandDims_:eK});function tK(n){const t={x:U(n,"x","expm1")};return J.runKernel(yd,t)}const nK=ne({expm1_:tK});function sK(n,e){const t=U(n,"x","tile","string_or_numeric");L(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return J.runKernel(Kd,s,r)}const zr=ne({tile_:sK});function rK(n,e,t,s="float32"){e==null&&(e=n);const r=nt([n,e],s),i=n<=e?n:e;for(let l=0;l<i;++l)r.set(1,l,l);const o=te(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return zr(ds(o,0),[t[0],1,1]);if(t.length===2)return zr(ds(ds(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return zr(ds(ds(ds(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const ND=ne({eye_:rK});function iK(n){const t={x:U(n,"x","floor","float32")};return J.runKernel(bd,t)}const m0=ne({floor_:iK});function oK(n,e,t=0,s=0){const r=U(n,"x","gather"),i=U(e,"indices","gather","int32"),o={x:r,indices:i},l={axis:t,batchDims:s};return J.runKernel(Eg,o,l)}const nS=ne({gather_:oK});function aK(n,e){let t=U(n,"a","greater","string_or_numeric"),s=U(e,"b","greater","string_or_numeric");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Ig,r)}const Ys=ne({greater_:aK});function lK(n,e){let t=U(n,"a","greaterEqual","string_or_numeric"),s=U(e,"b","greaterEqual","string_or_numeric");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(vd,r)}const al=ne({greaterEqual_:lK});function cK(n){const t={input:U(n,"input","imag")};return J.runKernel(I1,t)}const sS=ne({imag_:cK});function uK(n){const t={x:U(n,"x","isFinite")};return J.runKernel(Sd,t)}const hK=ne({isFinite_:uK});function dK(n){const t={x:U(n,"x","isInf")};return J.runKernel(Cd,t)}const fK=ne({isInf_:dK});function pK(n){const t={x:U(n,"x","isNaN")};return J.runKernel(Td,t)}const mK=ne({isNaN_:pK});function gK(n,e=.2){const s={x:U(n,"x","leakyRelu")},r={alpha:e};return J.runKernel(Ng,s,r)}const rS=ne({leakyRelu_:gK});function yK(n,e){let t=U(n,"a","less","string_or_numeric"),s=U(e,"b","less","string_or_numeric");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Ag,r)}const Dm=ne({less_:yK});function bK(n,e){let t=U(n,"a","lessEqual","string_or_numeric"),s=U(e,"b","lessEqual","string_or_numeric");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(_g,r)}const Xc=ne({lessEqual_:bK});function xK(n,e=5,t=1,s=1,r=.5){const i=U(n,"x","localResponseNormalization");L(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),L(_c(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,l=!1;i.rank===3&&(l=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c={x:o},h={depthRadius:e,bias:t,alpha:s,beta:r},d=J.runKernel(Mg,c,h);return l?te(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const vK=ne({localResponseNormalization_:xK});function wK(n){const t={x:U(n,"x","log","float32")};return J.runKernel(kd,t)}const mi=ne({log_:wK});function SK(n){const t={x:U(n,"x","log1p")};return J.runKernel($d,t)}const AD=ne({log1p_:SK});function CK(n,e){L(Av(n),()=>"The f passed in variableGrads(f) must be a function"),L(e==null||Array.isArray(e)&&e.every(h=>h instanceof Am),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const h in J.registeredVariables)e.push(J.registeredVariables[h])}const s=t?e.filter(h=>!h.trainable):null,r=e.length;e=e.filter(h=>h.trainable),L(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:l}=J.gradients(n,e,null,i);L(l.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),L(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const c={};return e.forEach((h,d)=>{l[d]!=null&&(c[h.name]=l[d])}),s?.forEach(h=>c[h.name]=null),{value:o,grads:c}}function Mc(n){return J.customGrad(n)}function TK(n){const t={x:U(n,"x","neg")};return J.runKernel(Ug,t)}const en=ne({neg_:TK});function kK(n){const t={x:U(n,"x","softplus")};return J.runKernel(Ud,t)}const Qd=ne({softplus_:kK});function $K(n){const e=U(n,"x","logSigmoid");return Mc(s=>({value:en(Qd(en(s))),gradFunc:o=>X(o,Kc(en(s)))}))(e)}const EK=ne({logSigmoid_:$K});function IK(n,e){let t=U(n,"a","sub"),s=U(e,"b","sub");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(Wd,r)}const Ve=ne({sub_:IK});function NK(n,e=-1){const t=U(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Mc((r,i)=>{const l=Vr(r,e,!0),c=Ve(r,l),h=Ve(Ee(c,"float32"),mi(Me(pi(c),e,!0)));return i([h]),{value:h,gradFunc:(p,m)=>{const[y]=m,b=!0,x=pi(y);return Ve(p,X(Me(p,e,b),x))}}})(t)}const _D=ne({logSoftmax_:NK});function AK(n,e=null,t=!1){const s=U(n,"x","logSumExp"),r=st(e,s.shape),i=Vr(s,r,!0),o=Ve(s,i),l=pi(o),c=Me(l,r),h=mi(c),d=ve(te(i,h.shape),h);if(t){const p=cn(d.shape,r);return te(d,p)}return d}const RD=ne({logSumExp_:AK});function _K(n,e){const t=U(n,"a","logicalAnd","bool"),s=U(e,"b","logicalAnd","bool");Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Rg,r)}const Gi=ne({logicalAnd_:_K});function RK(n){const t={x:U(n,"x","logicalNot","bool")};return J.runKernel(Dg,t)}const iS=ne({logicalNot_:RK});function DK(n,e){const t=U(n,"a","logicalOr","bool"),s=U(e,"b","logicalOr","bool");Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Og,r)}const DD=ne({logicalOr_:DK});function OK(n,e){const t=U(n,"a","logicalXor","bool"),s=U(e,"b","logicalXor","bool");return Ye(t.shape,s.shape),Gi(DD(n,e),iS(Gi(n,e)))}const MK=ne({logicalXor_:OK});function FK(n,e,t,s,r){const i=U(n,"x","maxPool"),o=1;let l=i,c=!1;i.rank===3&&(c=!0,l=te(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),L(Xn(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),bs("maxPool",s,r);const h={x:l},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r},p=J.runKernel(Lg,h,d);return c?te(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const oS=ne({maxPool_:FK});function LK(n,e=[1,1,1],t,s,r,i="NDHWC"){const o=U(n,"x","maxPool3d");let l=o,c=!1;o.rank===4&&(c=!0,l=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),L(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),bs("maxPool3d",s,r);const h={x:l},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},p=J.runKernel(Pg,h,d);return c?te(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const PK=ne({maxPool3d_:LK});function zK(n,e){let t=U(n,"a","maximum"),s=U(e,"b","maximum");[t,s]=tn(t,s),t.dtype==="bool"&&(t=Ee(t,"int32"),s=Ee(s,"int32")),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Ed,r)}const Xo=ne({maximum_:zK});function BK(n,e=null,t=!1){const r={x:U(n,"x","mean")},i={axis:e,keepDims:t};return J.runKernel(zg,r,i)}const ln=ne({mean_:BK});function In(n,e="float32"){if(Xi(n),e==="complex64"){const s=In(n,"float32"),r=In(n,"float32");return qa(s,r)}const t=qn(pe(n),e);return J.makeTensor(t,n,e)}function Yo(n,e="float32"){if(Xi(n),e==="complex64"){const s=Yo(n,"float32"),r=In(n,"float32");return qa(s,r)}const t=n1(pe(n),e);return J.makeTensor(t,n,e)}function VK(n,e){let t=U(n,"a","minimum"),s=U(e,"b","minimum");[t,s]=tn(t,s),t.dtype==="bool"&&(t=Ee(t,"int32"),s=Ee(s,"int32")),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(Id,r)}const zh=ne({minimum_:VK});function UK(n,e,t){L(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=U(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");L(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let l=0;l<s.rank;l++)L(e[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),L(e[l][0]>=0&&e[l][0]<=s.shape[l]-r&&e[l][1]>=0&&e[l][1]<=s.shape[l]-r,()=>`Padding in dimension ${l} cannot be greater than or equal to ${s.shape[l]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},o={x:s};return J.runKernel(Vg,o,i)}const jK=ne({mirrorPad_:UK});function GK(n,e){let t=U(n,"a","mod"),s=U(e,"b","mod");[t,s]=tn(t,s);const r={a:t,b:s};return J.runKernel(Nd,r)}const WK=ne({mod_:GK});function HK(n,e=null,t=!1){n=U(n,"x","moments");const s=st(e,n.shape),r=ln(n,s,t);let i=r.shape;t||(i=cn(r.shape,s));const o=Ft(Ve(Ee(n,"float32"),te(r,i))),l=ln(o,s,t);return{mean:r,variance:l}}const aS=ne({moments_:HK});function qK(n,e){let t=U(n,"a","notEqual","string_or_numeric"),s=U(e,"b","notEqual","string_or_numeric");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s};return J.runKernel(jg,r)}const Om=ne({notEqual_:qK});function KK(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:U(n,"indices","oneHot","int32")},l={dtype:r,depth:e,onValue:t,offValue:s};return J.runKernel(Wg,o,l)}const OD=ne({oneHot_:KK});function XK(n){const t={x:U(n,"x","onesLike")};return J.runKernel(Gg,t)}const vr=ne({onesLike_:XK});function YK(n,e,t=0){const s=U(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return J.runKernel(qg,i,r)}const lS=ne({pad_:YK});function JK(n,e,t){const s=U(n,"x","spaceToBatchND");L(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),L(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),L(s.shape.reduce((o,l,c)=>c>0&&c<=e.length?o&&(l+t[c-1][0]+t[c-1][1])%e[c-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return J.runKernel(s0,r,i)}const cS=ne({spaceToBatchND_:JK});function ZK(n,e,t,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const l=U(n,"x","maxPool");let c=l,h=!1;l.rank===3&&(h=!0,c=te(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(Xn(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=wr(c.shape,e,i,r,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=eX([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const y=p[0]===1&&p[1]===1,[b,x]=QK([d.inHeight,d.inWidth],p,m),w=y?s:"valid",S=y?c:cS(c,p,b),k=(t==="avg"?()=>Y1(S,e,i,w,o):()=>oS(S,e,i,w,o))(),$=y?k:J1(k,p,x);return h?te($,[$.shape[1],$.shape[2],$.shape[3]]):$}function QK(n,e,t){const s=t.map(d=>d[0]),r=t.map(d=>d[1]),i=n.concat(s,r),o=e.map((d,p)=>(d-i[p]%d)%d),l=r.map((d,p)=>d+o[p]),c=e.map((d,p)=>[s[p],l[p]]),h=e.map((d,p)=>[0,o[p]]);return[c,h]}function eX(n,e){const s=n.map((o,l)=>o+(o-1)*(e[l]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,l)=>o-r[l]);return s.map((o,l)=>[r[l],i[l]])}const tX=ne({pool_:ZK});function nX(n,e){const t=U(n,"x","prelu"),s=U(e,"alpha","prelu"),r={x:t,alpha:s};return J.runKernel(Kg,r)}const uS=ne({prelu_:nX});function sX(n,e=null,t=!1){let s=U(n,"x","prod");s.dtype==="bool"&&(s=Ee(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return J.runKernel(Xg,r,i)}const rX=ne({prod_:sX});var cm={exports:{}},iX=cm.exports,XI;function oX(){return XI||(XI=1,(function(n){(function(e,t,s){function r(c){var h=this,d=l();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(c),h.s0<0&&(h.s0+=1),h.s1-=d(c),h.s1<0&&(h.s1+=1),h.s2-=d(c),h.s2<0&&(h.s2+=1),d=null}function i(c,h){return h.c=c.c,h.s0=c.s0,h.s1=c.s1,h.s2=c.s2,h}function o(c,h){var d=new r(c),p=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,d),m.state=function(){return i(d,{})}),m}function l(){var c=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){c+=d.charCodeAt(p);var m=.02519603282416938*c;c=m>>>0,m-=c,m*=c,c=m>>>0,m-=c,c+=m*4294967296}return(c>>>0)*23283064365386963e-26};return h}t&&t.exports?t.exports=o:this.alea=o})(iX,n)})(cm)),cm.exports}var um={exports:{}},aX=um.exports,YI;function lX(){return YI||(YI=1,(function(n){(function(e,t,s){function r(l){var c=this,h="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=o:this.xor128=o})(aX,n)})(um)),um.exports}var hm={exports:{}},cX=hm.exports,JI;function uX(){return JI||(JI=1,(function(n){(function(e,t,s){function r(l){var c=this,h="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,d==h.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=o:this.xorwow=o})(cX,n)})(hm)),hm.exports}var dm={exports:{}},hX=dm.exports,ZI;function dX(){return ZI||(ZI=1,(function(n){(function(e,t,s){function r(l){var c=this;c.next=function(){var d=c.x,p=c.i,m,y;return m=d[p],m^=m>>>7,y=m^m<<24,m=d[p+1&7],y^=m^m>>>10,m=d[p+3&7],y^=m^m>>>3,m=d[p+4&7],y^=m^m<<7,m=d[p+7&7],m=m^m<<13,y^=m^m<<9,d[p]=y,c.i=p+1&7,y};function h(d,p){var m,y=[];if(p===(p|0))y[0]=p;else for(p=""+p,m=0;m<p.length;++m)y[m&7]=y[m&7]<<15^p.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(c,l)}function i(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.x&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=o:this.xorshift7=o})(hX,n)})(dm)),dm.exports}var fm={exports:{}},fX=fm.exports,QI;function pX(){return QI||(QI=1,(function(n){(function(e,t,s){function r(l){var c=this;c.next=function(){var d=c.w,p=c.X,m=c.i,y,b;return c.w=d=d+1640531527|0,b=p[m+34&127],y=p[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=p[m]=b^y,c.i=m,b+(d^d>>>16)|0};function h(d,p){var m,y,b,x,w,S=[],T=128;for(p===(p|0)?(y=p,p=null):(p=p+"\0",y=0,T=Math.max(T,p.length)),b=0,x=-32;x<T;++x)p&&(y^=p.charCodeAt((x+32)%p.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=S[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(S[(p&&p.length||0)&127]=-1),b=127,x=512;x>0;--x)y=S[b+34&127],m=S[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,S[b]=y^m;d.w=w,d.X=S,d.i=b}h(c,l)}function i(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.X&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=o:this.xor4096=o})(fX,n)})(fm)),fm.exports}var pm={exports:{}},mX=pm.exports,eN;function gX(){return eN||(eN=1,(function(n){(function(e,t,s){function r(l){var c=this,h="";c.next=function(){var p=c.b,m=c.c,y=c.d,b=c.a;return p=p<<25^p>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-p|0,c.b=p=p<<20^p>>>12^m,c.c=m=m-y|0,c.d=y<<16^m>>>16^b,c.a=b-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):h+=l;for(var d=0;d<h.length+20;d++)c.b^=h.charCodeAt(d)|0,c.next()}function i(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=o:this.tychei=o})(mX,n)})(pm)),pm.exports}var mm={exports:{}};const yX={},bX=Object.freeze(Object.defineProperty({__proto__:null,default:yX},Symbol.toStringTag,{value:"Module"})),xX=vB(bX);var vX=mm.exports,tN;function wX(){return tN||(tN=1,(function(n){(function(e,t,s){var r=256,i=6,o=52,l="random",c=s.pow(r,i),h=s.pow(2,o),d=h*2,p=r-1,m;function y($,E,N){var _=[];E=E==!0?{entropy:!0}:E||{};var R=S(w(E.entropy?[$,k(t)]:$??T(),3),_),D=new b(_),M=function(){for(var A=D.g(i),z=c,W=0;A<h;)A=(A+W)*r,z*=r,W=D.g(1);for(;A>=d;)A/=2,z/=2,W>>>=1;return(A+W)/z};return M.int32=function(){return D.g(4)|0},M.quick=function(){return D.g(4)/4294967296},M.double=M,S(k(D.S),t),(E.pass||N||function(A,z,W,Y){return Y&&(Y.S&&x(Y,D),A.state=function(){return x(D,{})}),W?(s[l]=A,z):A})(M,R,"global"in E?E.global:this==s,E.state)}function b($){var E,N=$.length,_=this,R=0,D=_.i=_.j=0,M=_.S=[];for(N||($=[N++]);R<r;)M[R]=R++;for(R=0;R<r;R++)M[R]=M[D=p&D+$[R%N]+(E=M[R])],M[D]=E;(_.g=function(A){for(var z,W=0,Y=_.i,K=_.j,P=_.S;A--;)z=P[Y=p&Y+1],W=W*r+P[p&(P[Y]=P[K=p&K+z])+(P[K]=z)];return _.i=Y,_.j=K,W})(r)}function x($,E){return E.i=$.i,E.j=$.j,E.S=$.S.slice(),E}function w($,E){var N=[],_=typeof $,R;if(E&&_=="object")for(R in $)try{N.push(w($[R],E-1))}catch{}return N.length?N:_=="string"?$:$+"\0"}function S($,E){for(var N=$+"",_,R=0;R<N.length;)E[p&R]=p&(_^=E[p&R]*19)+N.charCodeAt(R++);return k(E)}function T(){try{var $;return m&&($=m.randomBytes)?$=$(r):($=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues($)),k($)}catch{var E=e.navigator,N=E&&E.plugins;return[+new Date,e,N,e.screen,k(t)]}}function k($){return String.fromCharCode.apply(0,$)}if(S(s.random(),t),n.exports){n.exports=y;try{m=xX}catch{}}else s["seed"+l]=y})(typeof self<"u"?self:vX,[],Math)})(mm)),mm.exports}var _x,nN;function SX(){if(nN)return _x;nN=1;var n=oX(),e=lX(),t=uX(),s=dX(),r=pX(),i=gX(),o=wX();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=s,o.xor4096=r,o.tychei=i,_x=o,_x}var hS=SX();class MD{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=hS.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const l=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*l,t=this.mean+this.stdDev*i*l,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class CX{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=hS.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function TX(n,e=0,t=1,s,r){if(Xi(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new MD(e,t,s,!1,r),o=nt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const kX=ne({randomNormal_:TX});function $X(n,e=0,t=1,s="float32",r){Xi(n);const i=nt(n,s),o=new CX(e,t,null,r);for(let l=0;l<i.values.length;l++)i.values[l]=o.nextValue();return i.toTensor()}const ef=ne({randomUniform_:$X});function Bh(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return J.runKernel(M1,{},r)}function EX(n){const t={input:U(n,"input","real")};return J.runKernel(F1,t)}const Mm=ne({real_:EX});function IX(n){const t={x:U(n,"x","reciprocal")};return J.runKernel(Rd,t)}const NX=ne({reciprocal_:IX});function AX(n){const t={x:U(n,"x","relu")};return J.runKernel(Dd,t)}const ll=ne({relu_:AX});function _X(n){const t={x:U(n,"x","relu6")};return J.runKernel(Od,t)}const FD=ne({relu6_:_X});function RX(n,e){const s={x:U(n,"x","reverse")},r={dims:e};return J.runKernel(Qg,s,r)}const el=ne({reverse_:RX});function DX(n){const t={x:U(n,"x","round")};return J.runKernel(Md,t)}const LD=ne({round_:DX});function OX(n){const t={x:U(n,"x","rsqrt","float32")};return J.runKernel(Fd,t)}const PD=ne({rsqrt_:OX});function MX(n){const t={x:U(n,"x","selu")};return J.runKernel(Ld,t)}const zD=ne({selu_:MX});function FX(n,e,t,s,r,i=[1,1],o="NHWC"){const l=U(n,"x","separableConv2d"),c=U(e,"depthwiseFilter","separableConv2d"),h=U(t,"pointwiseFilter","separableConv2d");let d=l,p=!1;if(l.rank===3&&(p=!0,d=te(l,[1,l.shape[0],l.shape[1],l.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");L(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),L(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),L(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),L(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),L(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=c.shape[2],y=c.shape[3];L(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=eS(d,c,s,r,o,i),w=Za(b,h,1,"valid",o);return p?te(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const BD=ne({separableConv2d_:FX});function LX(n){const t={x:U(n,"x","sign")};return J.runKernel(Bd,t)}const PX=ne({sign_:LX});function zX(n){const t={x:U(n,"x","sin","float32")};return J.runKernel(Pd,t)}const VD=ne({sin_:zX});function BX(n){const t={x:U(n,"x","sinh")};return J.runKernel(zd,t)}const UD=ne({sinh_:BX});function VX(n,e,t){const s=U(n,"x","slice1d");return L(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Dt(s,[e],[t])}const dS=ne({slice1d_:VX});function UX(n,e,t){const s=U(n,"x","slice2d");return L(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Dt(s,e,t)}const jD=ne({slice2d_:UX});function jX(n,e,t){const s=U(n,"x","slice3d");return L(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Dt(s,e,t)}const fS=ne({slice3d_:jX});function GX(n,e,t){const s=U(n,"x","slice4d");return L(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Dt(s,e,t)}const Fm=ne({slice4d_:GX});function WX(n,e=-1){const t=U(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return J.runKernel(i0,s,r)}const pS=ne({softmax_:WX});function HX(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return J.runKernel(T1,e)}const GD=ne({fft_:HX});function qX(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return J.runKernel(E1,e)}const Hv=ne({ifft_:qX});function KX(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=te(n,[t,e]);s=Hv(r)}else{const r=[t,2*(e-1)],i=te(Mm(n),[t,e]),o=te(sS(n),[t,e]),l=el(Dt(i,[0,1],[t,e-2]),1),c=X(el(Dt(o,[0,1],[t,e-2]),1),bt(-1)),h=ms([i,l],1),d=ms([o,c],1),p=te(qa(h,d),[r[0],r[1]]);s=Hv(p)}if(s=Mm(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=te(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const XX=ne({irfft_:KX});function YX(n,e,t=0){const r={x:U(n,"x","split")},i={numOrSizeSplits:e,axis:t};return J.runKernel(r0,r,i)}const Ks=ne({split_:YX});function JX(n,e){L(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=e,r=Dt(n,b,x),t=e}else if(e!=null&&e>t){const b=n.shape.map(x=>x);b[n.shape.length-1]=e-t,r=ms([n,In(b)],n.shape.length-1),t=e}else r=n;const i=ht(r),o=te(qa(r,i),[s,t]),l=GD(o),c=Math.floor(t/2)+1,h=Mm(l),d=sS(l),p=Ks(h,[c,t-c],h.shape.length-1),m=Ks(d,[c,t-c],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=c,te(qa(p[0],m[0]),y)}const ZX=ne({rfft_:JX});function QX(n,e){let t=U(n,"a","squaredDifference"),s=U(e,"b","squaredDifference");[t,s]=tn(t,s),Ye(t.shape,s.shape);const r={a:t,b:s},i={};return J.runKernel(Gd,r,i)}const e9=ne({squaredDifference_:QX});function t9(n,e){const t=U(n,"x","squeeze","string_or_numeric");return te(t,Go(t.shape,e).newShape)}const tf=ne({squeeze_:t9});function n9(n,e=0){const t=hD(n,"tensors","stack","string_or_numeric");L(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&L(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return J.runKernel(Hg,s,r)}const Wi=ne({stack_:n9});function s9(n,e=0){const s={x:U(n,"x","step")},r={alpha:e};return J.runKernel(Xd,s,r)}const nf=ne({step_:s9});function r9(n,e,t,s,r=0,i=0,o=0,l=0,c=0){const d={x:U(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};return J.runKernel(V1,d,p)}const i9=ne({stridedSlice_:r9});function o9(n){const t={x:U(n,"x","tan","float32")};return J.runKernel(Hd,t)}const a9=ne({tan_:o9});function Ns(n,e){t1(n);const t=Yd(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Jd(n,null,t,e)}function Rx(n,e,t){if(t1(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Yd(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Jd(n,e,s,t)}function l9(n,e,t){if(t1(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Yd(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Jd(n,e,s,t)}function WD(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function c9(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}WD(t,e,n)}function cl(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let o=1;for(let p=r;p<i;++p)o*=t[p];const l=r<1?1:r,c=pe(e.shape)/l,h=[...Oe(t.slice(0,r)),1],d=pe(t);return{sliceRank:r,numUpdates:c,sliceSize:o,strides:h,outputSize:d}}function u9(n,e=1,t=!0){const s=U(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:t},[l,c]=J.runKernel(U1,i,o);return{values:l,indices:c}}const h9=ne({topk_:u9});function d9(n,e=0,t=1,s,r){if(Xi(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new MD(e,t,s,!0,r),o=nt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const HD=ne({truncatedNormal_:d9});function f9(n,e=0){const t=U(n,"x","unique","string_or_numeric");L(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,o]=J.runKernel(G1,s,r);return{values:i,indices:o}}const p9=ne({unique_:f9});function m9(n,e,t){const s=U(n,"x","unsortedSegmentSum"),r=U(e,"segmentIds","unsortedSegmentSum","int32");L(_c(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:t};return J.runKernel(a0,i,o)}const qD=ne({unsortedSegmentSum_:m9});function g9(n,e=0){const t=U(n,"x","unstack","string_or_numeric");L(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return J.runKernel(o0,s,r)}const tl=ne({unstack_:g9});function y9(n,e=!0,t,s){return J.makeVariable(n,e,t,s)}function KD(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=nt(n,"int32"),r=nt([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=s.indexToLoc(t[i]),l=i*n.length;r.values.set(o,l)}return r.toTensor()}function b9(n,e,t){const s=U(n,"x","transpose");if(e==null&&(e=s.shape.map((o,l)=>l).reverse()),L(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{L(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?ie(()=>{let o=Mm(s),l=sS(s);return o=J.runKernel(kc,{x:o},i),l=J.runKernel(kc,{x:l},i),t&&(l=en(l)),qa(o,l)}):J.runKernel(kc,r,i)}const ut=ne({transpose_:b9});function x9(n,e){if(e==null)return n.shape.slice();if(xt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function v9(n,e,t,s){const r=U(n,"x","dropout");if(L(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),L(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof gn?r.clone():r;const i=x9(r,t),o=1-e,l=Le(m0(ve(ef(i,0,1,"float32",s),o)),o);return X(r,l)}const w9=ne({dropout_:v9});function S9(n,e,t,s,r,i="NHWC",o){let l=n;n.rank===3&&(l=te(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=te(e,[1,e.shape[0],e.shape[1],e.shape[2]])),L(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),L(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),L(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const h=i==="NHWC"?l.shape[3]:l.shape[1],d=i==="NHWC"?c.shape[3]:c.shape[1];L(h===t[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${t[2]}.`),L(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),bs("conv2dDerFilter",r,o);const p={x:l,dy:c},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:t};return J.runKernel(f1,p,m)}const mS=ne({conv2DBackpropFilter_:S9});function gS(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return X(n,nf(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function yS(n,e){let t=e;const s=wn(n.shape,e.shape);return s.length>0&&(t=Me(t,s)),te(t,n.shape)}function bS(n,e,t,s){if(e==="linear")return n;if(e==="relu")return ll(n);if(e==="elu")return f0(n);if(e==="relu6")return FD(n);if(e==="prelu")return uS(n,t);if(e==="leakyrelu")return rS(n,s);if(e==="sigmoid")return Kc(n);throw new Error(`Unknown fused activation ${e}.`)}const xS=(n,e)=>!(n>0)||e==="linear";function C9({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:c="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(c=c||"linear",xS(J.state.gradientDepth,c)===!1){L(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=Za(n,e,t,s,r,i,o);return l!=null&&(N=ve(N,l)),bS(N,c,h,d)}const p=U(n,"x","conv2d","float32"),m=U(e,"filter","conv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=te(p,[1,p.shape[0],p.shape[1],p.shape[2]])),L(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),L(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),bs("fused conv2d",s,o);const x=r==="NHWC"?y.shape[3]:y.shape[1];L(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),L(Xn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const w=Mn(y.shape,m.shape,t,i,s,o);let S;l!=null&&(S=U(l,"bias","fused conv2d"),[S]=tn(S,p),r==="NHWC"?Ye(w.outShape,S.shape):(L(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),L(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let T;if(h!=null){const N=h.shape;if(L(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)L(N[0]===1||N[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${w.outChannels}).`);else if(N.length===3)try{Ye(N,w.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(R)}T=U(h,"prelu weights","fused conv2d")}const k=(N,_)=>{L(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,D,M,A]=_,z=gS(N,M,c);L(Ya(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const W=Z1(D.shape,z,R,t,s),Y=mS(D,z,R.shape,t,s),K=[W,Y];if(A!=null){const P=yS(A,z);K.push(P)}return K},$={x:y,filter:m,bias:S,preluActivationWeights:T},E={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:c,leakyreluAlpha:d};return l==null?Mc((_,R,D)=>{let M=J.runKernel(Im,$,E);return D([R,_,M]),b&&(M=te(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:k}})(y,m):Mc((_,R,D,M)=>{let A=J.runKernel(Im,$,E);return M([R,_,A,D]),b&&(A=te(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:k}})(y,m,S)}const T9=ne({fusedConv2d_:C9});function k9(n,e,t,s,r,i=[1,1],o){let l=n;n.rank===3&&(l=te(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={x:l,dy:c},d={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:t};return J.runKernel(v1,h,d)}const $9=ne({depthwiseConv2dNativeBackpropFilter_:k9});function E9(n,e,t,s,r,i=[1,1],o){let l=e,c=!1;e.rank===3&&(c=!0,l=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:l,filter:t},d={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},p=J.runKernel(w1,h,d);return c?te(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const I9=ne({depthwiseConv2dNativeBackpropInput_:E9});function N9({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}){if(xS(J.state.gradientDepth,i)===!1){let A=yt(n,e,t,s);return r!=null&&(A=ve(A,r)),bS(A,i,o,l)}let c=U(n,"a","fused matMul"),h=U(e,"b","fused matMul");[c,h]=tn(c,h);const d=t?c.shape[c.rank-2]:c.shape[c.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=t?c.shape[c.rank-1]:c.shape[c.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=c.shape.slice(0,-2),x=h.shape.slice(0,-2),w=pe(b),S=pe(x);L(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${c.shape} and ${h.shape} and transposeA=${t} and transposeB=${s} must match.`);const k=Ye(c.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),$=t?te(c,[w,d,m]):te(c,[w,m,d]),E=s?te(h,[S,y,p]):te(h,[S,p,y]);let N;r!=null&&(N=U(r,"bias","fused matMul"),[N]=tn(N,c),Ye(k,N.shape));let _;o!=null&&(_=U(o,"prelu weights","fused matMul"));const R=(A,z)=>{const[W,Y,K,P]=z,B=gS(te(A,K.shape),K,i);let G,ee;if(!t&&!s?(G=yt(B,Y,!1,!0),ee=yt(W,B,!0,!1)):!t&&s?(G=yt(B,Y,!1,!1),ee=yt(B,W,!0,!1)):t&&!s?(G=yt(Y,B,!1,!0),ee=yt(W,B,!1,!1)):(G=yt(Y,B,!0,!0),ee=yt(B,W,!0,!0)),r!=null){const Z=yS(P,B);return[G,ee,Z]}else return[G,ee]},D={a:$,b:E,bias:N,preluActivationWeights:_},M={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:l};return r==null?Mc((z,W,Y)=>{const K=J.runKernel(Em,D,M);return Y([z,W,K]),{value:te(K,k),gradFunc:R}})($,E):Mc((z,W,Y,K)=>{const P=J.runKernel(Em,D,M);return K([z,W,P,Y]),{value:te(P,k),gradFunc:R}})($,E,N)}const sN=ne({fusedMatMul_:N9});function A9(n,e,t,s,r="bilinear",i=0){const o=U(n,"image","cropAndResize"),l=U(e,"boxes","cropAndResize","float32"),c=U(t,"boxInd","cropAndResize","int32"),h=l.shape[0];L(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),L(l.rank===2&&l.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${l.shape}.`),L(c.rank===1&&c.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${l.shape}.`),L(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),L(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),L(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:o,boxes:l,boxInd:c},p={method:r,extrapolationValue:i,cropSize:s};return J.runKernel(y1,d,p)}const _9=ne({cropAndResize_:A9});function R9(n){const e=U(n,"image","flipLeftRight","float32");L(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return J.runKernel($1,t,{})}const D9=ne({flipLeftRight_:R9});function O9(n){const e=U(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];L(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),L(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,zr(e,r)}const M9=ne({grayscaleToRGB_:O9});function F9(n){const e=U(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];L(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),L(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=Ee(e,"float32"),o=Ns([.2989,.587,.114]);let l;switch(e.rank){case 2:l=sh("ij,j->i",i,o);break;case 3:l=sh("ijk,k->ij",i,o);break;case 4:l=sh("ijkl,l->ijk",i,o);break;case 5:l=sh("ijklm,m->ijkl",i,o);break;case 6:l=sh("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return l=ds(l,-1),Ee(l,r)}const L9=ne({rgbToGrayscale_:F9});function P9(n,e,t=0,s=.5){const r=U(n,"image","rotateWithOffset","float32");L(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:t,center:s};return J.runKernel(W1,i,o)}const z9=ne({rotateWithOffset_:P9});function Yc(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),L(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),L(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),L(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),L(e.rank===1,()=>"scores must be a 1D tensor"),L(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),L(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function B9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppression","float32"),o=U(e,"scores","nonMaxSuppression","float32"),l=Yc(i,o,t,s,r);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return J.runKernel(R1,{boxes:i,scores:o},c)}const V9=ne({nonMaxSuppression_:B9});function U9(n,e,t){const s=j9(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function j9(n,e,t){return W9(n,e,t||G9)}function G9(n,e){return n>e?1:n<e?-1:0}function W9(n,e,t){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const l=t(e,n[i]);l>0?s=i+1:(r=i,o=!l)}return o?s:-s-1}function vS(n,e,t,s,r){return CS(n,e,t,s,r,0)}function wS(n,e,t,s,r,i){return CS(n,e,t,s,r,0,!1,i,!0)}function SS(n,e,t,s,r,i){return CS(n,e,t,s,r,i,!0)}function CS(n,e,t,s,r,i,o=!1,l=!1,c=!1){const h=[];for(let w=0;w<e.length;w++)e[w]>r&&h.push({score:e[w],boxIndex:w,suppressBeginIndex:0});h.sort(rN);const d=i>0?-.5/i:0,p=[],m=[];for(;p.length<t&&h.length>0;){const w=h.pop(),{score:S,boxIndex:T,suppressBeginIndex:k}=w;if(S<r)break;let $=!1;for(let E=p.length-1;E>=k;--E){const N=H9(n,T,p[E]);if(N>=s){$=!0;break}if(w.score=w.score*q9(s,d,N),w.score<=r)break}w.suppressBeginIndex=p.length,$||(w.score===S?(p.push(T),m.push(w.score)):w.score>r&&U9(h,w,rN))}const y=p.length,b=t-y;l&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:p};return o&&(x.selectedScores=m),c&&(x.validOutputs=y),x}function H9(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(l-i)*(c-o),b=(p-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(i,h),w=Math.max(o,d),S=Math.min(l,p),T=Math.min(c,m),k=Math.max(S-x,0)*Math.max(T-w,0);return k/(y+b-k)}function q9(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function rN(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function K9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),l=Yc(i,o,t,s,r);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const c=await Promise.all([i.data(),o.data()]),h=c[0],d=c[1],{selectedIndices:p}=vS(h,d,t,s,r);return i!==n&&i.dispose(),o!==e&&o.dispose(),Ns(p,"int32")}const X9=K9;function Y9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=U(n,"boxes","nonMaxSuppression"),l=U(e,"scores","nonMaxSuppression"),c=Yc(o,l,t,s,r,i);t=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,i=c.softNmsSigma;const h={boxes:o,scores:l},d={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},p=J.runKernel(O1,h,d);return{selectedIndices:p[0],selectedScores:p[1]}}const J9=ne({nonMaxSuppressionWithScore_:Y9});async function Z9(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=U(n,"boxes","nonMaxSuppressionAsync"),l=U(e,"scores","nonMaxSuppressionAsync"),c=Yc(o,l,t,s,r,i);t=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,i=c.softNmsSigma;const h=await Promise.all([o.data(),l.data()]),d=h[0],p=h[1],{selectedIndices:m,selectedScores:y}=SS(d,p,t,s,r,i);return o!==n&&o.dispose(),l!==e&&l.dispose(),{selectedIndices:Ns(m,"int32"),selectedScores:Ns(y)}}const Q9=Z9;function e7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=U(n,"boxes","nonMaxSuppression"),l=U(e,"scores","nonMaxSuppression"),c=Yc(o,l,t,s,r,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,m={boxes:o,scores:l},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:i},b=J.runKernel(D1,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const t7=ne({nonMaxSuppressionPadded_:e7});async function n7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=U(n,"boxes","nonMaxSuppressionAsync"),l=U(e,"scores","nonMaxSuppressionAsync"),c=Yc(o,l,t,s,r,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,[m,y]=await Promise.all([o.data(),l.data()]),{selectedIndices:b,validOutputs:x}=wS(m,y,h,d,p,i);return o!==n&&o.dispose(),l!==e&&l.dispose(),{selectedIndices:Ns(b,"int32"),validOutputs:bt(x,"int32")}}const s7=n7;function r7(n,e,t=!1,s=!1){const r=U(n,"images","resizeBilinear");L(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),L(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),L(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=te(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},c={alignCorners:t,halfPixelCenters:s,size:e},h=J.runKernel(Zg,l,c);return o?te(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const XD=ne({resizeBilinear_:r7});function i7(n,e,t=!1,s=!1){const r=U(n,"images","resizeNearestNeighbor");L(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),L(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),L(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),L(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=te(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},c={alignCorners:t,halfPixelCenters:s,size:e},h=J.runKernel(Jg,l,c);return o?te(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const YD=ne({resizeNearestNeighbor_:i7});function o7(n,e="binary",t=!1,s=.5){const r=U(n,"image","threshold"),i=.2989,o=.587,l=.114,c=r.shape[0]*r.shape[1];let h=X(Ns([s]),255),d,p,m,y;if(L(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),L(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),L(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),L(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,p,m]=Ks(r,[1,1,1],-1);const w=X(d,i),S=X(p,o),T=X(m,l);y=ve(ve(w,S),T)}else y=n;if(e==="otsu"){const w=n8(Ee(LD(y),"int32"),wh([]),256);h=a7(w,c)}const b=t?Xc(y,h):Ys(y,h);return Ee(X(b,255),"int32")}function a7(n,e){let t=Ns([-1]),s=Ns([0]),r=Ns([0]),i,o,l,c,h,d;for(let p=0;p<n.size-1;p++){i=Dt(n,0,p+1),o=Dt(n,p+1),h=Le(Me(i),e),d=Le(Me(o),e);const m=Me(X(i,Bh(0,i.size)));l=Le(m,Me(i));const y=d0(o.shape,i.size),b=ve(Bh(0,o.size),y),x=X(o,b);c=Le(Me(x),Me(o));const w=Ve(l,c),S=Ve(l,c),T=X(h,d);r=X(X(T,w),S);const k=Ys(r,s);s=ss(k,r,s),t=ss(k,Ns([p]),t)}return t}const l7=ne({threshold_:o7});function c7(n,e,t="nearest",s="constant",r=0,i){const o=U(n,"image","transform","float32"),l=U(e,"transforms","transform","float32");L(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),L(l.rank===2&&(l.shape[0]===o.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),L(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const c={image:o,transforms:l},h={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return J.runKernel(j1,c,h)}const u7=ne({transform_:c7});function h7(n,e,t){const s=U(n,"a","bandPart");L(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let l,c;typeof e=="number"?(L(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),L(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),l=U(e<0?i:e,"numLower","bandPart")):(L(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),l=ss(Dm(e,0),i,zh(e,i))),typeof t=="number"?(L(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),L(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),c=U(t<0?o:t,"numUpper","bandPart")):(L(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=ss(Dm(t,0),o,zh(t,o)));const h=te(Bh(0,i,1,"int32"),[-1,1]),d=Bh(0,o,1,"int32"),p=Ve(h,d),m=Gi(Xc(p,l),al(p,en(c))),y=In([i,o],s.dtype);return te(Wi(tl(te(s,[-1,i,o])).map(b=>ss(m,b,y))),r)}const d7=ne({bandPart_:h7});function f7(n){let e;if(Array.isArray(n)){e=!1,L(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)L(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=Ks(n,n.shape[0],0).map(r=>tf(r,[0]));L(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(J.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const l=X(Me(X(t[o],i)),t[o]);i=Ve(i,l)}return Le(i,p0(i,"euclidean"))}));return e?Wi(t,0):t}const p7=ne({gramSchmidt_:f7});function m7(n,e=!1){if(L(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return iN(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((c,h)=>c*h),s=tl(te(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(c=>{const[h,d]=iN(c,e);r.push(h),i.push(d)});const o=te(Wi(r,0),n.shape),l=te(Wi(i,0),n.shape);return[o,l]}}function iN(n,e=!1){return J.tidy(()=>{L(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=ND(t),i=Ua(n);const o=Rx([[1]],[1,1]);let l=Ua(o);const c=t>=s?s:t;for(let h=0;h<c;++h){const d=i,p=l,m=r;[l,i,r]=J.tidy(()=>{const y=Dt(i,[h,h],[t-h,1]),b=p0(y),x=Dt(i,[h,h],[1,1]),w=ss(Ys(x,0),Rx([[-1]]),Rx([[1]])),S=Ve(x,X(w,b)),T=Le(y,S);T.shape[0]===1?l=Ua(o):l=ms([o,Dt(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const k=en(Le(yt(w,S),b)),$=Dt(i,[h,0],[t-h,s]),E=X(k,l),N=ut(l);if(h===0)i=Ve($,yt(E,yt(N,$)));else{const D=Ve($,yt(E,yt(N,$)));i=ms([Dt(i,[0,0],[h,s]),D],0)}const _=ut(E),R=Dt(r,[0,h],[t,r.shape[1]-h]);if(h===0)r=Ve(R,yt(yt(R,l),_));else{const D=Ve(R,yt(yt(R,l),_));r=ms([Dt(r,[0,0],[t,h]),D],1)}return[l,i,r]}),tt([d,p,m])}return!e&&t>s&&(r=Dt(r,[0,0],[t,s]),i=Dt(i,[0,0],[s,s])),[r,i]})}const g7=ne({qr_:m7});const Vi={flipLeftRight:D9,grayscaleToRGB:M9,resizeNearestNeighbor:YD,resizeBilinear:XD,rgbToGrayscale:L9,rotateWithOffset:z9,cropAndResize:_9,nonMaxSuppression:V9,nonMaxSuppressionAsync:X9,nonMaxSuppressionWithScore:J9,nonMaxSuppressionWithScoreAsync:Q9,nonMaxSuppressionPadded:t7,nonMaxSuppressionPaddedAsync:s7,threshold:l7,transform:u7},y7={bandPart:d7,gramSchmidt:p7,qr:g7};const b7=new Map,x7=new Map;class Jc{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class pr{constructor(){this.classNameMap={}}static getMap(){return pr.instance==null&&(pr.instance=new pr),pr.instance}static register(e){pr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function xe(n,e,t){L(n.className!=null,()=>"Class being registered does not have the static className property defined."),L(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),L(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return pr.register(n),b7.set(r,n),x7.set(n,r),n}class Jo extends Jc{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const o=s.map(l=>({name:l.name,tensor:i[l.name]}));this.applyGradients(o)}else this.applyGradients(i);return tt(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return CK(e,t)}dispose(){this.iterations_!=null&&tt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:bt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Jo,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class JD extends Jo{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=J.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:ie(()=>ht(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:ie(()=>ht(i).variable(o))});const l=Array.isArray(e)?e[r].tensor:e[s];if(l==null)return;const c=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;ie(()=>{const d=ve(X(c,this.rho),X(Ft(l),1-this.rho)),p=X(Le(Kn(ve(h,this.epsilon)),Kn(ve(c,this.epsilon))),l),m=ve(X(h,this.rho),X(Ft(p),1-this.rho));c.assign(d),h.assign(m);const y=ve(X(p,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(tt(this.accumulatedGrads.map(e=>e.variable)),tt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class ZD extends Jo{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=J.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:ie(()=>d0(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[r].variable;ie(()=>{const c=ve(l,Ft(o));l.assign(c);const h=ve(X(Le(o,Kn(ve(c,J.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&tt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class QD extends Jo{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ie(()=>{this.accBeta1=bt(t).variable(),this.accBeta2=bt(s).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ie(()=>{const s=Ve(1,this.accBeta1),r=Ve(1,this.accBeta2);t.forEach((i,o)=>{const l=J.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ie(()=>ht(l).variable(c))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:ie(()=>ht(l).variable(c))});const h=Array.isArray(e)?e[o].tensor:e[i];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedSecondMoment[o].variable,m=ve(X(d,this.beta1),X(h,1-this.beta1)),y=ve(X(p,this.beta2),X(Ft(h),1-this.beta2)),b=Le(m,s),x=Le(y,r);d.assign(m),p.assign(y);const w=ve(X(Le(b,ve(Kn(x),this.epsilon)),-this.learningRate),l);l.assign(w)}),this.accBeta1.assign(X(this.accBeta1,this.beta1)),this.accBeta2.assign(X(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&tt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&tt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ie(()=>{this.accBeta1.assign(Qa(this.beta1,this.iterations_+1)),this.accBeta2.assign(Qa(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class eO extends Jo{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ie(()=>{this.iteration=bt(0).variable(),this.accBeta1=bt(t).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ie(()=>{const s=Ve(1,this.accBeta1),r=Le(-this.learningRate,ve(X(this.iteration,this.decay),1));t.forEach((i,o)=>{const l=J.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ht(l).variable(c)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:ht(l).variable(c)});const h=Array.isArray(e)?e[o].tensor:e[i];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedWeightedInfNorm[o].variable,m=ve(X(d,this.beta1),X(h,1-this.beta1)),y=X(p,this.beta2),b=Qn(h),x=Xo(y,b);d.assign(m),p.assign(x);const w=ve(X(Le(r,s),Le(m,ve(x,this.epsilon))),l);l.assign(w)}),this.iteration.assign(ve(this.iteration,1)),this.accBeta1.assign(X(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&tt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&tt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class TS extends Jo{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=J.registeredVariables[s];ie(()=>{const l=ve(X(this.c,i),o);o.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=li(bt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class tO extends TS{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=bt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=J.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:ie(()=>ht(i).variable(!1))});const o=this.accumulations[r].variable,l=Array.isArray(e)?e[r].tensor:e[s];l!=null&&ie(()=>{let c;const h=ve(X(this.m,o),l);this.useNesterov?c=ve(X(this.c,ve(l,X(h,this.m))),i):c=ve(X(this.c,h),i),o.assign(h),i.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&tt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class nO extends Jo{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=J.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=J.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:ie(()=>ht(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:ie(()=>ht(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:ie(()=>ht(i).variable(o))});const l=Array.isArray(e)?e[r].tensor:e[s];if(l==null)return;const c=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;ie(()=>{const d=ve(X(c,this.decay),X(Ft(l),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,m=ve(X(p,this.decay),X(l,1-this.decay)),y=Le(X(l,this.learningRate),Kn(Ve(d,ve(Ft(m),this.epsilon)))),b=ve(X(h,this.momentum),y);c.assign(d),p.assign(m),h.assign(b);const x=Ve(i,b);i.assign(x)}else{const p=ve(X(c,this.decay),X(Ft(l),1-this.decay)),m=ve(X(h,this.momentum),Le(X(l,this.learningRate),Kn(ve(p,this.epsilon))));c.assign(p),h.assign(m);const y=Ve(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&tt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&tt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&tt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const v7=[JD,ZD,QD,eO,tO,nO,TS];function w7(){for(const n of v7)xe(n)}function oN(n,e,t,s){o(n),t=t??0,s=s??1,l(t,s);let r=0;const i=c=>(c.then(h=>{const d=t+ ++r/n.length*(s-t);return e(d),h}),c);function o(c){L(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function l(c,h){L(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),L(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),L(h>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${h}`)}return Promise.all(n.map(i))}async function S7(n,e){e==null&&(e={});const t=e.fetchFunc==null?ce().platform.fetch:e.fetchFunc,s=n.map(p=>t(p,e.requestInit,{isBinary:!0})),l=(e.onProgress==null?await Promise.all(s):await oN(s,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(l):await oN(l,e.onProgress,.5,1)}function C7(n,e){var t;const s=e.fetchFunc==null?ce().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var l;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:c,value:h}=await i.read();if(c){r++,i=void 0,(l=e.onProgress)===null||l===void 0||l.call(e,r/n.length);continue}o.enqueue(h);return}o.close()}})}const T7="application/octet-stream",k7="application/json";class kS{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(L(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ce().platform.fetch,L(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&L(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=F6(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:k7}),"model.json"),e.weightData!=null){const o=Ho.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:T7}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:K1(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return P6(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=HI(e.weightsManifest),r=()=>C7(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=$7(t),i=this.weightPathPrefix||s,o=[],l=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):o.push(i+h+r);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(e){const t=await this.getWeightUrls(e),s=HI(e),r=await S7(t,this.loadOptions);return[s,r]}}kS.URL_SCHEME_REGEX=/^https?:\/\//;function $7(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function aN(n){return n.match(kS.URL_SCHEME_REGEX)!=null}const sO=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>aN(s)):t=aN(n),t)return rO(n,e)}return null};$n.registerSaveRouter(sO);$n.registerLoadRouter(sO);function rO(n,e){return new kS(n,e)}function E7(n,e){return rO(n,e)}class Dx{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class I7{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function N7(n,e,t,s){const r=arguments;return new I7(A7(...r))}function A7(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Dx(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Dx({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Dx({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function $S(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(pe(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let p=0;p<r.length-1;++p)o*=r[p];const l=n.shape,c=r.slice();c.pop();let h=1;for(let p=i;p<t;++p)h*=l[p],c.push(l[p]);const d=[...Oe(n.shape).map(p=>p/h),1].slice(0,i);return[c,o,h,d]}const qv=-2,_7=-1;function ES(n,e,t){const s=n.shape.length;L(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),L(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)L(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function R7(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function IS(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function iO(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function oO(n,e,t){return t<=n?t:t-(e-1)}function aO(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function D7(n,e,t,s,r,i,o,l,c){const h=n.length;let d=new Array(h),p=new Array(h),m=new Array(h);if(e.length&&t>0){const y=e[0],b=t+1;d=lO(o,y,b,s,n),p=cO(l,y,b,r,n),m=iO(i,y,b,n)}else for(let y=0;y<h;y++)d[y]=hO(o,s,i,n,y,c),p[y]=dO(l,r,i,n,y,c),m[y]=uO(i,y,c);return{begin:d,end:p,strides:m}}function lO(n,e,t,s,r){const i=[...r],o=aO(t,e);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=0;else{const c=oO(e,t,l);let h=s[c];n&1<<c&&(h=0),i[l]=h}return i}function cO(n,e,t,s,r){const i=[...r],o=aO(t,e);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=Number.MAX_SAFE_INTEGER;else{const c=oO(e,t,l);let h=s[c];n&1<<c&&(h=Number.MAX_SAFE_INTEGER),i[l]=h}for(let l=0;l<i.length;l++){const c=r[l];i[l]<0&&(i[l]+=c),i[l]=Wa(0,i[l],r[l])}return i}function uO(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function hO(n,e,t,s,r,i){let o=e[r];const l=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),o=Wa(0,o,c-1),o}function dO(n,e,t,s,r,i){let o=e[r];const l=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),l>0?o=Wa(0,o,c):o=Wa(-1,o,c-1),o}function NS(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function AS(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function g0(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{L(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((o,l)=>o>=0?o:(L(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,i]}function _S(n,e,t,s,r,i,o,l,c){let h;if(s==null?(h=new Array(e.length),h.fill(1)):h=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:h.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};for(let k=0;k<p.dims;k++)d&&(1<<k&l)!==0&&p.numAddAxisAfterEllipsis++,1<<k&o&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};O7(p,m);let y=!0,b=!0,x=!0;const w=[],S=[];for(let k=0;k<n.length;++k){if(m.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);const $=!!(m.shrinkAxisMask&1<<k),E=n[k];if(E===-1){w.push($?1:-1);continue}const N=[m.beginMask&1<<k,m.endMask&1<<k],_=[m.strides[k]>0?0:-1,m.strides[k]>0?E:E-1];if($&&m.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[k]===1;const R=!!(m.beginMask&1<<k&&m.endMask&1<<k);if(m.beginValid&&m.endValid){if($){const z=m.begin[k]<0?E+m.begin[k]:m.begin[k];if(m.begin[k]=z,m.end[k]=m.begin[k]+1,z<0||z>=E)throw Error(`slice index ${m.begin[k]} of dimension ${k} out of bounds.`)}else m.begin[k]=lN(m.begin[k],0,m.strides[k],E,N,_),m.end[k]=lN(m.end[k],1,m.strides[k],E,N,_);const A=m.strides[k]===1&&m.begin[k]===0&&m.end[k]===E;y=y&&A,b=b&&(k===0&&m.strides[k]===1||A)}else y=y&&m.strides[k]===1&&R,b=b&&(k===0&&m.strides[k]===1||R);let D,M=!1;if(m.beginValid&&m.endValid?(D=m.end[k]-m.begin[k],M=!0):$?(D=1,M=!0):R&&E>=0&&(m.strides[k]<0?D=-E:D=E,M=!0),M){let A;D===0||D<0!=m.strides[k]<0?A=0:A=Math.trunc(D/m.strides[k])+(D%m.strides[k]!==0?1:0),w.push(A)}else w.push(-1)}for(let k=0;k<m.finalShapeGatherIndices.length;++k){const $=m.finalShapeGatherIndices[k];$>=0?S.push(w[$]):$===qv&&S.push(1)}return{finalShapeSparse:S.filter((k,$)=>m.finalShapeGatherIndices[$]!==qv),finalShape:S,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function O7(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(qv),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(_7),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function lN(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const M7=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ES,computeFlatOffset:AS,computeOutShape:IS,getNormalizedAxes:D7,isSliceContinous:NS,maskToAxes:R7,parseSliceParams:g0,sliceInfo:_S,startForAxis:hO,startIndicesWithElidedDims:lO,stopForAxis:dO,stopIndicesWithElidedDims:cO,stridesForAxis:uO,stridesWithElidedDims:iO},Symbol.toStringTag,{value:"Module"}));class F7{static sgd(e){return new TS(e)}static momentum(e,t,s=!1){return new tO(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new nO(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new QD(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new JD(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new eO(e,t,s,r,i)}static adagrad(e,t=.1){return new ZD(e,t)}}const ac=F7;const L7=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function fO(){return new Promise(n=>L7(()=>n()))}function RS(n,e){const t=n[0].length;n.forEach((r,i)=>{L(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),L(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<t;o++)L(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function ci(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var Pr;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Pr||(Pr={}));function pO(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],o=s[s.length-t.length+r],l=s[o];if(i>=0)if(l>=0){if(l!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${l}`)}else s[o]=i}return s}function mO(n){const e={FIRST_DIM_SIZE:Pr.FIRST_DIM_SIZE,VALUE_ROWIDS:Pr.VALUE_ROWIDS,ROW_LENGTHS:Pr.ROW_LENGTHS,ROW_SPLITS:Pr.ROW_SPLITS,ROW_LIMITS:Pr.ROW_LIMITS,ROW_STARTS:Pr.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function gO(n){return n.length===0?0:n[0]===Pr.FIRST_DIM_SIZE?n.length-1:n.length}function yO(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],o=e[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const DS=30;function y0(n){return n<=DS?n:_v(n,Math.floor(Math.sqrt(n)))}function OS(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function sf(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(i+1))}return r}function rf(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function of(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function MS(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function FS(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const b0=1.7580993408473768,x0=1.0507009873554805;const LS=.3275911,PS=.254829592,zS=-.284496736,BS=1.421413741,VS=-1.453152027,US=1.061405429;function Hi(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function bO(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function xO(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function vO(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function jS(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function wO(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function SO(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function CO(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const Ox="->",P7=/->/g,cN=",",uN="...";function GS(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(P7,"").length)/Ox.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Ox}").`);const[s,r]=n.split(Ox);L(s.indexOf(uN)===-1,()=>`The ellipsis notation ("${uN}") is not supported yet.`);const i=s.split(cN),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);l.indexOf(y)===-1&&l.push(y)}for(let m=0;m<s.length;++m){const y=s[m];l.indexOf(y)===-1&&y!==cN&&l.push(y)}const c=new Array(i.length);for(let m=0;m<o;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);c[m]=[];for(let y=0;y<i[m].length;++y)c[m].push(l.indexOf(i[m][y]))}const h=l.length,d=r.length,p=[];for(let m=d;m<h;++m)p.push(m);return{allDims:l,summedDims:p,idDims:c}}function WS(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function HS(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:L(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function qS(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<t.length;++o){const l=t[o],c=z7(e,l);for(const h of c)i.indexOf(h)===-1&&(s[o].push(h),i.push(h))}return{path:t,steps:s}}function KS(n){return n.every((e,t)=>e===t)}function z7(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function XS(n,e,t=0){let s=[];if(typeof e=="number")L(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,l)=>(l===-1&&(o+=1),o),0);L(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((l,c)=>c>0?l+c:l);e[i]=n.shape[t]-o}L(n.shape[t]===e.reduce((o,l)=>o+l),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function TO(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function kO(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function $O(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function EO(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function IO(n,e){return`size ${n} must be non-negative, not ${e}`}function NO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function AO(n,e){const t=pe(n),s=pe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function _O(n,e){const t=pe(n),s=pe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function Kv(){return"segment ids must be >= 0"}function RO(){return"segment ids are not increasing"}function DO(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function OO(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function MO(n,e){let t=!1,s;for(n<=DS?(s=n,t=!0):s=_v(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=_v(n,s+1);return s}function FO(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function YS(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let p=0;p<s;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const o=n.shape[t],l=[];let c=1,h=1,d=1;for(let p=0;p<s;++p)l.push(n.shape[p]),c*=n.shape[p];for(let p=s;p<t;p++)l.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<r;p++)l.push(e.shape[p]);for(let p=t+1;p<i;p++)l.push(n.shape[p]),d*=n.shape[p];return{batchSize:c,sliceSize:d,outerSize:h,dimSize:o,outputShape:l}}const B7=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:YS,computeOutShape:FO,segOpComputeOptimalWindowSize:MO},Symbol.toStringTag,{value:"Module"}));function qi(n){try{return n.map(e=>Lo(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function LO(n){return n.map(e=>Ro(e))}const V7=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:PS,ERF_A2:zS,ERF_A3:BS,ERF_A4:VS,ERF_A5:US,ERF_P:LS,PARALLELIZE_THRESHOLD:DS,get RowPartitionType(){return Pr},SELU_SCALE:x0,SELU_SCALEALPHA:b0,applyActivation:bS,assertAndGetBroadcastShape:Ye,assertAxesAreInnerMostDims:Fn,assertParamsConsistent:RS,assignToTypedArray:wO,axesAreInnerMostDims:tS,calculateShapes:cl,checkEinsumDimSizes:HS,checkPadOnDimRoundingMode:bs,combineLocations:ED,combineRaggedTensorToTensorShapes:pO,complexWithEvenIndex:xO,complexWithOddIndex:vO,computeConv2DInfo:Mn,computeConv3DInfo:qo,computeDefaultPad:X1,computeDilation2DInfo:Zd,computeOptimalWindowSize:y0,computeOutAndReduceShapes:An,computeOutShape:ci,computePool2DInfo:wr,computePool3DInfo:Yi,convertConv2DDataFormat:Ji,decodeEinsumEquation:GS,eitherStridesOrDilationsAreOne:Xn,expandShapeToKeepDim:cn,exponent:CO,exponents:SO,fromStringArrayToUint8:LO,fromUint8ToStringArray:qi,getAxesPermutation:Wt,getBroadcastDims:Oc,getComplexWithIndex:jS,getEinsumComputePath:qS,getEinsumPermutation:WS,getFusedBiasGradient:yS,getFusedDyActivation:gS,getImageCenter:OS,getInnerMostAxes:nn,getPermuted:rf,getRaggedRank:gO,getReductionAxes:wn,getReshaped:sf,getReshapedPermuted:of,getRowPartitionTypesHelper:mO,getSliceBeginCoords:MS,getSliceSize:FS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:TO,getSparseFillEmptyRowsNegativeIndexErrorMessage:kO,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:$O,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:NO,getSparseReshapeInputOutputMismatchErrorMessage:_O,getSparseReshapeInputOutputMultipleErrorMessage:AO,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:EO,getSparseReshapeNegativeOutputDimErrorMessage:IO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:OO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Kv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:RO,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:DO,getUndoAxesPermutation:Ko,isIdentityPermutation:KS,log:e6,mergeRealAndImagArrays:Hi,prepareAndValidate:$S,prepareSplitSize:XS,segment_util:B7,shouldFuse:xS,slice_util:M7,splitRealAndImagArrays:bO,stridesOrDilationsArePositive:Ja,tupleValuesAreOne:Ya,upcastType:As,validateDefaultValueShape:yO,validateInput:c9,validateUpdateShape:WD,warn:Hs},Symbol.toStringTag,{value:"Module"}));w7();const PO={kernelName:cg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,nf(Ee(t,"float32"),-1))}}};const U7={kernelName:td,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ft(Ee(t,"float32")),r=Kn(Ve(bt(1),s));return en(Le(n,r))}}}};const j7={kernelName:nd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Kn(Ve(Ft(Ee(t,"float32")),1));return Le(n,s)}}}};const G7={kernelName:qc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{let l=n;const c=wn(t.shape,r);return c.length>0&&(l=Me(l,c)),te(l,t.shape)},b:()=>{let l=n;const c=wn(s.shape,r);return c.length>0&&(l=Me(l,c)),te(l,s.shape)}}}};const W7={kernelName:i1,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const H7={kernelName:ug,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ht(t)}}};const q7={kernelName:hg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ht(t)}}};const K7={kernelName:sd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Kn(Ve(bt(1),Ft(Ee(t,"float32")))))}}};const X7={kernelName:rd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Kn(ve(bt(1),Ft(Ee(t,"float32"))));return Le(n,s)}}}};const Y7={kernelName:ad,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{const l=ve(Ft(t),Ft(s));let c=X(n,Le(s,l));const h=wn(t.shape,r);return h.length>0&&(c=Me(c,h)),te(c,t.shape)},b:()=>{const l=ve(Ft(t),Ft(s));let c=en(X(n,Le(t,l)));const h=wn(s.shape,r);return h.length>0&&(c=Me(c,h)),te(c,s.shape)}}}};const J7={kernelName:id,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,ve(Ft(Ee(t,"float32")),1))}}};const Z7={kernelName:od,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Ve(bt(1),Ft(Ee(t,"float32"))))}}};function Q7(n,e,t,s,r,i){const o=U(n,"dy","avgPool3dGrad"),l=U(e,"input","avgPool3dGrad");let c=o,h=l,d=!1;l.rank===4&&(d=!0,c=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=te(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),L(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),L(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),bs("avgPool3dGrad",r,i);const p={dy:c,input:h},m={filterSize:t,strides:s,pad:r,dimRoundingMode:i},y=J.runKernel(c1,p,m);return d?te(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const eY=ne({avgPool3dGrad_:Q7});const tY={kernelName:fg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:l}=t;return{x:()=>eY(n,s,r,i,o,l)}}};function nY(n,e,t,s,r){const i=U(n,"dy","avgPoolGrad"),o=U(e,"input","avgPoolGrad");L(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let l=o,c=i,h=!1;o.rank===3&&(h=!0,l=te(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=te(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),L(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);const d={dy:c,input:l},p={filterSize:t,strides:s,pad:r},m=J.runKernel(l1,d,p);return h?te(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const sY=ne({avgPoolGrad_:nY});const rY={kernelName:dg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=t;return{x:()=>sY(n,s,r,i,o)}}};const iY={kernelName:pg,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>yt(n,r,!1,!0),b:()=>yt(s,n,!0,!1)}:!i&&o?{a:()=>yt(n,r,!1,!1),b:()=>yt(n,s,!0,!1)}:i&&!o?{a:()=>yt(r,n,!1,!0),b:()=>yt(s,n,!1,!1)}:{a:()=>yt(r,n,!0,!0),b:()=>yt(n,s,!0,!0)}}};const oY={kernelName:mg,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>cS(n,s,r)}}};const aY={kernelName:Y5,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,o=Array.from(i);for(let c=r.length-1;c>=0;c--)if(r[c]===i[c])o[c]=1;else if(r[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const l=[];for(let c=0;c<o.length;c++)o[c]>1&&l.push(c);return{x:()=>Me(n,l,!0)}}};const lY={kernelName:ld,gradFunc:n=>({x:()=>n.clone()})};const cY={kernelName:cd,gradFunc:n=>({x:()=>ht(n)})};const uY={kernelName:ud,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>ss(Gi(al(s,r),Xc(s,i)),n,ht(n))}}};const hY={kernelName:gg,inputsToSave:["x"],gradFunc:PO.gradFunc};const dY={kernelName:yg,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(c=>c.shape),{axis:r}=t,i=st(r,e[0].shape)[0],o=s.map(c=>c[i]);return Ks(n,o,i).map(c=>()=>c)}};const fY={kernelName:bg,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:o,pad:l,dataFormat:c}=t;return L(Ya(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>Z1(s.shape,n,r,o,l,c),filter:()=>mS(s,n,r.shape,o,l,c)}}};const pY={kernelName:xg,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c}=t;return{dy:()=>Za(n,r,i,o,l,1,c),filter:()=>mS(n,s,r.shape,i,o,l,c)}}};function mY(n,e,t,s,r){let i=n;n.rank===4&&(i=te(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=te(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),L(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),L(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),L(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),L(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),L(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const l={x:i,dy:o},c={strides:s,pad:r,filterShape:t};return J.runKernel(p1,l,c)}const gY=ne({conv3DBackpropFilter_:mY});const yY={kernelName:vg,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;L(Ya(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,l]=e;return{x:()=>CD(o.shape,n,l,r,i),filter:()=>gY(o,n,l.shape,r,i)}}};const bY={kernelName:hd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(en(VD(Ee(t,"float32"))),n)}}};const xY={kernelName:dd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(UD(Ee(t,"float32")),n)}}};const vY={kernelName:wg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=t;return{x:()=>{const l=Wt([r],s.rank);let c=kD(n,r,i,!o);return l!=null&&(c=ut(c,l)),c}}}};const wY={kernelName:Sg,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=t,l=s??[1,1];L(Ya(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);const[c,h]=e;return L(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),L(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),L(c.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),L(Xn(r,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${l}'.`),bs("depthwiseConv2d",i,o),{x:()=>I9(c.shape,n,h,r,i,l,o),filter:()=>$9(c,n,h.shape,r,i,l,o)}}};const SY={kernelName:Cg,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>J.runKernel(Rv,i,t),filter:()=>J.runKernel(Dv,o,t)}}};const CY={kernelName:pd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>J.runKernel(C1,s)}}};const TY={kernelName:md,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=X(pi(en(Ft(t))),2/Math.sqrt(Math.PI));return{x:()=>X(n,s)}}};const kY={kernelName:gd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,t)}}};const $Y={kernelName:kg,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>te(n,t.shape)}}};const EY={kernelName:yd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,pi(t))}}};const IY={kernelName:bd,gradFunc:n=>({x:()=>ht(n)})};const NY={kernelName:xd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{const l=Le(n,Ee(s,"float32")),c=wn(t.shape,r);return c.length>0?te(Me(l,c),t.shape):l},b:()=>{let l=X(n,Ee(t,"float32"));const c=wn(s.shape,r);c.length>0&&(l=te(Me(l,c),s.shape));const h=Ft(s);return en(Le(l,Ee(h,"float32")))}}}};const AY={kernelName:$g,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,o,l]=e,c=l??bt(1),h=wn(i.shape,r.shape),d=[];if(i.rank===1){for(let $=0;$<r.shape.length-1;++$)d.push(r.shape[$]);d.push(1)}const p=Ve(r,i),m=X(n,c),y=PD(ve(o,bt(s))),b=X(X(X(y,y),y),bt(-.5));return{x:()=>i.rank===1?te(X(X(n,zr(te(y,[1,1,1,i.shape[0]]),d)),c),r.shape):te(X(X(n,y),c),r.shape),mean:()=>{let $=X(X(y,bt(-1)),m);return i.rank===1&&($=Me($,h)),te($,i.shape)},variance:()=>{let $=X(X(b,p),m);return i.rank===1&&($=Me($,h)),te($,i.shape)},scale:()=>{const $=X(p,y);let E=X(n,$);return i.rank===1&&(E=Me(E,h)),te(E,i.shape)},offset:()=>{let $=n;return i.rank===1&&($=Me($,h)),te($,i.shape)}}}};const _Y={kernelName:Eg,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:o}=t,l=st(i,s.shape)[0],c=(h,d,p)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,l),x=b.length,w=m.slice(i,m.length).slice(1),S=w.length,T=hN(0,x),k=hN(x+1,x+1+S),$=dN([b,[y],w]),E=te(p,$),N=te(d,[y]),_=dN([[x],T,k]),R=ut(E,_);let D=qD(R,N,h.shape[l]);const M=Ko(_);return D=ut(D,M),D};if(o===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>Wi(d.map((y,b)=>c(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:c(s,r,n),indices:()=>r}}};function hN(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function dN(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const RY={kernelName:vd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ht(t),b:()=>ht(s)}}};const DY={kernelName:wd,gradFunc:n=>({x:()=>Ee(n,"float32")})};const OY={kernelName:Sd,gradFunc:n=>({x:()=>ht(n)})};const MY={kernelName:Cd,gradFunc:n=>({x:()=>ht(n)})};const FY={kernelName:Td,gradFunc:n=>({x:()=>ht(n)})};const LY={kernelName:Ng,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=Ys(s,0);return{x:()=>ss(i,n,X(n,r))}}};const PY={kernelName:$d,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,ve(t,1))}}};const zY={kernelName:kd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Ee(t,"float32"))}}};const BY={kernelName:Z5,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const o=pi(s);return Ve(n,X(Me(n,r,!0),o))}}}};function VY(n,e,t,s=5,r=1,i=1,o=.5){const l={x:n,y:e,dy:t},c={depthRadius:s,bias:r,alpha:i,beta:o};return J.runKernel(N1,l,c)}const UY=ne({localResponseNormalizationBackprop_:VY});const jY={kernelName:Mg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:l,beta:c}=t;return{x:()=>UY(s,r,n,i,o,l,c)}}};function zO(n,e,t,s){return e.rank<t.rank&&(e=te(e,cn(e.shape,s))),n.rank<t.rank&&(n=te(n,cn(n.shape,s))),{x:()=>X(n,Ee(fi(t,e),n.dtype))}}const fN={kernelName:Fg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],o=e[1],l=st(r,i.shape),c=zO(n,o,i,l);return{x:()=>c.x()}}};const GY={kernelName:Ed,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>X(n,Ee(al(t,s),"float32")),b:()=>X(n,Ee(Dm(t,s),"float32"))}}};function WY(n,e,t,s,r,i,o){const l=U(n,"dy","maxPool3dGrad"),c=U(e,"input","maxPool3dGrad"),h=U(t,"output","maxPool3dGrad");let d=l,p=c,m=h,y=!1;c.rank===4&&(y=!0,d=te(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=te(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),m=te(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),L(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),L(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),L(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),bs("maxPool3dGrad",i,o);const b={dy:d,input:p,output:m},x={filterSize:s,strides:r,pad:i,dimRoundingMode:o},w=J.runKernel(_1,b,x);return y?te(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const HY=ne({maxPool3dGrad_:WY});const qY={kernelName:Pg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=t;return{x:()=>HY(n,s,r,i,o,l,c)}}};function KY(n,e,t,s,r,i,o){const l=U(n,"dy","maxPoolGrad"),c=U(e,"input","maxPoolGrad"),h=U(t,"output","maxPoolGrad");L(c.rank===l.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${l.rank})`),L(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),L(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),bs("maxPoolGrad",i,o);const d={dy:l,input:c,output:h},p={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return J.runKernel(A1,d,p)}const XY=ne({maxPoolGrad_:KY});const YY={kernelName:Lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:l}=t;return{x:()=>XY(n,s,r,i,o,l)}}};const JY={kernelName:zg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=st(r,s.shape),l=An(s.shape,i)[1],c=pe(l);return{x:()=>{const d=s.shape.slice();i.forEach(y=>{d[y]=1});const p=te(n,d);return Le(X(p,Yo(s.shape,"float32")),c)}}}};const ZY={kernelName:Bg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,o]=e,l=st(r,i.shape),c=zO(n,o,i,l);return{x:()=>c.x()}}};const QY={kernelName:Id,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>X(n,Ee(Xc(t,s),"float32")),b:()=>X(n,Ee(Ys(t,s),"float32"))}}};const eJ={kernelName:Vg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>Dt(n,i,s.shape)}}};const tJ={kernelName:Nd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{const l=wn(t.shape,r);return l.length>0?te(Me(n,l),t.shape):n},b:()=>{const l=X(n,en(m0(Le(t,s)))),c=wn(s.shape,r);return c.length>0?te(Me(l,c),s.shape):l}}}};const nJ={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{const l=X(n,Ee(s,"float32")),c=wn(t.shape,r);return c.length>0?te(Me(l,c),t.shape):l},b:()=>{const l=X(n,Ee(t,"float32")),c=wn(s.shape,r);return c.length>0?te(Me(l,c),s.shape):l}}}};const sJ={kernelName:Ug,gradFunc:n=>({x:()=>en(n)})};const rJ={kernelName:Wg,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>In(t.shape,"float32")}}};const iJ={kernelName:Gg,gradFunc:n=>({x:()=>ht(n)})};const oJ={kernelName:Hg,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return tl(n,s).map(i=>()=>i)}};const pN={kernelName:qg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>Dt(n,i,s.shape)}}};const aJ={kernelName:_d,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,o=s,l=Ye(i.shape,o.shape);return{a:()=>{const d=Ee(o,"float32");let p=X(n,X(d,Qa(i,Ve(d,bt(1)))));const m=wn(i.shape,l);return m.length>0&&(p=Me(p,m)),te(p,i.shape)},b:()=>{const d=Ys(i,0),p=ss(d,mi(i),ht(i));let m=X(n,X(r,p));const y=wn(o.shape,l);return y.length>0&&(m=Me(m,y)),te(m,o.shape)}}}};const lJ={kernelName:Kg,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=Ys(t,0);return{x:()=>ss(r,n,X(n,s)),alpha:()=>{let i=ss(r,ht(n),X(n,t));const o=wn(s.shape,n.shape);return o.length>0&&(i=Me(i,o)),te(i,s.shape)}}}};function cJ(n,e,t){const s=n.shape.slice();s[t]=1;const r=te(e,s),i=Wv(n,t,!0,!1),o=Wv(n,t,!0,!0),l=X(i,o);return X(r,l)}function uJ(n,e,t){const s=n.shape.length,r=s-t.length,i=Wt(t,s);let o=n;i!=null&&(o=ut(n,i));const l=o.shape.slice(),h=l.splice(s-t.length,t.length).reduce((m,y)=>m*y,1);l.push(h);const d=o.reshape(l);let p=cJ(d,e,r);if(p=p.reshape(o.shape),i!=null){const m=Ko(i);p=ut(p,m)}return p}const hJ={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((o,l)=>l):typeof r=="number"?i=[r]:i=r,{x:()=>uJ(s,n,i)}}};const dJ={kernelName:fd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{const l=Le(n,Ee(s,"float32")),c=wn(t.shape,r);return c.length>0?te(Me(l,c),t.shape):l},b:()=>{let l=X(n,Ee(t,"float32"));const c=wn(s.shape,r);c.length>0&&(l=te(Me(l,c),s.shape));const h=Ft(s);return en(Le(l,Ee(h,"float32")))}}}};const fJ={kernelName:Rd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,en(Ft(t)))}}};const pJ={kernelName:Od,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=X(Xc(t,6),nf(t));return{x:()=>X(n,Ee(s,"float32"))}}};const mJ={kernelName:Dd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,Ee(nf(t),"float32"))}}};const gJ={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>te(n,t.shape)}}};const yJ={kernelName:Zg,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>J.runKernel(P1,r,t)}}};const bJ={kernelName:Jg,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>J.runKernel(L1,r,t)}}};const xJ={kernelName:Qg,gradFunc:(n,e,t)=>{const{dims:s}=t,r=st(s,n.shape);return{x:()=>el(n,r)}}};const vJ={kernelName:Md,gradFunc:n=>({x:()=>ht(n)})};const wJ={kernelName:Fd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>en(Le(n,X(Qa(t,1.5),2)))}}};const SJ={kernelName:e0,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ee(ht(t),"float32"),t:()=>X(n,Ee(t,n.dtype)),e:()=>X(n,Ee(iS(t),n.dtype))}}};const CJ={kernelName:Ld,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ys(t,bt(0)),r=bt(b0),i=bt(x0),o=X(n,i),l=X(X(n,r),pi(Ee(t,"float32")));return ss(s,o,l)}}}};const TJ={kernelName:Vd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,X(t,Ve(bt(1),t)))}}};const kJ={kernelName:Bd,gradFunc:n=>({x:()=>ht(n)})};const $J={kernelName:Pd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(Q1(Ee(t,"float32")),n)}}};const EJ={kernelName:zd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(TD(Ee(t,"float32")),n)}}};const IJ={kernelName:t0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,o=s.shape,[l,c]=g0(s,r,i),h=[];for(let d=0;d<n.rank;d++)h.push([l[d],o[d]-l[d]-c[d]]);return{x:()=>lS(n,h)}}};const NJ={kernelName:i0,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,o=X(n,s);return{logits:()=>Ve(o,X(Me(o,[r],i),s))}}};const AJ={kernelName:Ud,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,Kc(t))}}};const mN={kernelName:s0,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>J1(n,s,r)}}};const gN={kernelName:r0,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>ms(n,s)}}};const _J={kernelName:jd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,X(Kn(Ee(t,"float32")),2))}}};const RJ={kernelName:z1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,X(Ee(t,"float32"),2))}}};const DJ={kernelName:Gd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=bt(2);return{a:()=>X(n,X(r,Ve(t,s))),b:()=>X(n,X(r,Ve(s,t)))}}};const OJ={kernelName:Xd,gradFunc:n=>({x:()=>ht(n)})};const MJ={kernelName:Wd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ye(t.shape,s.shape);return{a:()=>{let l=n;const c=wn(t.shape,r);return c.length>0&&(l=Me(l,c)),te(l,t.shape)},b:()=>{let l=n;const c=wn(s.shape,r);return c.length>0&&(l=Me(l,c)),te(en(l),s.shape)}}}};const FJ={kernelName:n0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;st(i,s.shape).forEach(h=>{r[h]=1});const l=te(n,r),c=X(l,Yo(s.shape,"float32"));return{x:()=>c}}};const LJ={kernelName:Hd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Ft(Q1(t)))}}};const PJ={kernelName:qd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(Ve(bt(1),Ft(t)),n)}}};const zJ={kernelName:Kd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let o=ht(s);if(s.rank===1)for(let l=0;l<r[0];++l)o=ve(o,Dt(n,[l*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)o=ve(o,Dt(n,[l*s.shape[0],c*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let h=0;h<r[2];++h)o=ve(o,Dt(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let h=0;h<r[2];++h)for(let d=0;d<r[3];++d)o=ve(o,Dt(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};const BJ={kernelName:kc,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=Ko(r);return{x:()=>ut(n,i)}}};const VJ={kernelName:o0,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>Wi(n,r)}}};const UJ={kernelName:a0,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>jJ(n,t)}}};function jJ(n,e){const t=Xo(e,ht(e)),s=nS(n,t);let r=al(e,bt(0,"int32"));const i=s.rank-r.rank;for(let l=0;l<i;++l)r=ds(r,l+1);r=Gi(r,Yo(s.shape,"bool"));const o=ht(s);return ss(r,s,o)}const GJ={kernelName:l0,gradFunc:n=>({x:()=>ht(n)})};const WJ=[PO,U7,j7,G7,W7,H7,q7,K7,X7,Y7,J7,Z7,tY,rY,iY,oY,aY,lY,cY,uY,hY,dY,pY,fY,yY,bY,xY,vY,wY,SY,dJ,CY,TY,kY,$Y,EY,NY,IY,AY,_Y,RY,DY,OY,MY,FY,LY,PY,zY,BY,jY,fN,fN,GY,qY,YY,JY,ZY,QY,eJ,tJ,nJ,sJ,rJ,iJ,oJ,pN,pN,aJ,lJ,hJ,fJ,pJ,mJ,gJ,yJ,bJ,xJ,vJ,wJ,SJ,CJ,TJ,kJ,$J,EJ,IJ,NJ,AJ,mN,mN,gN,gN,_J,DJ,RJ,OJ,MJ,FJ,LJ,PJ,zJ,BJ,VJ,UJ,GJ];for(const n of WJ)t6(n);fe().prototype.abs=function(){return this.throwIfDisposed(),Qn(this)};fe().prototype.acos=function(){return this.throwIfDisposed(),mq(this)};fe().prototype.acosh=function(){return this.throwIfDisposed(),yq(this)};fe().prototype.add=function(n){return this.throwIfDisposed(),ve(this,n)};fe().prototype.all=function(n,e){return this.throwIfDisposed(),vD(this,n,e)};fe().prototype.any=function(n,e){return this.throwIfDisposed(),jv(this,n,e)};fe().prototype.argMax=function(n){return this.throwIfDisposed(),Fh(this,n)};fe().prototype.argMin=function(n){return this.throwIfDisposed(),Sq(this,n)};fe().prototype.asScalar=function(){return this.throwIfDisposed(),L(this.size===1,()=>"The array must have only 1 element."),te(this,[])};fe().prototype.asType=function(n){return this.throwIfDisposed(),Ee(this,n)};fe().prototype.as1D=function(){return this.throwIfDisposed(),te(this,[this.size])};fe().prototype.as2D=function(n,e){return this.throwIfDisposed(),te(this,[n,e])};fe().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),te(this,[n,e,t])};fe().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),te(this,[n,e,t,s])};fe().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),te(this,[n,e,t,s,r])};fe().prototype.asin=function(){return this.throwIfDisposed(),Tq(this)};fe().prototype.asinh=function(){return this.throwIfDisposed(),$q(this)};fe().prototype.atan=function(){return this.throwIfDisposed(),Iq(this)};fe().prototype.atan2=function(n){return this.throwIfDisposed(),Aq(this,n)};fe().prototype.atanh=function(){return this.throwIfDisposed(),Rq(this)};fe().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),Y1(this,n,e,t,s)};fe().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),J1(this,n,e)};fe().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),h0(this,n,e,t,s,r)};fe().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Sh(this,n)};fe().prototype.cast=function(n){return this.throwIfDisposed(),Ee(this,n)};fe().prototype.ceil=function(){return this.throwIfDisposed(),i8(this)};fe().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Xs(this,n,e)};fe().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof gn&&(n=[n]),ms([this,...n],e)};fe().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),wD(this,n,e,t,s,r,i)};fe().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),SD(this,n,e,t,s,r)};fe().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Za(this,n,e,t,s,r,i)};fe().prototype.cos=function(){return this.throwIfDisposed(),Q1(this)};fe().prototype.cosh=function(){return this.throwIfDisposed(),TD(this)};fe().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),Wv(this,n,e,t)};fe().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),kD(this,n,e,t)};fe().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),A8(this,n,e)};fe().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),eS(this,n,e,t,s,r,i)};fe().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),D8(this,n,e,t,s,r)};fe().prototype.divNoNan=function(n){return this.throwIfDisposed(),P8(this,n)};fe().prototype.div=function(n){return this.throwIfDisposed(),Le(this,n)};fe().prototype.dot=function(n){return this.throwIfDisposed(),B8(this,n)};fe().prototype.elu=function(){return this.throwIfDisposed(),f0(this)};fe().prototype.equal=function(n){return this.throwIfDisposed(),fi(this,n)};fe().prototype.erf=function(){return this.throwIfDisposed(),$D(this)};fe().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),Z8(this,n,e)};fe().prototype.exp=function(){return this.throwIfDisposed(),pi(this)};fe().prototype.expandDims=function(n){return this.throwIfDisposed(),ds(this,n)};fe().prototype.expm1=function(){return this.throwIfDisposed(),nK(this)};fe().prototype.fft=function(){return this.throwIfDisposed(),GD(this)};fe().prototype.flatten=function(){return this.throwIfDisposed(),te(this,[this.size])};fe().prototype.floor=function(){return this.throwIfDisposed(),m0(this)};fe().prototype.floorDiv=function(n){return this.throwIfDisposed(),xD(this,n)};fe().prototype.gather=function(n,e,t){return this.throwIfDisposed(),nS(this,n,e,t)};fe().prototype.greaterEqual=function(n){return this.throwIfDisposed(),al(this,n)};fe().prototype.greater=function(n){return this.throwIfDisposed(),Ys(this,n)};fe().prototype.ifft=function(){return this.throwIfDisposed(),Hv(this)};fe().prototype.irfft=function(){return this.throwIfDisposed(),XX(this)};fe().prototype.isFinite=function(){return this.throwIfDisposed(),hK(this)};fe().prototype.isInf=function(){return this.throwIfDisposed(),fK(this)};fe().prototype.isNaN=function(){return this.throwIfDisposed(),mK(this)};fe().prototype.leakyRelu=function(n){return this.throwIfDisposed(),rS(this,n)};fe().prototype.lessEqual=function(n){return this.throwIfDisposed(),Xc(this,n)};fe().prototype.less=function(n){return this.throwIfDisposed(),Dm(this,n)};fe().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),vK(this,n,e,t,s)};fe().prototype.logSigmoid=function(){return this.throwIfDisposed(),EK(this)};fe().prototype.logSoftmax=function(n){return this.throwIfDisposed(),_D(this,n)};fe().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),RD(this,n,e)};fe().prototype.log=function(){return this.throwIfDisposed(),mi(this)};fe().prototype.log1p=function(){return this.throwIfDisposed(),AD(this)};fe().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Gi(this,n)};fe().prototype.logicalNot=function(){return this.throwIfDisposed(),iS(this)};fe().prototype.logicalOr=function(n){return this.throwIfDisposed(),DD(this,n)};fe().prototype.logicalXor=function(n){return this.throwIfDisposed(),MK(this,n)};fe().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),yt(this,n,e,t)};fe().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),oS(this,n,e,t,s)};fe().prototype.max=function(n,e){return this.throwIfDisposed(),Vr(this,n,e)};fe().prototype.maximum=function(n){return this.throwIfDisposed(),Xo(this,n)};fe().prototype.mean=function(n,e){return this.throwIfDisposed(),ln(this,n,e)};fe().prototype.min=function(n,e){return this.throwIfDisposed(),Rm(this,n,e)};fe().prototype.minimum=function(n){return this.throwIfDisposed(),zh(this,n)};fe().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),jK(this,n,e)};fe().prototype.mod=function(n){return this.throwIfDisposed(),WK(this,n)};fe().prototype.mul=function(n){return this.throwIfDisposed(),X(this,n)};fe().prototype.neg=function(){return this.throwIfDisposed(),en(this)};fe().prototype.norm=function(n,e,t){return this.throwIfDisposed(),p0(this,n,e,t)};fe().prototype.notEqual=function(n){return this.throwIfDisposed(),Om(this,n)};fe().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),OD(this,n,e,t)};fe().prototype.onesLike=function(){return this.throwIfDisposed(),vr(this)};fe().prototype.pad=function(n,e){return this.throwIfDisposed(),lS(this,n,e)};fe().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),tX(this,n,e,t,s,r,i)};fe().prototype.pow=function(n){return this.throwIfDisposed(),Qa(this,n)};fe().prototype.prelu=function(n){return this.throwIfDisposed(),uS(this,n)};fe().prototype.prod=function(n,e){return this.throwIfDisposed(),rX(this,n,e)};fe().prototype.reciprocal=function(){return this.throwIfDisposed(),NX(this)};fe().prototype.relu=function(){return this.throwIfDisposed(),ll(this)};fe().prototype.relu6=function(){return this.throwIfDisposed(),FD(this)};fe().prototype.reshapeAs=function(n){return this.throwIfDisposed(),te(this,n.shape)};fe().prototype.reshape=function(n){return this.throwIfDisposed(),te(this,n)};fe().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),XD(this,n,e,t)};fe().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),YD(this,n,e,t)};fe().prototype.reverse=function(n){return this.throwIfDisposed(),el(this,n)};fe().prototype.rfft=function(){return this.throwIfDisposed(),ZX(this)};fe().prototype.round=function(){return this.throwIfDisposed(),LD(this)};fe().prototype.rsqrt=function(){return this.throwIfDisposed(),PD(this)};fe().prototype.selu=function(){return this.throwIfDisposed(),zD(this)};fe().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),BD(this,n,e,t,s,r,i)};fe().prototype.sigmoid=function(){return this.throwIfDisposed(),Kc(this)};fe().prototype.sign=function(){return this.throwIfDisposed(),PX(this)};fe().prototype.sin=function(){return this.throwIfDisposed(),VD(this)};fe().prototype.sinh=function(){return this.throwIfDisposed(),UD(this)};fe().prototype.slice=function(n,e){return this.throwIfDisposed(),Dt(this,n,e)};fe().prototype.softmax=function(n){return this.throwIfDisposed(),pS(this,n)};fe().prototype.softplus=function(){return this.throwIfDisposed(),Qd(this)};fe().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),cS(this,n,e)};fe().prototype.split=function(n,e){return this.throwIfDisposed(),Ks(this,n,e)};fe().prototype.sqrt=function(){return this.throwIfDisposed(),Kn(this)};fe().prototype.square=function(){return this.throwIfDisposed(),Ft(this)};fe().prototype.squaredDifference=function(n){return this.throwIfDisposed(),e9(this,n)};fe().prototype.squeeze=function(n){return this.throwIfDisposed(),tf(this,n)};fe().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof gn?[this,n]:[this,...n];return Wi(t,e)};fe().prototype.step=function(n){return this.throwIfDisposed(),nf(this,n)};fe().prototype.stridedSlice=function(n,e,t,s,r,i,o,l){return this.throwIfDisposed(),i9(this,n,e,t,s,r,i,o,l)};fe().prototype.sub=function(n){return this.throwIfDisposed(),Ve(this,n)};fe().prototype.sum=function(n,e){return this.throwIfDisposed(),Me(this,n,e)};fe().prototype.tan=function(){return this.throwIfDisposed(),a9(this)};fe().prototype.tanh=function(){return this.throwIfDisposed(),u0(this)};fe().prototype.tile=function(n){return this.throwIfDisposed(),zr(this,n)};fe().prototype.toBool=function(){return this.throwIfDisposed(),Ee(this,"bool")};fe().prototype.toFloat=function(){return this.throwIfDisposed(),Ee(this,"float32")};fe().prototype.toInt=function(){return this.throwIfDisposed(),Ee(this,"int32")};fe().prototype.topk=function(n,e){return this.throwIfDisposed(),h9(this,n,e)};fe().prototype.transpose=function(n){return this.throwIfDisposed(),ut(this,n)};fe().prototype.unique=function(n){return this.throwIfDisposed(),p9(this,n)};fe().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),qD(this,n,e)};fe().prototype.unstack=function(n){return this.throwIfDisposed(),tl(this,n)};fe().prototype.where=function(n,e){return this.throwIfDisposed(),ss(n,this,e)};fe().prototype.zerosLike=function(){return this.throwIfDisposed(),ht(this)};class ti extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ti.prototype)}}class gr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,gr.prototype)}}class H extends Error{constructor(e){super(e),Object.setPrototypeOf(this,H.prototype)}}class Ze extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ze.prototype)}}class JS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,JS.prototype)}}class BO{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function nl(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ni(n,e){if(!n)throw new JS(e)}function yN(n,e){let t=0;for(const s of n)s===e&&t++;return t}function fs(n){return n.length===1?n[0]:n}function St(n){return Array.isArray(n)?n:[n]}function zi(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Da(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let cr={};function ZS(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function Xv(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>Xv(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:Xv(s))}}}function af(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in cr)o=cr[i];else if(o=e[i],o==null)throw new H(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new H(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let l,c;if(o in t?[l,c]=t[o]:o in cr?[l,c]=cr.className:o in e&&([l,c]=e[o]),l==null)throw new H(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const h={};for(const y of Object.keys(cr))h[y]=cr[y];for(const y of Object.keys(t))h[y]=t[y];const d=i.config;d.customObjects=h;const p=Object.assign({},cr);for(const y of Object.keys(t))cr[y]=t[y];Xv(i.config);const m=c(l,i.config,t,r);return cr=Object.assign({},p),m}else{const h=Object.assign({},cr);for(const p of Object.keys(t))cr[p]=t[p];const d=new l(i.config);return cr=Object.assign({},h),d}}}function HJ(n,e){return n<e?-1:n>e?1:0}function Hp(n,e){return-1*HJ(n,e)}function Do(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function qJ(n){if(n==null)throw new H(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function ul(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new H(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function QS(n,e,t=0,s=1/0){return ni(t>=0),ni(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Nn(n,e){Array.isArray(n)?(L(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Nn(t,`element ${s+1} of ${e}`))):L(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${VO(n)}.`)}function VO(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>VO(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function KJ(n,e,t){let s=t!=null?t():hs(),r;return(...o)=>{const l=t!=null?t():hs();return l-s<e||(s=l,r=n(...o)),r}}function UO(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let XJ=0;function jO(){return XJ++}const qp={};function v0(n=""){return n in qp||(qp[n]=0),qp[n]+=1,n+qp[n].toString()}const YJ=["channelsFirst","channelsLast"],JJ=["nearest","bilinear"],ZJ=["valid","same","causal"],QJ=["max","avg"],eZ=["sum","mul","concat","ave"];const lc=new Map;function sn(n){ul(YJ,"DataFormat",n)}function tZ(n){ul(JJ,"InterpolationFormat",n)}function Js(n){ul(ZJ,"PaddingMode",n)}function GO(n){ul(QJ,"PoolMode",n)}const Ch=[],bN="/";function ja(n,e){Ch.push(n);try{const t=e();return Ch.pop(),t}catch(t){throw Ch.pop(),t}}function nZ(){return Ch.length===0?"":Ch.join(bN)+bN}function WO(n){if(!qO(n))throw new Error("Not a valid tensor name: '"+n+"'");return nZ()+n}function HO(n){if(!qO(n))throw new Error("Not a valid tensor name: '"+n+"'");lc.has(n)||lc.set(n,0);const e=lc.get(n);if(lc.set(n,lc.get(n)+1),e>0){const t=`${n}_${e}`;return lc.set(t,1),t}else return n}const sZ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function qO(n){return!!n.match(sZ)}function rZ(n){return n===parseInt(n.toString(),10)}function Oo(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Fc(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Po(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function jr(n,e){if(e<n)throw new H(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let Mx;function yn(){return Mx==null&&(Mx=I6().epsilon()),Mx}function Gr(){return"channelsLast"}function ui(n,e){return Ee(n,e)}function lf(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),te(n,t)}function iZ(n,e){return ie(()=>{if(n.shape.length!==2)throw new H(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=lf(n,1);return Yv(t,[1,e,1])})}function oZ(n){const e=[Oo(n.shape)];return te(n,e)}function aZ(n){if(n.rank<=1)throw new H(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Oo(n.shape,1)];return te(n,e)}function Ga(n,e,t){return ie(()=>{switch(n.rank){case 1:return dS(n,e,t);case 2:return jD(n,[e,0],[t,n.shape[1]]);case 3:return fS(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Fm(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Dt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Dt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new H(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Fx(n,e,t){return ie(()=>{switch(n.rank){case 1:return dS(n,e,t);case 2:return jD(n,[0,e],[n.shape[0],t]);case 3:return fS(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Fm(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Kp(n,e,t,s){return ie(()=>{switch(n.rank){case 1:return dS(n,e,t);case 2:switch(s){case 1:return Ga(n,e,t);case 2:return Fx(n,e,t);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ga(n,e,t);case 2:return fS(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Fx(n,e,t);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ga(n,e,t);case 2:return Fm(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Fm(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Fx(n,e,t);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function eC(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),ms(n,e)}function xN(n,e){switch(n.rank){case 1:return l8([n,e]);case 2:return u8([n,e],0);case 3:return d8([n,e],0);case 4:return p8([n,e],0);default:throw new H(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Yv(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new H(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return zr(n,e)}function w0(n,e=0,t=1,s,r){return kX(n,e,t,s,r)}function hi(n,e,t,s){if(n.rank<2||e.rank<2)throw new Ze(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new Ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return sN({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Jv(n.rank,s,Gr()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=te(n,[-1,i]);const o=e.shape.slice(),l=o.pop(),c=o.pop(),h=[...o,l],d=Array.from({length:e.rank},(b,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=te(ut(e,d),[c,-1]);const p=[...r,...h];return te(sN({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?Jv(n.rank,s,Gr()):null,activation:t}),p)}}function KO(n,e,t){return ie(()=>(Array.isArray(e)?e=Ns(e,"int32"):e=Ee(e,"int32"),nS(n,e,t)))}function cf(n){return X(n,n)}function Jv(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new H(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?te(e,[1,s[0],1,1,1]):te(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?te(e,[1,1,1,1,s[0]]):te(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?te(e,[1,s[0],1,1]):te(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?te(e,[1,1,1,s[0]]):te(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?te(e,[1,s[0],1]):te(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?te(e,[1,1,s[0]]):te(e,[1].concat(s))}else if(n<3)return e;throw new H(`Unsupported input rank by biasAdd: ${e.rank}`)}function Hr(n,e,t){return ie(()=>(t==null&&(t=Gr()),sn(t),ve(n,Jv(n.rank,e,t))))}function lZ(n,e=1){if(e!==1)throw new Ze(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return f0(n)}function cZ(n){return ie(()=>Le(n,ve(Qn(n),1)))}function XO(n,e,t,s){return ie(()=>w9(n,e,t,s))}function uZ(n){return ie(()=>{const e=ve(.5,X(.2,n));return Xs(e,0,1)})}function uf(n,e,t=!1){return t?n():e()}const hZ=["fanIn","fanOut","fanAvg"],dZ=["normal","uniform","truncatedNormal"];function fZ(n){ul(hZ,"FanMode",n)}function pZ(n){ul(dZ,"Distribution",n)}class Sr extends Jc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class YO extends Sr{apply(e,t){return In(e,t)}}YO.className="Zeros";xe(YO);class tC extends Sr{apply(e,t){return Yo(e,t)}}tC.className="Ones";xe(tC);class JO extends Sr{constructor(e){if(super(),typeof e!="object")throw new H(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new H(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ie(()=>X(bt(this.value),Yo(e,t)))}getConfig(){return{value:this.value}}}JO.className="Constant";xe(JO);class ZO extends Sr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return ef(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ZO.className="RandomUniform";xe(ZO);class QO extends Sr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`randomNormal does not support dType ${t}.`);return w0(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}QO.className="RandomNormal";xe(QO);class eM extends Sr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`truncatedNormal does not support dType ${t}.`);return HD(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}eM.className="TruncatedNormal";xe(eM);class tM extends Sr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ie(()=>{if(e.length!==2||e[0]!==e[1])throw new H("Identity matrix initializer can only be used for 2D square matrices.");return X(this.gain,ND(e[0]))})}getConfig(){return{gain:this.gain}}}tM.className="Identity";xe(tM);function mZ(n,e="channelsLast"){let t,s;if(sn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Oo(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Oo(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Oo(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class _s extends Sr{constructor(e){if(super(),e.scale<0)throw new H(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,fZ(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,pZ(this.distribution),this.seed=e.seed}apply(e,t){const s=mZ(e),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const l=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`${this.getClassName()} does not support dType ${t}.`);return HD(e,0,l,t,this.seed)}else{const l=Math.sqrt(3*o);return ef(e,-l,l,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}_s.className="VarianceScaling";xe(_s);class nC extends _s{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return _s.className}}nC.className="GlorotUniform";xe(nC);class sC extends _s{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return _s.className}}sC.className="GlorotNormal";xe(sC);class rC extends _s{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return _s.className}}rC.className="HeNormal";xe(rC);class iC extends _s{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return _s.className}}iC.className="HeUniform";xe(iC);class oC extends _s{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return _s.className}}oC.className="LeCunNormal";xe(oC);class aC extends _s{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return _s.className}}aC.className="LeCunUniform";xe(aC);class nM extends Sr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ie(()=>{if(e.length<2)throw new Ze("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=pe(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],l=w0(o,0,1,t,this.seed),c=y7.qr(l,!1);let h=c[0];const p=c[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return h=X(h,p.sign()),s<r&&(h=h.transpose()),X(bt(this.gain),h.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}nM.className="Orthogonal";xe(nM);const vN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function wN(n,e={}){return af(n,pr.getMap().classNameMap,e,"initializer")}function Gt(n){return ZS(n)}function Bt(n){if(typeof n=="string"){const e=n in vN?vN[n]:n;if(e==="GlorotNormal")return new sC;if(e==="GlorotUniform")return new nC;if(e==="HeNormal")return new rC;if(e==="HeUniform")return new iC;if(e==="LeCunNormal")return new oC;if(e==="LeCunUniform")return new aC;{const t={};return t.className=e,t.config={},wN(t)}}else return n instanceof Sr?n:wN(n)}function Zv(n){return Array.isArray(n)&&Array.isArray(n[0])}function Lm(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Ge(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new H(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function ft(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new H(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function Pm(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const SN="Variable";class gZ{constructor(e,t="float32",s=SN,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=jO(),s=s??SN,this.originalName=WO(s),this.name=HO(this.originalName),this.trainable_=r,this.constraint=i,this.val=y9(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),yZ(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function yZ(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function Qv(n){return n.map(e=>e.read())}function lC(n){n.forEach(e=>{e[0].write(e[1])})}class bn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class gi{constructor(e,t,s,r,i,o,l){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=l,this.id=jO(),o!=null&&(this.originalName=WO(o),this.name=HO(this.originalName)),this.rank=t.length}}let bZ=0;class S0{constructor(e,t){this.callArgs=t,this.id=bZ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xZ=0;class rt extends Jc{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xZ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=zi(s)+"_"+v0(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new gr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new H(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return fs(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return fs(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ti(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ti(`Layer ${this.name} is not connected, no input to return.`);return fs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ti(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ti(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return fs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=St(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=St(this.inputSpec);if(t.length!==s.length)throw new H(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],o=s[r];if(o==null)continue;const l=i.rank;if(o.ndim!=null&&l!==o.ndim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${l}`);if(o.maxNDim!=null&&l>o.maxNDim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${l}`);if(o.minNDim!=null&&l<o.minNDim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${l}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new H(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const c=i.shape;for(const h in o.axes){const d=Number(h),p=o.axes[h],m=d>=0?c[d]:c[c.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${c}.`)}}if(o.shape!=null)for(let c=0;c<o.shape.length;++c){const h=o.shape[c],d=i.shape[c];if(h!=null&&d!=null&&h!==d)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=St(e),r=SZ(e),i=CZ(e);if(r===i)throw new H("Arguments to apply() must be all SymbolicTensors or all Tensors");return ja(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const l of St(e))o.push(l.shape);this.build(fs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const l=St(o),c=[];for(let h of l)s.indexOf(h)!==-1&&(h=h.clone()),c.push(h);if(o=fs(c),this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=vZ(e),l=this.computeOutputShape(o);let c;const h=wZ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),l!=null&&l.length>0&&Array.isArray(l[0])?c=l.map((d,p)=>new gi(h,d,this,St(e),t,this.name,p)):c=new gi(h,l,this,St(e),t,this.name),this.addInboundNode(e,c,null,null,o,l,t),this._refCount++,this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ti(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ti(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new gr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Pm(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Qv(e?this.trainableWeights:this.weights)}setWeights(e){ie(()=>{const t=this.weights;if(t.length!==e.length)throw new H(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=Qv(t);for(let i=0;i<r.length;++i){const o=r[i],l=t[i],c=e[i];if(!xt(o.shape,c.shape))throw new H(`Layer weight shape ${o.shape} not compatible with provided weight shape ${c.shape}`);s.push([l,c])}lC(s)})}addWeight(e,t,s,r,i,o,l,c){if(this._addedWeightNames.indexOf(e)!==-1)throw new H(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=c!=null?c():Bt("zeros"));const h=r.apply(t,s),d=new gZ(h,s,e,o,l);return h.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),o==null&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=St(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=St(t),o=St(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let l=0;l<i.length;l++)i[l].kerasMask=o[l]}addInboundNode(e,t,s,r,i,o,l=null){const c=St(e);t=St(t),s=St(s),r=St(r),i=Lm(i),o=Lm(o);const h=[],d=[],p=[];for(const m of c)h.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new S0({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:p,inputTensors:c,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},l);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function vZ(n){n=St(n);const e=[];for(const t of n)e.push(t.shape);return fs(e)}function wZ(n){return"float32"}function sM(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],l=s.inboundLayers[i],c=s.nodeIndices[i],h=sM(o,l,c);for(const d of h)r.indexOf(d)===-1&&r.push(d)}return r}}}function SZ(n){let e=!0;for(const t of St(n))if(!(t instanceof gi)){e=!1;break}return e}function CZ(n){let e=!0;for(const t of St(n))if(t instanceof gi){e=!1;break}return e}class hf extends rt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:v0("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new H("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new H("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new H("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new gi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new S0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new H(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}hf.className="InputLayer";xe(hf);function TZ(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new H("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new hf({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function kZ(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ee(e,n.dtype)}catch{throw new H(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class No{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof No)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=kZ(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new H(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof gi){if(this.id2Value[e.id]==null)throw new H(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new H(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof gi){if(this.id2Value[e.id]==null)throw new H(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new H(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&tt(this.id2Mask)}}const zm=new BO,Bm=new BO;function $Z(n){zm?.setMaxEntries(n),Bm?.setMaxEntries(n)}function uh(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],l=o.map(b=>b.name),c=[],h=e.names();for(const b of l)h.indexOf(b)!==-1?c.push(e.getValue(b)):c.push(null);const d=l.join(",")+"|"+e.names().sort().join(",");let p=zm.get(d),m;if(p==null){const b=EZ(o,e);p=b.sorted,m=b.recipientCounts,zm.put(d,p),Bm.put(d,m)}m={},r||Object.assign(m,Bm.get(d));const y=new No(e);for(let b=0;b<p.length;++b){const x=p[b],w=x.sourceLayer;if(w instanceof hf)continue;const S=[],T=[],k=[];let $=!1;for(const D of x.inputs){const M=y.getValue(D),A=y.getMask(D);S.push(M),T.push(A),A!=null&&($=!0),r||(m[D.name]--,m[D.name]===0&&!e.hasKey(D)&&l.indexOf(D.name)===-1&&!M.isDisposed&&D.sourceLayer.stateful!==!0&&k.push(M))}$&&(t=t||{},t.mask=T[0]);const E=St(w.apply(S,t));let N=null;w.supportsMasking&&(N=w.computeMask(S,T));const _=NZ(x),R=Array.isArray(_)?_:[_];for(let D=0;D<R.length;++D){y.hasKey(R[D])||y.add(R[D],E[D],Array.isArray(N)?N[0]:N);const M=l.indexOf(R[D].name);M!==-1&&(c[M]=E[D])}r||tt(k)}return y.disposeMasks(),i?c:c[0]}function EZ(n,e){L(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=CN(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:l}=CN(i,e);for(const c of o)r.has(c.name)||(t.push(c),r.add(c.name));for(const c in l)s[c]==null&&(s[c]=new Set),l[c].forEach(h=>s[c].add(h))}}return{sorted:t,recipientCounts:IZ(s)}}function IZ(n){const e={};for(const t in n)e[t]=n[t].size;return e}function CN(n,e){const t=new Set,s=[],r={};for(const l of e.names())t.add(l);const i=[],o=[];for(i.push(n);i.length>0;){const l=i[i.length-1];if(t.has(l.name)){i.pop();continue}const c=o[o.length-1]===i.length-1;if(l.inputs.length===0||c)i.pop(),s.push(l),t.add(l.name),c&&o.pop();else{o.push(i.length-1);for(const h of l.inputs)r[h.name]==null&&(r[h.name]=new Set),r[h.name].add(l.name),!t.has(h.name)&&i.push(h)}}return{sorted:s,recipientMap:r}}function NZ(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const AZ=ce();AZ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,$Z);function cC(n,e){return ie(()=>Kn(Me(X(n,n),e,!0)))}class df extends Jc{getConfig(){return{}}}class rM extends df{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ie(()=>{const t=cC(e,this.axis),s=Xs(t,0,this.maxValue);return X(e,Le(s,ve(yn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}rM.className="MaxNorm";xe(rM);class iM extends df{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ie(()=>Le(e,ve(yn(),cC(e,this.axis))))}getConfig(){return{axis:this.axis}}}iM.className="UnitNorm";xe(iM);class oM extends df{apply(e){return ll(e)}}oM.className="NonNeg";xe(oM);class aM extends df{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ie(()=>{const t=cC(e,this.axis),s=ve(X(this.rate,Xs(t,this.minValue,this.maxValue)),X(1-this.rate,t));return X(e,Le(s,ve(yn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}aM.className="MinMaxNorm";xe(aM);const TN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function xn(n){return ZS(n)}function kN(n,e={}){return af(n,pr.getMap().classNameMap,e,"constraint")}function vn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in TN?TN[n]:n,config:{}};return kN(t)}else return n instanceof df?n:kN(n)}async function Ta(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(r),s.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];tt(s)}}function lM(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var $N;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})($N||($N={}));const _Z=125;class Vh{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class RZ{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class DZ extends Vh{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const l=ie(()=>ve(this.totals[r],X(i,s)));this.totals[r]=l,o?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:ie(()=>{const r=X(Le(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),li(t[s])}))}}class OZ extends Vh{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const o=this.history[i];for(let l=0;l<o.length;++l)if(typeof o[l]!="number"){const c=o[l];e.push(c.data()),t.push(i),s.push(l)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class MZ extends Vh{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||fO,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=_Z),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Nv(this.yieldEvery)&&(this.maybeWait=KJ(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await Ta(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Ta(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Ta(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Ta(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Ta(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Nv(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Ta(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Ta(e),await this.trainEnd(e))}}function cM(n,e){return n==null&&(n={}),n instanceof Vh?[n]:Array.isArray(n)&&n[0]instanceof Vh?n:St(n).map(s=>new MZ(s,e))}class dr{constructor(){}static registerCallbackConstructor(e,t){L(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),dr.checkForDuplicate(t),dr.constructors[e]==null&&(dr.constructors[e]=[]),dr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in dr.constructors)dr.constructors[+t].forEach(r=>{if(r===e)throw new H("Duplicate callback constructor.")})}static clear(){dr.constructors={}}static createCallbacks(e){const t=[];for(const s in dr.constructors){const r=+s;e>=r&&t.push(...dr.constructors[r])}return t.map(s=>new s)}}dr.constructors={};function uM(n,e,t,s,r,i,o,l,c){const h=new OZ,d=[new DZ,...dr.createCallbacks(e)];n!=null&&d.push(...n),d.push(h);const p=new RZ(d);return p.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:l,metrics:c}),{callbackList:p,history:h}}function di(n,e={},t=!1){return af(n,pr.getMap().classNameMap,e,"layer",t)}function Vm(n,e){return ie(()=>{n.dtype!=="float32"&&(n=Ee(n,"float32"));const t=Me(cf(n),e,!0),s=d0(t.shape,yn()),r=Kn(Xo(t,s));return Le(n,r)})}function C0(n,e){return ie(()=>ln(cf(Ve(e,n)),-1))}function uC(n,e){return ie(()=>ln(Qn(Ve(e,n)),-1))}function hC(n,e){return ie(()=>{const t=Ve(n,e),s=Xs(Qn(n),yn(),Number.MAX_VALUE),r=Qn(Le(t,s));return X(100,ln(r,-1))})}function FZ(n,e){return ie(()=>{const t=Xs(e,yn(),Number.MAX_VALUE),s=mi(ve(1,t)),r=Xs(n,yn(),Number.MAX_VALUE),i=mi(ve(1,r));return ln(cf(Ve(s,i)),-1)})}function LZ(n,e){return ie(()=>{const t=Xo(0,Ve(1,X(n,e)));return ln(cf(t),-1)})}function PZ(n,e){return ie(()=>{const t=Xo(0,Ve(1,X(n,e)));return ln(t,-1)})}function zZ(n,e){return ie(()=>{const t=Me(X(n,e),-1),s=Vr(X(Ve(1,n),e),-1);return Xo(0,ve(1,Ve(s,t)))})}function BZ(n,e){return ie(()=>{const t=Math.log(2),s=Ve(e,n),r=Ve(ve(s,Qd(X(-2,s))),t);return ln(r,-1)})}function Uh(n,e,t=!1){return ie(()=>{if(t)e=pS(e);else{const s=Me(e,e.shape.length-1,!0);e=Le(e,s)}return e=Xs(e,yn(),1-yn()),en(Me(X(Ee(n,"float32"),mi(e)),e.shape.length-1))})}function Um(n,e,t=!1){return ie(()=>{const s=Ee(m0(oZ(n)),"int32");e=Xs(e,yn(),1-yn());const r=e.shape,i=te(OD(s,r[r.length-1]),r);return Uh(i,e,t)})}function VZ(n,e){if(!xt(n.shape,e.shape))throw new H(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return ie(()=>{const t=ll(e),s=en(Qn(e));return ve(Ve(t,X(e,n)),AD(pi(s)))})}function T0(n,e){return ie(()=>{let t;return t=Xs(e,yn(),1-yn()),t=mi(Le(t,Ve(1,t))),ln(VZ(n,t),-1)})}function UZ(n,e){return ie(()=>{const t=Xs(n,yn(),1),s=Xs(e,yn(),1);return Me(X(n,mi(Le(t,s))),-1)})}function jZ(n,e){return ie(()=>{const t=mi(ve(yn(),e));return ln(Ve(e,X(n,t)),-1)})}function hM(n,e){return ie(()=>{const t=Vm(n,-1),s=Vm(e,-1),r=X(t,s);return en(Me(r,-1))})}const jm={meanSquaredError:C0,meanAbsoluteError:uC,meanAbsolutePercentageError:hC,meanSquaredLogarithmicError:FZ,squaredHinge:LZ,hinge:PZ,categoricalHinge:zZ,logcosh:BZ,categoricalCrossentropy:Uh,sparseCategoricalCrossentropy:Um,binaryCrossentropy:T0,kullbackLeiblerDivergence:UZ,poisson:jZ,cosineProximity:hM};function Lx(n){if(typeof n=="string"){if(n in jm)return jm[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new H(e)}else return n}function dM(n,e){return ie(()=>{const t=X(.5,vr(e)),s=ui(Ys(e,t),n.dtype);return ln(fi(n,s),-1)})}function fM(n,e){return ie(()=>ui(fi(Fh(n,-1),Fh(e,-1)),"float32"))}function GZ(n,e){return ie(()=>Ee(Me(Gi(fi(n,1),fi(e,1))),"float32"))}function WZ(n,e){return ie(()=>Ee(Me(Gi(fi(n,0),fi(e,1))),"float32"))}function HZ(n,e){return ie(()=>{const t=GZ(n,e),s=WZ(n,e),r=ve(t,s);return Ee(ss(Ys(r,0),Le(t,r),0),"float32")})}function qZ(n,e){return T0(n,e)}function KZ(n,e){return n.rank===e.rank&&(n=tf(n,[n.rank-1])),e=Fh(e,-1),e.dtype!==n.dtype&&(e=Ee(e,n.dtype)),Ee(fi(n,e),"float32")}const XZ=C0,YZ=C0,JZ=uC,ZZ=uC,QZ=hC,eQ=hC,pM=Uh,tQ=hM,mM=Um,Gm={binaryAccuracy:dM,categoricalAccuracy:fM,precision:HZ,categoricalCrossentropy:pM,sparseCategoricalCrossentropy:mM,mse:XZ,MSE:YZ,mae:JZ,MAE:ZZ,mape:QZ,MAPE:eQ,cosine:tQ};function nQ(n){if(typeof n=="string"&&n in Gm)return Gm[n];if(typeof n!="string"&&n!=null)return n;throw new H(`Unknown metric ${n}`)}function Xp(n){if(ni(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(jm))if(jm[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Gm))if(Gm[t]===n){e=t;break}return e!==void 0?e:n.name}}function sQ(n){const e={Adagrad:()=>ac.adagrad(.01),Adadelta:()=>ac.adadelta(1,.95,yn()),Adam:()=>ac.adam(.001,.9,.999,yn()),Adamax:()=>ac.adamax(.002,.9,.999,yn(),0),RMSProp:()=>ac.rmsprop(.001,.9,0,yn()),SGD:()=>ac.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new H(`Unknown Optimizer ${n}`)}const EN=1*1024*1024;function IN(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!ew(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>EN&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${EN}.`)}}function ew(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!ew(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!ew(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function rQ(n,e,t,s=console.log){const r=oQ(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let o;if(!r){i.push("Receives inputs"),o=[];for(const d in n.nodesByDepth)o.push(...n.nodesByDepth[d])}s("_".repeat(e)),Wm(i,t,s),s("=".repeat(e));const l=n.layers;for(let d=0;d<l.length;++d)r?aQ(l[d],t,s):lQ(l[d],t,o,s),s((d===l.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const c=iQ(n),h=Pm(n.nonTrainableWeights);s(`Total params: ${c+h}`),s(`Trainable params: ${c}`),s(`Non-trainable params: ${h}`),s("_".repeat(e))}function iQ(n){let e;return n.collectedTrainableWeights!=null?e=Pm(n.collectedTrainableWeights):e=Pm(n.trainableWeights),e}function oQ(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function Wm(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function aQ(n,e,t){let s,r;try{r=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),l=[`${i} (${o})`,r,s,n.countParams().toString()];Wm(l,e,t)}function lQ(n,e,t,s){let r,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const p of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const y=p.inboundLayers[m].name,b=p.nodeIndices[m],x=p.tensorIndices[m];o.push(`${y}[${b}][${x}]`)}const l=n.name,c=n.getClassName(),h=o.length===0?"":o[0],d=[`${l} (${c})`,i,r,n.countParams().toString(),h];Wm(d,e,s);for(let p=1;p<o.length;++p)Wm(["","","","",o[p]],e,s)}function gM(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Hm(n,e){if(n===null)return null;if(typeof n=="string")return Da(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];gM(e,r,i)?t.push(i):t.push(Hm(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=Da(s);t[i]=Hm(r,i)}}return t}}function tw(n,e){if(n==null)return null;if(typeof n=="string")return zi(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];gM(e,r,i)?t.push(i):t.push(tw(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=zi(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=tw(r,s)}return t}}const yM="4.22.0";const cQ=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Or extends rt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=v0(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Do(this.inputs).length!==this.inputs.length)throw new H(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Do(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push($),this.outputLayersTensorIndices.push(E)}for(const T of this.inputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;ni($===0,"input layer has >1 nodes"),ni(E===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push($),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const k=this.inputLayers[T];if(!(k instanceof hf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${T} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const t={},s={},r={},i={},o={},l=[],c=(T,k,$,E,N,_)=>{(E==null||N==null||_==null)&&(E=T.sourceLayer,N=T.nodeIndex,_=T.tensorIndex);const R=E.inboundNodes[N];if($.indexOf(R)!==-1)throw new gr(`The tensor ${T.name} at layer "${E.name}" is part of a cycle.`);if(k.indexOf(R)!==-1)return;this.containerNodes.add(Or.nodeKey(E,N)),E.id in o||(o[E.id]=Object.keys(o).length),$.indexOf(R)===-1&&$.push(R);const D=R.inboundLayers.length;for(let M=0;M<D;M++){const A=R.inputTensors[M],z=R.inboundLayers[M],W=R.nodeIndices[M],Y=R.tensorIndices[M];c(A,k,$,z,W,Y)}for(k.push(R);$.indexOf(R)>=0;)$.splice($.indexOf(R),1);l.push(R)},h=[],d=[];for(const T of this.outputs)c(T,h,d);const p=l.slice().reverse();for(const T of p){s[T.id]=T,T.id in t||(t[T.id]=0);let k=t[T.id];const $=r[T.outboundLayer.id]==null?0:r[T.outboundLayer.id];k=Math.max(k,$),r[T.outboundLayer.id]=k,i[T.outboundLayer.id]=T.outboundLayer,t[T.id]=k;for(let E=0;E<T.inboundLayers.length;E++){const N=T.inboundLayers[E],_=T.nodeIndices[E],R=N.inboundNodes[_],D=t[R.id]==null?0:t[R.id];t[R.id]=Math.max(k+1,D),s[R.id]=R}}const m={};for(const T in t){const k=t[T];k in m||(m[k]=[]),m[k].push(s[T])}const y={};for(const T in r){const k=r[T];k in y||(y[k]=[]),y[k].push(i[T])}let b=Object.keys(y).map(T=>parseInt(T,10)).sort(Hp);this.layers=[];for(const T of b){const k=y[T];k.sort(($,E)=>{const N=o[$.id],_=o[E.id];return N<_?-1:N>_?1:0});for(const $ of k)$ instanceof Or&&this.internalContainerRefs.push($),this.layers.push($)}this.layersByDepth=y,b=Object.keys(m).map(T=>parseInt(T,10)).sort(Hp);const x=this.inputs.slice(),w=[];for(const T of b)for(const k of m[T]){const $=k.outboundLayer;if($!=null){for(const E of k.inputTensors)if(x.indexOf(E)===-1)throw new gr(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${$.name}". The following previous layers were accessed without issue: ${w}`);for(const E of k.outputTensors)x.push(E);w.push($.name)}}this.nodesByDepth=m;const S=this.layers.map(T=>T.name);for(const T of S){const k=S.filter($=>$===T).length;if(k!==1)throw new gr(`The name "${T}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new S0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new H("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=cQ(e);i&&this.parseWeights(e);for(const l of this.layers)for(const[c,h]of l.weights.entries()){const d=i?`${h.name.split("/").slice(0,-1).join("/")+"/"}${c}`:h.originalName;if(s[d]!=null)throw new H(`Duplicate weight name: ${d}`);s[d]=h,r++}const o=[];for(const l in e){let c=l;if(s[l]==null){const h=l.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[c]!=null)o.push([s[c],e[l]]);else if(t)throw new H(`Provided weight data has no target variable: ${l}`);delete s[c]}if(t){const l=[];for(const c in s)l.push(c);if(l.length>0)throw new H(`${l.length} of ${r} weights are not set: ${l}`)}lC(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${yM}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=tw(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return ie(()=>{e=St(e);const s=new No;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return uh(this.outputs,s,t)})}computeMask(e,t){return ie(()=>{e=St(e);let s;return t==null?s=nl(null,e.length):s=St(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=Lm(e);if(t.length!==this.inputLayers.length)throw new H(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let l=0;l<t.length;l++){const c=this.inputLayers[l],h=t[l],d=c.name+"_0_0";s[d]=h}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Hp);if(r.length>1)for(const l of r){const c=this.nodesByDepth[l];for(const h of c){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const p=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],S=h.nodeIndices[x],T=h.tensorIndices[x],k=`${w.name}_${S}_${T}`,$=s[k];p.push($)}const m=d.computeOutputShape(fs(p)),y=Lm(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const i=[],o=[];for(let l=0;l<this.outputLayers.length;l++){const c=this.outputLayers[l],h=this.outputLayersNodeIndices[l],d=this.outputLayersTensorIndices[l],p=`${c.name}_${h}_${d}`;o.push(p)}for(let l=0;l<o.length;l++){const c=o[l];ni(c in s),i.push(s[c])}return fs(i)}runInternalGraph(e,t){t==null&&(t=nl(null,e.length));const s={};for(let c=0;c<this.inputs.length;++c){const h=this.inputs[c],d=e[c],p=t[c];s[h.id]=[d,p]}const r=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(Hp);for(const c of r){const h=this.nodesByDepth[c];for(const d of h){const p=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,S,T,k;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[$,E]=b[0];x.mask==null&&(x.mask=E),T=St(p.call($,x)),k=St(p.computeMask($,E)),w=[$],S=[E]}else w=b.map($=>$[0]),S=b.map($=>$[1]),x.mask==null&&(x.mask=S),T=St(p.call(w,x)),k=St(p.computeMask(w,S));if(p.activityRegularizer)throw new Ze("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let $=0;$<y.length;++$){const E=y[$],N=T[$],_=k[$];s[E.id]=[N,_]}}}}const i=[],o=[],l=[];for(const c of this.outputs){ni(c.id in s,`Could not compute output ${c.name} : ${c.id}`);const[h,d]=s[c.id];l.push(h.shape),i.push(h),o.push(d)}return[i,o,l]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof Or?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Or.nodeKey(r,i);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new H("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new H(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new H(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ie(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=Or.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const l=o.getClassName(),c=o.getConfig(),h=[];for(let p=0;p<o.inboundNodes.length;p++){const m=o.inboundNodes[p],y=Or.nodeKey(o,p);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const S=m.inboundLayers[w],T=m.nodeIndices[w],k=m.tensorIndices[w],$=Or.nodeKey(S,T);let E=t[$];E==null&&(E=0),x.push([S.name,E,k,b])}h.push(x)}}}const d={};d.name=o.name,d.className=l,d.config=c,d.inboundNodes=h,s.push(d)}e.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const l=this.inputLayers[o],c=this.inputLayersNodeIndices[o],h=Or.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const p=this.inputLayersTensorIndices[o];r.push([l.name,d,p])}e.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=Or.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const p=this.outputLayersTensorIndices[o];i.push([l.name,d,p])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},o={};function l(w,S){w.name in o?o[w.name].push(S):o[w.name]=[S]}function c(w,S){const T=[];let k;for(const $ of S){const E=$[0],N=$[1],_=$[2];if(k=$[3]==null?{}:$[3],!(E in i)){l(w,S);return}const R=i[E];if(R.inboundNodes.length<=N){l(w,S);return}const D=R.inboundNodes[N];T.push(D.outputTensors[_])}T.length>0&&w.apply(fs(T),k)}function h(w){const S=w.name,T=di(w,t.customObjects!=null?t.customObjects:{});T.setFastWeightInitDuringBuild(r),i[S]=T,w.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new H(`Corrupted configuration, expected array for nodeData: ${$}`);l(T,$)})}const d=t.name,p=t.layers;for(const w of p)h(w);for(;!qJ(o);)for(const w of p){const S=i[w.name];if(S.name in o){const T=o[S.name];delete o[S.name];for(const k of T)c(S,k)}}const m=[],y=[],b=t.inputLayers;for(const w of b){const S=w[0],T=w[1],k=w[2];ni(S in i);const E=i[S].inboundNodes[T].outputTensors;m.push(E[k])}const x=t.outputLayers;for(const w of x){const S=w[0],T=w[1],k=w[2];ni(S in i);const E=i[S].inboundNodes[T].outputTensors;y.push(E[k])}return new e({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new H("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ie(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function uQ(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function bM(n,e){return uQ(n,e,"classWeight")}async function xM(n,e,t,s){if(t!=null){const r=ie(()=>{if(n.shape.length===1)return Ua(n);if(n.shape.length===2){if(n.shape[1]>1)return Fh(n,1);if(n.shape[1]===1)return te(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());tt(r);const o=[];return i.forEach(l=>{if(t[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);o.push(t[l])}),Ns(o,"float32")}else return null}function hQ(n,e){return X(n,e)}const dQ=32;function vM(n,e){let t,s;const r=e;t=r.xs,s=r.ys,L(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=NN("input",n.inputNames,t),o=NN("output",n.outputNames,s),l=i[0].shape[0];L(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),L(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<i.length;c++)L(i[c].shape[0]===l,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${i[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);for(let c=0;c<o.length;c++)L(o[c].shape[0]===l,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${o[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function NN(n,e,t){if(t instanceof gn)return[t];if(Array.isArray(t))return L(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new H(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function fQ(n){if(n.length===3)throw new Ze("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function pQ(n,e,t){const s=t.batchesPerEpoch!=null;if(L(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),L(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),L(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),L(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),L(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,o;if(r)if(AN(t.validationData))L(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const w=fQ(t.validationData);i=w.xs,o=w.ys}const l=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let h;r?h=c.slice().concat(c.map(w=>"val_"+w)):h=c.slice();const d=cM(t.callbacks,t.yieldEvery),p=t.verbose==null?1:t.verbose,{callbackList:m,history:y}=uM(d,p,t.epochs,null,null,mQ(e,t),null,r,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=t.initialEpoch==null?0:t.initialEpoch,x=await e.iterator();for(;b<t.epochs;){const w={};await m.onEpochBegin(b);let S=0,T=0;for(s||(x=await e.iterator());!s||S<t.batchesPerEpoch;){const k=await x.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:$,ys:E}=vM(n,k.value),N={};N.batch=T,N.size=$[0].shape[0],await m.onBatchBegin(T,N);const _=[];if(t.classWeight!=null){const M=bM(t.classWeight,n.outputNames);for(let A=0;A<M.length;++A)_.push(await xM(E[A],null,M[A]))}const R=$.concat(E).concat(_),D=l(R);tt(R);for(let M=0;M<c.length;++M){const A=c[M],z=D[M];N[A]=z,li(z)}await m.onBatchEnd(T,N),lM(N),T++,S++}if(s?S>=t.batchesPerEpoch:k.done){if(r){let $;AN(t.validationData)?$=St(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):$=St(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?dQ:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=$[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function mQ(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function AN(n){return typeof n.iterator=="function"}function gQ(n){return typeof n.next=="function"}async function yQ(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new Ze("Verbose mode is not implemented yet.");L(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=gQ(e)?e:await e.iterator();let l=0,c=0;for(;!s||c<t.batches;){const h=await o.next();if(i=ie(()=>{if(h.value){const{xs:d,ys:p}=vM(n,h.value),m=d.concat(p),y=ie(()=>r(m));if(tt(m),c===0)for(let x=0;x<y.length;++x)i.push(bt(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],S=i[x];i[x]=ie(()=>ve(i[x],X(b,w))),c>0&&tt(S)}tt(y),l+=b,++c}return i}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<i.length;++h){const d=i[h];i[h]=Le(i[h],l),tt(d)}return fs(i)}function Px(n){L(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function rh(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Ga(s,e,t-e)):Ga(n,e,t-e)}function nw(n,e){return ie(()=>n==null?null:Array.isArray(n)?n.map(t=>nw(t,e)):KO(n,e.dtype==="int32"?e:Ee(e,"int32")))}function zx(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function wM(n){const e=[];n instanceof gn&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(lf(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function _r(n,e){if(n==null)return;const t=[];if(e instanceof gn)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof gn)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function bQ(n){return n instanceof gn}function sw(n){return Array.isArray(n)}function _N(n){return!bQ(n)&&!sw(n)}function RN(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(sw(n)&&n.length>0)o=!0;else if(_N(n)){for(const l in n)if(n.hasOwnProperty(l)){o=!0;break}}else o=!0;if(o)throw new H(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(_N(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new H(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(sw(n)){if(n=n,n.length!==e.length)throw new H(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new H(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=wM(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const l=i[o];if(l.shape.length!==t[o].length)throw new H(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${l.shape}`);for(let c=0;c<t[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=t[o][c];if(d!=null&&d>=0&&h!==d)throw new H(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${l.shape[0]} examples, each with shape [${l.shape.slice(1,l.shape.length)}] (tensor shape [${l.shape}])`)}}return i}function xQ(n,e,t){const s=Do(n.map(i=>i.shape[0]));s.sort();const r=Do(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new H(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new H(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!xt(s,r))throw new H(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function vQ(n,e,t){const s=[C0,T0,Uh];for(let r=0;r<n.length;++r){const i=n[r],o=e[r],l=t[r];if(o!=null){if(o===Uh&&i.shape[i.shape.length-1]===1)throw new H(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const c=i.shape.slice(1),h=l.slice(1);for(let d=0;d<c.length;++d){const p=c[d],m=h[d];if(m!=null&&p!==m)throw new H(`A target Tensor with shape ${i.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function DN(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new H(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new H(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const l=i[o];if(l.shape.length!==t[o].length)throw new H(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let c=0;c<t[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=t[o][c];if(d!=null&&d!==h)throw new H(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function wQ(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const SQ="layers-model";class Ec extends Or{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new H("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");rQ(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=sQ(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Jo))throw new H("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new H(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(Lx(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new H(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(l=>Lx(l))}else{const o=Lx(e.loss);this.outputs.forEach(l=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const l=this.internalOutputShapes[o],c=this.outputNames[o];this.feedOutputNames.push(c),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ja("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([l,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=wQ(e.metrics,this.outputNames),i=(o,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[o]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,o])};ja("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=r[o];(h=>{let p,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[o];w[w.length-1]===1||this.lossFunctions[o]===T0?["accuracy","acc"].indexOf(b)!==-1?m=dM:["crossentropy","ce"].indexOf(b)!==-1&&(m=qZ):this.lossFunctions[o]===Um?["accuracy","acc"].indexOf(b)!==-1?m=KZ:["crossentropy","ce"].indexOf(b)!==-1&&(m=mM):["accuracy","acc"].indexOf(b)!==-1?m=fM:["crossentropy","ce"].indexOf(b)!==-1&&(m=pM);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,p=""+S}else y=nQ(b),p=""+Xp(b);let x;ja(p,()=>{x=y}),i(o,p,x)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Px(r);const o=this.standardizeUserDataXY(e,t,!0,r);try{const l=o[0].concat(o[1]);this.makeTestFunction();const c=this.testFunction,h=this.testLoop(c,l,r,s.verbose,s.steps);return fs(h)}finally{_r(o[0],e),_r(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),yQ(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new H(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new H(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new H("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),o=new No;if(e instanceof gn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new H(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)o.add(this.inputs[c],e[c])}else for(const c of this.inputs){const h=e[c.name];if(h==null)throw new H(`No value is provided for the model's input ${c.name}`);o.add(c,h)}const l=uh(i,o);return s?l:l[0]}retrieveSymbolicTensors(e){const t=nl(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(l=>l.name);for(let l=0;l<e.length;++l){const c=o.indexOf(e[l]);if(c!==-1&&(t[l]=i[c],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,o)=>{i==null&&r.push(e[o])}),new H(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return ie(()=>{const r=this.checkNumSamples(e);if(s)throw new Ze("Verbose predictLoop() is not implemented yet.");const i=zx(r,t),o=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)ie(()=>{const h=i[l][0],d=i[l][1],p=rh(e,h,d),m=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)m.push({key:this.inputs[b],value:p[b]});else m.push({key:this.inputs[0],value:p});const y=new No(m);return uh(this.outputs,y)}).forEach((h,d)=>o[d].push(h));return fs(o.map(l=>ms(l,0)))})}predict(e,t={}){const s=wM(e);DN(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Px(r),this.predictLoop(s,r)}finally{_r(s,e)}}predictOnBatch(e){DN(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new gr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const l=this.feedOutputShapes[o];this.feedLossFns[o]===Um?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(e=RN(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=RN(t,this.feedOutputNames,i,!1,"target"),xQ(e,t),vQ(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new H(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,o){const[l,c]=this.standardizeUserDataXY(e,t,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(r!=null){const d=bM(r,this.outputNames);h=[];for(let p=0;p<d.length;++p)h.push(await xM(c[p],null,d[p]))}return[l,c,h]}testLoop(e,t,s,r=0,i){return ie(()=>{const o=this.checkNumSamples(t,s,i,"steps"),l=[];if(r>0)throw new Ze("Verbose mode is not implemented yet.");if(i!=null)throw new Ze("steps mode in testLoop() is not implemented yet");{const c=zx(o,s),h=Ns(jr(0,o));for(let d=0;d<c.length;++d){const p=c[d][0],m=c[d][1],y=Ga(h,p,m-p),b=nw(t,y),x=e(b);if(d===0)for(let w=0;w<x.length;++w)l.push(bt(0));for(let w=0;w<x.length;++w){const S=x[w];l[w]=ve(l[w],X(m-p,S))}}for(let d=0;d<l.length;++d)l[d]=Le(l[d],o)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(yN(e,r)>1){const o=yN(e.slice(0,s),r);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],l=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const m=new No(p),y=uh(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let S=w(r[x],y[x]);i[x]!=null&&(S=hQ(S,i[x]));const T=ln(S);t.push(T),x===0?b=S:b=ve(b,S)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=t[x];else{const S=this.metricsTensors[x][0],T=this.metricsTensors[x][1];w=ln(S(r[T],y[T]))}li(w),o.push(w)}return b=ln(b),this.calculateLosses().forEach(x=>{b=ve(b,x)}),b},c=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(l,!0,c)].concat(o)}}makeTestFunction(){this.testFunction=e=>ie(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let h=0;h<this.inputs.length;++h)o.push({key:this.inputs[h],value:r[h]});const l=new No(o),c=uh(this.outputs,l);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],p=ln(d(i[h],c[h]));h===0?s=p:s=ve(s,p),t.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],p=this.metricsTensors[h][1],m=ln(d(i[p],c[p]));t.push(m)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,l,c,h,d,p,m;try{const y=s.batchSize==null?32:s.batchSize;Px(y);const x=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,y);r=x[0],i=x[1],m=x[2];let w=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)c=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Ze("validationData including sample weights is not supported yet."):new H(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const M=await this.standardizeUserData(c,h,null,null,!0,y);d=M[0],p=M[1],S=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const D=Math.floor(r[0].shape[0]*(1-s.validationSplit)),M=r[0].shape[0];d=rh(r,D,M),o=r,r=rh(r,0,D),p=rh(i,D,M),l=i,i=rh(i,0,D),S=d.concat(p)}else s.validationSteps!=null&&(w=!0);const T=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),$=this.getDedupedMetricsNames();let E,N;w?(this.makeTestFunction(),E=this.testFunction,N=$.slice().concat($.map(D=>"val_"+D))):(E=null,S=[],N=$.slice());const _=cM(s.callbacks,s.yieldEvery);return await this.fitLoop(k,T,$,y,s.epochs,s.verbose,_,E,S,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,_r(r,e),_r(i,t),_r(o,e),_r(l,t),_r(d,c),_r(p,h),m!=null&&tt(m)}}async fitLoop(e,t,s,r,i,o,l,c,h,d,p,m,y,b){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(c!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new H("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(t,r,y,"steps_per_epoch");let S;w!=null&&(S=jr(0,w)),o==null&&(o=1);const{callbackList:T,history:k}=uM(l,o,i,m,w,y,r,x,p);T.setModel(this),this.history=k,await T.onTrainBegin(),this.stopTraining_=!1;for(let $=m;$<i;++$){await T.onEpochBegin($);const E={};if(y!=null)throw new Ze("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Ze("batch shuffling is not implemneted yet");d&&L5(S);const N=Ns(S),_=zx(w,r);for(let R=0;R<_.length;++R){const D={};if(await T.onBatchBegin(R,D),ie(()=>{const M=_[R][0],A=_[R][1],z=Ga(N,M,A-M);D.batch=R,D.size=A-M;const W=nw(t,z),Y=e(W);for(let K=0;K<s.length;++K){const P=s[K],B=Y[K];D[P]=B,li(B)}if(R===_.length-1&&x){const K=this.testLoop(c,h,r);for(let P=0;P<s.length;++P){const B=s[P],G=K[P];li(G),E["val_"+B]=G}}}),await T.onBatchEnd(R,D),lM(D),this.stopTraining_)break}N.dispose()}if(await T.onEpochEnd($,E),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return pQ(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],l=this.makeTrainFunction()(r.concat(i)),c=[];for(const h of l){const d=await h.data();c.push(d[0])}return tt(l),_r(s[0],e),_r(s[1],t),fs(c)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||t.push({name:r[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=UI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-UI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=zi(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>zi(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=zi(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[zi(Xp(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>zi(Xp(e)));{const e={};for(const t in this.metrics)e[t]=zi(Xp(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Hm(e.optimizer_config),s=di(t);let r;if(typeof e.loss=="string")r=Da(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Da(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Da(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Da(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Da(e.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const h=j6(e);if(h.length===0)throw new H(`Cannot find any save handlers for URL '${e}'`);if(h.length>1)throw new H(`Found more than one (${h.length}) save handlers for URL '${e}'`);e=h[0]}if(e.save==null)throw new H("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await GI(this.getNamedWeights(t)),l={modelTopology:this.toJSON(null,!1),format:SQ,generatedBy:`TensorFlow.js tfjs-layers v${yM}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:p}=await GI(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=M6([s.data,d])}return this.userDefinedMetadata!=null&&(IN(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=s.data,l.weightSpecs=s.specs,e.save(l)}setUserDefinedMetadata(e){IN(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ec.className="Model";xe(Ec);class SM extends Ec{}SM.className="Functional";xe(SM);async function CQ(n,e){if(e==null&&(e={}),typeof n=="string"){const t=G6(n,e);if(t.length===0)t.push(E7(n,e));else if(t.length>1)throw new H(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return TQ(n,void 0,e)}async function TQ(n,e,t){if(t==null&&(t={}),n.load==null)throw new H("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=t.strict==null?!0:t.strict,o=s.weightData!=null&&s.weightSpecs!=null&&i,l=di(Hm(r),e,o),c=s.trainingConfig;if(c!=null&&l.loadTrainingConfig(c),s.userDefinedMetadata!=null&&l.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new H("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=kQ(s.weightData,s.weightSpecs);l.loadWeights(h,i),l.optimizer!=null&&d.length>0&&await l.optimizer.setWeights(d),tt(h),tt(d.map(p=>p.tensor))}return l}function kQ(n,e){const t=N6(n,e),s={},r=[];return e.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:t[i.name]}):s[i.name]=t[i.name]}),{modelWeights:s,optimizerWeights:r}}class jh extends Ec{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:v0("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new H(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof jh||e instanceof Ec;let s;if(t){if(s=e,s.outputs.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new H("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new H("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=TZ({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new H(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=sM(this.outputs[0])}this.inboundNodes=[],new S0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:nl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(ft(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ec({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new gr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new gr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new gr("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new gr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new H("Legacy serialization format not supported yet.");i=t}else L(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const l=new e(o);if(!(l instanceof jh))throw new Ze(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of i){const d=di(c,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(this.model==null)throw new H("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new H("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}jh.className="Sequential";xe(jh);let Yn=class extends Jc{getConfig(){return{}}};class CM extends Yn{apply(e,t=1){return lZ(e,t)}}CM.className="elu";xe(CM);class TM extends Yn{apply(e){return zD(e)}}TM.className="selu";xe(TM);class kM extends Yn{apply(e){return ll(e)}}kM.className="relu";xe(kM);class $M extends Yn{apply(e){return ie(()=>zh(6,ll(e)))}}$M.className="relu6";xe($M);class EM extends Yn{apply(e){return e}}EM.className="linear";xe(EM);class IM extends Yn{apply(e){return Kc(e)}}IM.className="sigmoid";xe(IM);class NM extends Yn{apply(e){return uZ(e)}}NM.className="hardSigmoid";xe(NM);class AM extends Yn{apply(e){return Qd(e)}}AM.className="softplus";xe(AM);class _M extends Yn{apply(e){return cZ(e)}}_M.className="softsign";xe(_M);class RM extends Yn{apply(e){return u0(e)}}RM.className="tanh";xe(RM);let dC=class extends Yn{apply(e,t=-1){return pS(e,t)}};dC.className="softmax";xe(dC);class DM extends Yn{apply(e,t=-1){return _D(e,t)}}DM.className="logSoftmax";xe(DM);class OM extends Yn{apply(e){return ie(()=>ie(()=>{const t=Math.sqrt(2),s=X(.5,ve(1,$D(Le(e,t))));return X(e,s)}))}}OM.className="gelu";xe(OM);class MM extends Yn{apply(e){return ie(()=>X(.5,X(e,ve(1,u0(X(Kn(Le(2,Math.PI)),ve(e,X(.044715,Qa(e,3)))))))))}}MM.className="gelu_new";xe(MM);class FM extends Yn{apply(e){return ie(()=>X(e,u0(Qd(e))))}}FM.className="mish";xe(FM);class LM extends Yn{apply(e,t=1){return ie(()=>X(Kc(X(e,t)),e))}}LM.className="swish";xe(LM);function zo(n){return n.getClassName()}function Bx(n,e={}){return af(n,pr.getMap().classNameMap,e,"activation")}function Bo(n){if(n==null){const e={};return e.className="linear",e.config={},Bx(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},Bx(e)}else return n instanceof Yn?n:Bx(n)}function $Q(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class PM extends Jc{}class zM extends PM{constructor(e){super(),$Q(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ie(()=>{let t=In([1]);return this.hasL1&&(t=ve(t,Me(X(this.l1,Qn(e))))),this.hasL2&&(t=ve(t,Me(X(this.l2,cf(e))))),te(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}zM.className="L1L2";xe(zM);const ON={l1l2:"L1L2"};function At(n){return ZS(n)}function MN(n,e={}){return af(n,pr.getMap().classNameMap,e,"regularizer")}function Vt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in ON?ON[n]:n,config:{}};return MN(t)}else return n instanceof PM?n:MN(n)}class BM extends rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ge(e);let s=ll(e);return this.maxValue!=null&&(s=Xs(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}BM.className="ReLU";xe(BM);class VM extends rt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Ge(e);return rS(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}VM.className="LeakyReLU";xe(VM);class UM extends rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Bt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Vt(e.alphaRegularizer),this.alphaConstraint=vn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new H(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=ft(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new bn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Ge(e),uS(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Gt(this.alphaInitializer),alphaRegularizer:At(this.alphaRegularizer),alphaConstraint:xn(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}UM.className="PReLU";xe(UM);let jM=class extends rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Ge(e);return f0(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};jM.className="ELU";xe(jM);class GM extends rt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Ge(e);return X(s,Ee(Ys(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}GM.className="ThresholdedReLU";xe(GM);class WM extends rt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new dC().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ie(()=>{let s=Ge(e);const r=t.mask;if(r!=null){const i=X(Ve(Yo(s.shape),Ee(r,s.dtype)),bt(-1e9));s=ve(s,i)}return this.axis instanceof Array?this.axis.length>1?pi(Ve(s,RD(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}WM.className="Softmax";xe(WM);function Ic(n,e,t){if(typeof n=="number")return nl(n,e);if(n.length!==e)throw new H(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!rZ(r))throw new H(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Ur(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function si(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Po([t-e,0]);else if(s==="same")n=n*e;else throw new H(`Unsupport padding mode: ${s}.`);return n}function fC(n,e){return ie(()=>(sn(e),e==="channelsFirst"?ut(n,[0,2,3,1]):n))}function HM(n,e){return ie(()=>(sn(e),e==="channelsFirst"?ut(n,[0,2,3,4,1]):n))}function EQ(n,e,t,s=1,r="valid",i,o=1){return ie(()=>{if(i==null&&(i=Gr()),sn(i),n.shape.length!==3)throw new H(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new H(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new H(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=ut(n,[0,2,1])),r==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=wD(n,e,s,r==="same"?"same":"valid","NWC",o);return t!=null&&(l=Hr(l,t)),l})}function FN(n,e,t,s=[1,1],r="valid",i,o,l=null){return ie(()=>{if(i==null&&(i=Gr()),sn(i),n.rank!==3&&n.rank!==4)throw new H(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new H(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=fC(n,i);if(r==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=T9({x:c,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:l}),i==="channelsFirst"&&(c=ut(c,[0,3,1,2])),c})}function IQ(n,e,t,s=[1,1,1],r="valid",i,o){return ie(()=>{if(i==null&&(i=Gr()),sn(i),n.rank!==4&&n.rank!==5)throw new H(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new H(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let l=HM(n,i);if(r==="causal")throw new Ze("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=v8(l,e,s,r==="same"?"same":"valid","NDHWC",o),t!=null&&(l=Hr(l,t)),i==="channelsFirst"&&(l=ut(l,[0,4,1,2,3])),l})}class k0 extends rt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",k0.verifyArgs(t),this.rank=e,Nn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ic(t.kernelSize,e,"kernelSize"),this.strides=Ic(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Js(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,sn(this.dataFormat),this.activation=Bo(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Bt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=vn(t.biasConstraint),this.biasRegularizer=Vt(t.biasRegularizer),this.activityRegularizer=Vt(t.activityRegularizer),this.dilationRate=Ic(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new H(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new H(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new H(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ni("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!QS(e.kernelSize,"number",1,3))throw new H(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:zo(this.activation),useBias:this.useBias,biasInitializer:Gt(this.biasInitializer),biasRegularizer:At(this.biasRegularizer),activityRegularizer:At(this.activityRegularizer),biasConstraint:xn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Zc extends k0{constructor(e,t){super(e,t),this.kernel=null,Zc.verifyArgs(t),this.filters=t.filters,Nn(this.filters,"filters"),this.kernelInitializer=Bt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=vn(t.kernelConstraint),this.kernelRegularizer=Vt(t.kernelRegularizer)}build(e){e=ft(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return ie(()=>{e=Ge(e);let s;const r=this.bias==null?null:this.bias.read(),i=UO(this.activation.getClassName());if(i!=null&&this.rank===2)s=FN(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=EQ(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=FN(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=IQ(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ze("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=ft(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const o=Ur(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Gt(this.kernelInitializer),kernelRegularizer:At(this.kernelRegularizer),kernelConstraint:xn(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new H(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ff extends Zc{constructor(e){super(2,e),ff.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!QS(e.kernelSize,"number",1,2))throw new H(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ff.className="Conv2D";xe(ff);class pf extends Zc{constructor(e){super(3,e),pf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new H(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}pf.className="Conv3D";xe(pf);class qM extends ff{constructor(e){if(super(e),this.inputSpec=[new bn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ft(e),e.length!==4)throw new H("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new bn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return ie(()=>{let s=Ge(e);if(s.shape.length!==4)throw new H(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l;this.dataFormat==="channelsFirst"?(o=2,l=3):(o=1,l=2);const c=r[o],h=r[l],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=si(c,m,d,this.padding),x=si(h,y,p,this.padding),w=[i,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=ut(s,[0,2,3,1]));let S=SD(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=ut(S,[0,3,1,2])),this.bias!=null&&(S=Hr(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(e){e=ft(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1];return t[s]=this.filters,t[r]=si(t[r],c,o,this.padding),t[i]=si(t[i],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}qM.className="Conv2DTranspose";xe(qM);class KM extends pf{constructor(e){if(super(e),this.inputSpec=[new bn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ft(e),e.length!==5)throw new H("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new bn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return ie(()=>{let s=Ge(e);if(s.shape.length!==5)throw new H(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l,c;this.dataFormat==="channelsFirst"?(c=2,o=3,l=4):(c=1,o=2,l=3);const h=r[c],d=r[o],p=r[l],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],S=this.strides[2],T=si(h,x,m,this.padding),k=si(d,w,y,this.padding),$=si(p,S,b,this.padding),E=[i,T,k,$,this.filters];this.dataFormat!=="channelsLast"&&(s=ut(s,[0,2,3,4,1]));let N=C8(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=ut(N,[0,4,1,2,3])),this.bias!==null&&(N=Hr(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(e){e=ft(e);const t=e.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const l=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return t[s]=this.filters,t[r]=si(t[r],d,l,this.padding),t[i]=si(t[i],p,c,this.padding),t[o]=si(t[o],m,h,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}KM.className="Conv3DTranspose";xe(KM);class XM extends Zc{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new H("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new H("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new H(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Bt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Vt(t.depthwiseRegularizer),this.depthwiseConstraint=vn(t.depthwiseConstraint),this.pointwiseInitializer=Bt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Vt(t.pointwiseRegularizer),this.pointwiseConstraint=vn(t.pointwiseConstraint)}build(e){if(e=ft(e),e.length<this.rank+2)throw new H(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new H(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new bn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return ie(()=>{e=Ge(e);let s;if(this.rank===1)throw new Ze("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ut(e,[0,2,3,1])),s=BD(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Hr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=ut(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Gt(this.depthwiseInitializer),e.pointwiseInitializer=Gt(this.pointwiseInitializer),e.depthwiseRegularizer=At(this.depthwiseRegularizer),e.pointwiseRegularizer=At(this.pointwiseRegularizer),e.depthwiseConstraint=xn(this.depthwiseConstraint),e.pointwiseConstraint=xn(this.pointwiseConstraint),e}}XM.className="SeparableConv";class YM extends XM{constructor(e){super(2,e)}}YM.className="SeparableConv2D";xe(YM);class $0 extends Zc{constructor(e){super(1,e),$0.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!QS(e.kernelSize,"number",1,1))throw new H(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}$0.className="Conv1D";xe($0);class JM extends rt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ie(()=>{if(e=Ge(e),this.dataFormat==="channelsLast"){const s=Kp(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Kp(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Kp(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Kp(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}JM.className="Cropping2D";xe(JM);class ZM extends rt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,sn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,tZ(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return ie(()=>{let s=Ge(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=ut(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],l=this.interpolation==="nearest"?Vi.resizeNearestNeighbor(s,[i,o]):Vi.resizeBilinear(s,[i,o]);return ut(l,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Vi.resizeNearestNeighbor(s,[i,o]):Vi.resizeBilinear(s,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}ZM.className="UpSampling2D";xe(ZM);function NQ(n,e,t=[1,1],s="valid",r,i){return ie(()=>{r==null&&(r=Gr()),sn(r);let o=fC(n,r);if(n.rank!==4)throw new H(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new H(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=eS(o,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=ut(o,[0,3,1,2])),o})}class QM extends k0{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Bt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=vn(e.depthwiseConstraint),this.depthwiseRegularizer=Vt(e.depthwiseRegularizer)}build(e){if(e=ft(e),e.length<4)throw new H(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new H(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ie(()=>{e=Ge(e);let s=NQ(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Hr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=ft(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Ur(t,this.kernelSize[0],this.padding,this.strides[0]),o=Ur(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,o]:[e[0],i,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Gt(this.depthwiseInitializer),e.depthwiseRegularizer=At(this.depthwiseRegularizer),e.depthwiseConstraint=xn(this.depthwiseRegularizer),e}}QM.className="DepthwiseConv2D";xe(QM);function e3(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new H("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function t3(n,e,t,s=!1,r,i,o=!1,l=!1){return ie(()=>{const c=e.shape.length;if(c<3)throw new H(`Input should be at least 3D, but is ${c}D.`);const h=[1,0].concat(jr(2,c));e=ut(e,h),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ee(Ee(r,"bool"),"float32"),r.rank===c-1&&(r=ds(r,-1)),r=ut(r,h)),s&&(e=el(e,0),r!=null&&(r=el(r,0)));const d=[];let p,m=t;const y=e.shape[0],b=tl(e);let x;r!=null&&(x=tl(r));for(let S=0;S<y;++S){const T=b[S],k=ie(()=>n(T,m));if(r==null)p=k[0],m=k[1];else{const $=ie(()=>{const E=x[S],N=Ve(vr(E),E),_=ve(X(k[0],E),X(m[0],N)),R=m.map((D,M)=>ve(X(k[1][M],E),X(D,N)));return{output:_,newStates:R}});p=$.output,m=$.newStates}l&&d.push(p)}let w;return l&&(w=Wi(d,1)),[p,w,m]})}class Zo extends rt{constructor(e){super(e);let t;if(e.cell==null)throw new H("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new gC({cells:e.cell}):t=e.cell,t.stateSize==null)throw new H("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new bn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return jr(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Zv(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[r].concat(i)}else return r}computeMask(e,t){return ie(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ze("Constants support is not implemented in RNN yet.");Zv(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new bn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!xt(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new H(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new bn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){ie(()=>{if(!this.stateful)throw new ti("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>In([s,r])):this.states_=[In([s,this.cell.stateSize])];else if(e==null)tt(this.states_),this.keptStates!=null&&(tt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>In([s,r])):this.states_[0]=In([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):tt(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,l=[s,o];if(!xt(i.shape,l))throw new H(`State ${r} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>li(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=e3(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let o=[],l=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new bn({shape:h.shape}));l=l.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof gi){const h=[e].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return ie(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=Ge(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new H(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:r},h=t3((b,x)=>{const w=this.cell.call([b].concat(x),l);return[w[0],w.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],p=h[1],m=h[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?p:d;return this.returnState?[y].concat(m):y})}getInitialState(e){return ie(()=>{let t=In(e.shape);return t=Me(t,[1,2]),t=lf(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Yv(t,[1,s]):t):this.cell.stateSize>1?[Yv(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Zo.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=di(r,s);return new e(Object.assign(t,{cell:i}))}}Zo.className="RNN";xe(Zo);class E0 extends rt{}class pC extends E0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Nn(this.units,"units"),this.activation=Bo(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Bt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Vt(e.kernelRegularizer),this.recurrentRegularizer=Vt(e.recurrentRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.kernelConstraint=vn(e.kernelConstraint),this.recurrentConstraint=vn(e.recurrentConstraint),this.biasConstraint=vn(e.biasConstraint),this.dropout=Fc([1,Po([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fc([1,Po([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ft(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ie(()=>{if(e=e,e.length!==2)throw new H(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>vr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>vr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,l=this.recurrentDropoutMask;o!=null?i=hi(X(e,o),this.kernel.read()):i=hi(e,this.kernel.read()),this.bias!=null&&(i=Hr(i,this.bias.read())),l!=null&&(s=X(s,l));let c=ve(i,hi(s,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:Gt(this.kernelInitializer),recurrentInitializer:Gt(this.recurrentInitializer),biasInitializer:Gt(this.biasInitializer),kernelRegularizer:At(this.kernelRegularizer),recurrentRegularizer:At(this.recurrentRegularizer),biasRegularizer:At(this.biasRegularizer),activityRegularizer:At(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),recurrentConstraint:xn(this.recurrentConstraint),biasConstraint:xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}pC.className="SimpleRNNCell";xe(pC);class n3 extends Zo{constructor(e){e.cell=new pC(e),super(e)}call(e,t){return ie(()=>{this.cell.dropoutMask!=null&&(tt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}n3.className="SimpleRNN";xe(n3);class mC extends E0{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new H("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Nn(this.units,"units"),this.activation=Bo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Bo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Bt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Vt(e.kernelRegularizer),this.recurrentRegularizer=Vt(e.recurrentRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.kernelConstraint=vn(e.kernelConstraint),this.recurrentConstraint=vn(e.recurrentConstraint),this.biasConstraint=vn(e.biasConstraint),this.dropout=Fc([1,Po([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fc([1,Po([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ft(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ie(()=>{if(e=e,e.length!==2)throw new H(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>vr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>vr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h;0<this.dropout&&this.dropout<1&&(e=X(e,i[0]));let d=hi(e,this.kernel.read());this.useBias&&(d=Hr(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=X(r,o[0]));const p=this.recurrentKernel.read(),[m,y]=Ks(p,[2*this.units,this.units],p.rank-1),b=hi(r,m),[x,w,S]=Ks(d,3,d.rank-1),[T,k]=Ks(b,2,b.rank-1);l=this.recurrentActivation.apply(ve(x,T)),c=this.recurrentActivation.apply(ve(w,k));const $=hi(X(c,r),y);h=this.activation.apply(ve(S,$));const E=ve(X(l,r),X(ve(1,en(l)),h));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Gt(this.kernelInitializer),recurrentInitializer:Gt(this.recurrentInitializer),biasInitializer:Gt(this.biasInitializer),kernelRegularizer:At(this.kernelRegularizer),recurrentRegularizer:At(this.recurrentRegularizer),biasRegularizer:At(this.biasRegularizer),activityRegularizer:At(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),recurrentConstraint:xn(this.recurrentConstraint),biasConstraint:xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}mC.className="GRUCell";xe(mC);class s3 extends Zo{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mC(e),super(e)}call(e,t){return ie(()=>{this.cell.dropoutMask!=null&&(tt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}s3.className="GRU";xe(s3);class I0 extends E0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Nn(this.units,"units"),this.activation=Bo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Bo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Bt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Vt(e.kernelRegularizer),this.recurrentRegularizer=Vt(e.recurrentRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.kernelConstraint=vn(e.kernelConstraint),this.recurrentConstraint=vn(e.recurrentConstraint),this.biasConstraint=vn(e.biasConstraint),this.dropout=Fc([1,Po([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fc([1,Po([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=ft(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(t=class extends Sr{apply(c,h){const d=i.apply([o]),p=new tC().apply([o]),m=i.apply([o*2]);return xN(xN(d,p),m)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ie(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new H(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>vr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>vr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=this.recurrentDropoutMask;let c,h,d,p;0<this.dropout&&this.dropout<1&&(e=X(e,o[0]));let m=hi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=X(r,l[0])),m=ve(m,hi(r,this.recurrentKernel.read())),this.useBias&&(m=Hr(m,this.bias.read()));const[y,b,x,w]=Ks(m,4,m.rank-1);c=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=ve(X(h,i),X(c,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const S=X(p,this.activation.apply(d));return[S,S,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Gt(this.kernelInitializer),recurrentInitializer:Gt(this.recurrentInitializer),biasInitializer:Gt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:At(this.kernelRegularizer),recurrentRegularizer:At(this.recurrentRegularizer),biasRegularizer:At(this.biasRegularizer),activityRegularizer:At(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),recurrentConstraint:xn(this.recurrentConstraint),biasConstraint:xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}I0.className="LSTMCell";xe(I0);class r3 extends Zo{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new I0(e),super(e)}call(e,t){return ie(()=>{this.cell.dropoutMask!=null&&(tt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}r3.className="LSTM";xe(r3);class gC extends E0{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ie(()=>{e=e;let s=e.slice(1);const r=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?r.push(s.splice(0,l.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=r[l],l===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=c.call(o,t),i.push(o.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[o[0]].concat(s)})}build(e){Zv(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{ja(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(di(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Qv(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],i[o]])}lC(t)}}gC.className="StackedRNNCells";xe(gC);function Vo(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):XO(e(),t),l=()=>uf(o,e,s);return!r||r<=1?li(l().clone()):Array(r).fill(void 0).map(l).map(h=>li(h.clone()))}var AQ=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class i3 extends Zo{constructor(e){if(e.unroll)throw new Ze("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ze("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new bn({ndim:5})]}call(e,t){return ie(()=>{if(this.cell.dropoutMask!=null&&(tt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new H("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ie(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=In(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){ie(()=>{if(!this.stateful)throw new ti("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>In(i)):this.states_=[In(i)];else if(e==null)tt(this.states_),this.keptStates!=null&&(tt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>In(i)):this.states_[0]=In(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):tt(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],h=i;if(!xt(c.shape,h))throw new H(`State ${l} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>li(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:l}=this.cell,c=t==="channelsFirst",h=e[c?3:2],d=e[c?4:3],p=Ur(h,r[0],i,o[0],l[0]),m=Ur(d,r[1],i,o[1],l[1]);return[...e.slice(0,2),...c?[s,p,m]:[p,m,s]]}}i3.className="ConvRNN2D";class yC extends I0{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Nn(this.filters,"filters"),this.kernelSize=Ic(s,2,"kernelSize"),this.kernelSize.forEach(c=>Nn(c,"kernelSize")),this.strides=Ic(r||1,2,"strides"),this.strides.forEach(c=>Nn(c,"strides")),this.padding=i||"valid",Js(this.padding),this.dataFormat=o||"channelsLast",sn(this.dataFormat),this.dilationRate=Ic(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Nn(c,"dilationRate"))}build(e){var t;e=ft(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;c=new(t=class extends Sr{apply(m,y){const b=h.apply([d]),x=Yo([d]),w=h.apply([d*2]);return eC([b,x,w])}},t.className="CustomInit",t)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ie(()=>{if(e.length!==3)throw new H(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],o=e[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>vr(r),rate:this.dropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,h=(Z,F,V)=>!F||!F[V]?Z:X(F[V],Z);let d=h(r,c,0),p=h(r,c,1),m=h(r,c,2),y=h(r,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>vr(i),rate:this.recurrentDropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(i,b,0),w=h(i,b,1),S=h(i,b,2),T=h(i,b,3);const k=3,[$,E,N,_]=Ks(this.kernel.read(),l,k),[R,D,M,A]=this.useBias?Ks(this.bias.read(),l):[null,null,null,null];d=this.inputConv(d,$,R,this.padding),p=this.inputConv(p,E,D,this.padding),m=this.inputConv(m,N,M,this.padding),y=this.inputConv(y,_,A,this.padding);const[z,W,Y,K]=Ks(this.recurrentKernel.read(),l,k);x=this.recurrentConv(x,z),w=this.recurrentConv(w,W),S=this.recurrentConv(S,Y),T=this.recurrentConv(T,K);const P=this.recurrentActivation.apply(ve(d,x)),B=this.recurrentActivation.apply(ve(p,w)),G=ve(X(B,o),X(P,this.activation.apply(ve(m,S)))),ee=X(this.recurrentActivation.apply(ve(y,T)),this.activation.apply(G));return[ee,ee,G]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=AQ(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=Za(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Hr(i,s,this.dataFormat):i}recurrentConv(e,t){return Za(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}yC.className="ConvLSTM2DCell";xe(yC);class o3 extends i3{constructor(e){const t=new yC(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}o3.className="ConvLSTM2D";xe(o3);class bC extends rt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return uf(()=>XO(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}bC.className="Dropout";xe(bC);class a3 extends bC{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}a3.className="SpatialDropout1D";xe(a3);class l3 extends rt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Nn(this.units,"units"),this.activation=Bo(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=vn(e.kernelConstraint),this.biasConstraint=vn(e.biasConstraint),this.kernelRegularizer=Vt(e.kernelRegularizer),this.biasRegularizer=Vt(e.biasRegularizer),this.activityRegularizer=Vt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=ft(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=ft(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e),r=UO(this.activation.getClassName());let i;return r!=null?i=hi(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=hi(s,this.kernel.read()),this.bias!=null&&(i=Hr(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:Gt(this.kernelInitializer),biasInitializer:Gt(this.biasInitializer),kernelRegularizer:At(this.kernelRegularizer),biasRegularizer:At(this.biasRegularizer),activityRegularizer:At(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),biasConstraint:xn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}l3.className="Dense";xe(l3);class c3 extends rt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ft(e);for(const t of e.slice(1))if(t==null)throw new H(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Oo(e,1)]}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let s=Ge(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=ut(s,r)}return aZ(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}c3.className="Flatten";xe(c3);class u3 extends rt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Bo(e.activation)}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e);return this.activation.apply(s)})}getConfig(){const e={activation:zo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}u3.className="Activation";xe(u3);class h3 extends rt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ie(()=>(e=Ge(e),iZ(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}h3.className="RepeatVector";xe(h3);class d3 extends rt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,o=null;for(let c=0;c<r.length;++c){const h=r[c];if(this.isUnknown(h))if(o===null)o=c;else throw new H("Can only specifiy one unknown dimension.");else i*=h}const l=Oo(e);if(o!==null){if(i===0||l%i!==0)throw new H(s);r[o]=l/i}else if(l!==i)throw new H(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return te(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}d3.className="Reshape";xe(d3);class f3 extends rt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=jr(1,e.dims.length+1);if(!xt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new bn({ndim:this.dims.length+1})]}computeOutputShape(e){e=ft(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return ut(Ge(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}f3.className="Permute";xe(f3);class p3 extends rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Ge(e);return jv(Om(s,this.maskValue),-1)}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e),o=jv(Om(s,this.maskValue),-1,!0);return X(s,Ee(o,s.dtype))})}}p3.className="Masking";xe(p3);class m3 extends rt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(St(e.inputLength))}this.inputDim=e.inputDim,Nn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Nn(this.outputDim,"outputDim"),this.embeddingsInitializer=Bt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Vt(e.embeddingsRegularizer),this.activityRegularizer=Vt(e.activityRegularizer),this.embeddingsConstraint=vn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ie(()=>this.maskZero?(e=Ge(e),Om(e,ht(e))):null)}computeOutputShape(e){if(e=ft(e),this.inputLength==null)return[...e,this.outputDim];const t=St(this.inputLength);if(t.length!==e.length-1)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],o=e[r+1];if(i!=null&&o!=null&&i!==o)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let s=Ge(e);s.dtype!=="int32"&&(s=ui(s,"int32"));const r=KO(this.embeddings.read(),te(s,[s.size]));return te(r,ft(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Gt(this.embeddingsInitializer),embeddingsRegularizer:At(this.embeddingsRegularizer),activityRegularizer:At(this.activityRegularizer),embeddingsConstraint:xn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}m3.className="Embedding";xe(m3);class hl extends rt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ze}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],o=t[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new H("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[ft(e)]),e=e,e.length<2)throw new H(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Do(t),t.length>1)throw new H(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Do(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ie(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Po(r);for(let o of e){const l=o.rank;for(let c=0;c<i-l;++c)o=lf(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const c of e){const h=c.rank;if(h==null){const d=c.shape,p=d[0],m=d.slice(1).concat([p]);let y=te(c,[p].concat(Oo(d.slice(1))));y=ut(y,[1,0]),y=te(y,m),s.push(y),i=!0}else if(h>1){const d=jr(1,h).concat([0]);s.push(ut(c,d)),i=!0}else s.push(c)}let o=this.mergeFunction(s);const l=o.rank;if(i){if(l==null){const c=o.shape,h=c.length,d=c[h-1],p=[d].concat(c.slice(0,c.length-1));o=te(ut(te(o,[-1,d]),[1,0]),p)}else if(l>1){const c=[l-1].concat(jr(0,l-1));o=ut(o,c)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Do(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return ie(()=>{if(t==null)return null;if(!Array.isArray(t))throw new H("`mask` should be an Array");if(!Array.isArray(e))throw new H("`inputs` should be an Array");if(t.length!==e.length)throw new H(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:ds(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Gi(s,t[r]);return s})}}class g3 extends hl{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ve(t,e[s]);return t})}}g3.className="Add";xe(g3);class y3 extends hl{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=X(t,e[s]);return t})}}y3.className="Multiply";xe(y3);class b3 extends hl{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ve(t,e[s]);return X(1/e.length,t)})}}b3.className="Average";xe(b3);class x3 extends hl{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Xo(t,e[s]);return t})}}x3.className="Maximum";xe(x3);class v3 extends hl{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=zh(t,e[s]);return t})}}v3.className="Minimum";xe(v3);class w3 extends hl{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new H("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let o=!1;for(const l of s)if(xt(l,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new H("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ie(()=>eC(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new H("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new H("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new H("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new H(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ie(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(Ee(vr(e[o]),"bool")):t[o].rank<e[o].rank?r.push(ds(t[o],-1)):r.push(t[o]);const i=ms(r,this.axis);return vD(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}w3.className="Concatenate";xe(w3);function ih(n,e){for(;n<0;)n+=e;return n}function _Q(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Ze("batchDot is not implemented for tensors of 4D or higher rank yet");if(L(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),L(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Ze("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return ie(()=>{let o;if(s>r){o=s-r;const c=[];for(let h=0;h<o;++h)c.push(1);e=te(e,e.shape.concat(c))}else if(r>s){o=r-s;const c=[];for(let h=0;h<o;++h)c.push(1);n=te(n,n.shape.concat(c))}else o=0;let l;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?l=Me(X(n,e),i[0]):l=Me(X(ut(n,[1,0]),e),i[1]);else{const c=i[0]!==n.shape.length-1,h=i[1]===e.shape.length-1;l=yt(n,e,c,h)}if(o>0){let c;s>r?c=s+r-3:c=s-1;const h=[];for(let d=c;d<c+o;++d)h.push(d);l=tf(l,h)}return l.shape.length===1&&(l=ds(l,1)),l})}class S3 extends hl{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){L(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new H(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new H(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>ih(i,e[o].shape.length)):r=[ih(this.axes,t.shape.length),ih(this.axes,s.shape.length)],this.normalize&&(t=Vm(t,r[0]),s=Vm(s,r[1])),_Q(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[ih(this.axes,e.length),ih(this.axes,t.length)],s}computeOutputShape(e){L(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}S3.className="Dot";xe(S3);class C3 extends rt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e);return uf(()=>ve(w0(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}C3.className="GaussianNoise";xe(C3);class T3 extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ie(()=>{this.invokeCallHook(e,t);const s=Ge(e);return this.rate>0&&this.rate<1?uf(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return X(s,w0(s.shape,1,i))},()=>s,t.training||!1):s})}}T3.className="GaussianDropout";xe(T3);class k3 extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ge(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ie(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return uf(()=>{const i=Ge(e),l=-1.6732632423543772*1.0507009873554805;let c=al(ef(s),this.rate);c=ui(c,"float32");const h=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-h*l*this.rate,p=ve(X(i,c),X(ve(c,-1),l));return ve(X(p,h),d)},()=>Ge(e),t.training||!1)}return e})}}k3.className="AlphaDropout";xe(k3);function Gh(n,e,t,s,r,i=.001){let o;if(n.rank===2)o=Yq(n,e,t,s,r,i);else if(n.rank===3)o=Zq(n,e,t,s,r,i);else if(n.rank===4)o=e8(n,e,t,s,r,i);else throw new Ze(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function RQ(n,e,t,s,r=.001){return ie(()=>{const i=aS(n,s),o=i.mean,l=i.variance;return[Gh(n,o,l,t,e,r),o,l]})}function DQ(n,e,t,s,r=.001){return ie(()=>{const i=aS(n,s),o=i.mean,l=i.variance,c=[];for(const b of jr(0,n.rank))s.indexOf(b)!==-1?c.push(1):c.push(n.shape[b]);const h=te(o,c),d=te(l,c),p=e==null?null:te(e,c),m=t==null?null:te(t,c);return[Gh(n,h,d,m,p,r),o,l]})}function OQ(n,e,t,s,r=.001){return xt(s.slice().sort(),jr(0,n.rank-1))?RQ(n,e,t,s,r):DQ(n,e,t,s,r)}class $3 extends rt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Bt(e.betaInitializer||"zeros"),this.gammaInitializer=Bt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Bt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Bt(e.movingVarianceInitializer||"ones"),this.betaConstraint=vn(e.betaConstraint),this.gammaConstraint=vn(e.gammaConstraint),this.betaRegularizer=Vt(e.betaRegularizer),this.gammaRegularizer=Vt(e.gammaRegularizer)}build(e){e=ft(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new H(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new bn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ie(()=>{const s=t.training==null?!1:t.training,r=Ge(e),i=r.shape,o=i.length,l=jr(0,o),c=this.axis>=0?this.axis:this.axis+o;l.splice(c,1);const h=nl(1,o);h[c]=i[c];const d=l.slice();d.sort();const p=!xt(d,jr(0,o).slice(0,o-1)),m=()=>{if(p){const T=te(this.movingMean.read(),h),k=te(this.movingVariance.read(),h),$=this.center?te(this.beta.read(),h):null,E=this.scale?te(this.gamma.read(),h):null;return Gh(r,T,k,$,E,this.epsilon)}else return Gh(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=OQ(r,this.gamma.read(),this.beta.read(),l,this.epsilon),w=(T,k,$)=>{ie(()=>{const E=1-$,N=T.read(),_=X(Ve(N,k),E);T.write(Ve(N,_))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Gt(this.betaInitializer),gammaInitializer:Gt(this.gammaInitializer),movingMeanInitializer:Gt(this.movingMeanInitializer),movingVarianceInitializer:Gt(this.movingVarianceInitializer),betaRegularizer:At(this.betaRegularizer),gammaRegularizer:At(this.gammaRegularizer),betaConstraint:xn(this.betaConstraint),gammaConstraint:xn(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}$3.className="BatchNormalization";xe($3);class E3 extends rt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Bt(e.betaInitializer||"zeros"),this.gammaInitializer=Bt(e.gammaInitializer||"ones"),this.betaRegularizer=Vt(e.betaRegularizer),this.gammaRegularizer=Vt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=ft(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Do(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=Ge(e),r=s.shape,i=r.length;return ie(()=>{let{mean:l,variance:c}=aS(s,this.axis,!0);const h=nl(1,i);for(const x of this.axis)h[x]=r[x];const d=x=>x!=null&&x.shape.length!==i?te(x,h):x;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<i;++x)this.axis.indexOf(x)!==-1?(y.push(r[x]),b.push(1)):(y.push(1),b.push(r[x]));return l=zr(l,y),c=zr(c,y),p!=null&&(p=zr(p,b)),m!=null&&(m=zr(m,b)),Gh(s,l,c,m,p,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Gt(this.betaInitializer),gammaInitializer:Gt(this.gammaInitializer),betaRegularizer:At(this.betaRegularizer),gammaRegularizer:At(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}E3.className="LayerNormalization";xe(E3);function MQ(n,e,t){return ie(()=>{if(n.rank!==4)throw new H(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new H("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Gr()),t!=="channelsLast"&&t!=="channelsFirst")throw new H(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],lS(n,s)})}class I3 extends rt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Gr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new H(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new H(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new H(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new bn({ndim:4})]}computeOutputShape(e){e=ft(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return ie(()=>MQ(Ge(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}I3.className="ZeroPadding2D";xe(I3);function N0(n,e,t,s,r,i){return ie(()=>{sn(r),GO(i),Js(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Gr()),i==null&&(i="max"),n=fC(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=oS(n,e,t,l):o=Y1(n,e,t,l),r==="channelsFirst"&&(o=ut(o,[0,3,1,2])),o})}function N3(n,e,t,s,r,i){return ie(()=>{sn(r),GO(i),Js(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Gr()),i==null&&(i="max"),n=HM(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=PK(n,e,t,l):o=Bq(n,e,t,l),r==="channelsFirst"&&(o=ut(o,[0,4,1,2,3])),o})}class A3 extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new H(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Nn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new H(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Nn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Js(this.padding),this.inputSpec=[new bn({ndim:3})]}computeOutputShape(e){e=ft(e);const t=Ur(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ie(()=>{this.invokeCallHook(e,t),e=lf(Ge(e),2);const s=this.poolingFunction(Ge(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return tf(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class _3 extends A3{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return sn(i),Js(r),N0(e,t,s,r,i,"max")}}_3.className="MaxPooling1D";xe(_3);class R3 extends A3{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return sn(i),Js(r),N0(e,t,s,r,i,"avg")}}R3.className="AveragePooling1D";xe(R3);class D3 extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new H(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Nn(this.poolSize,"poolSize"),Nn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,sn(this.dataFormat),Js(this.padding),this.inputSpec=[new bn({ndim:4})]}computeOutputShape(e){e=ft(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Ur(t,this.poolSize[0],this.padding,this.strides[0]),s=Ur(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return ie(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class O3 extends D3{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return sn(i),Js(r),N0(e,t,s,r,i,"max")}}O3.className="MaxPooling2D";xe(O3);class M3 extends D3{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return sn(i),Js(r),N0(e,t,s,r,i,"avg")}}M3.className="AveragePooling2D";xe(M3);class F3 extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new H(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Nn(this.poolSize,"poolSize"),Nn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,sn(this.dataFormat),Js(this.padding),this.inputSpec=[new bn({ndim:5})]}computeOutputShape(e){e=ft(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Ur(t,this.poolSize[0],this.padding,this.strides[0]),s=Ur(s,this.poolSize[1],this.padding,this.strides[1]),r=Ur(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return ie(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class L3 extends F3{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return sn(i),Js(r),N3(e,t,s,r,i,"max")}}L3.className="MaxPooling3D";xe(L3);class P3 extends F3{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return sn(i),Js(r),N3(e,t,s,r,i,"avg")}}P3.className="AveragePooling3D";xe(P3);class z3 extends rt{constructor(e){super(e),this.inputSpec=[new bn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ze}}class B3 extends z3{constructor(e){super(e||{})}call(e,t){return ie(()=>{const s=Ge(e);return ln(s,1)})}}B3.className="GlobalAveragePooling1D";xe(B3);class V3 extends z3{constructor(e){super(e||{})}call(e,t){return ie(()=>{const s=Ge(e);return Vr(s,1)})}}V3.className="GlobalMaxPooling1D";xe(V3);class U3 extends rt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,sn(this.dataFormat),this.inputSpec=[new bn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ze}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class j3 extends U3{call(e,t){return ie(()=>{const s=Ge(e);return this.dataFormat==="channelsLast"?ln(s,[1,2]):ln(s,[2,3])})}}j3.className="GlobalAveragePooling2D";xe(j3);class G3 extends U3{call(e,t){return ie(()=>{const s=Ge(e);return this.dataFormat==="channelsLast"?Vr(s,[1,2]):Vr(s,[2,3])})}}G3.className="GlobalMaxPooling2D";xe(G3);class W3 extends rt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=di(r,s);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class H3 extends W3{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=ft(e),e.length<3)throw new H(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=ft(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return ie(()=>(e=Ge(e),t3((o,l)=>[Ge(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}H3.className="TimeDistributed";xe(H3);function FQ(n){ul(eZ,"BidirectionalMergeMode",n)}const LQ="concat";class q3 extends W3{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=di(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=di(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?LQ:e.mergeMode,FQ(this.mergeMode),e.weights)throw new Ze("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):fs(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=e3(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const o=[],l=[];if(s!=null){const h=s.length;if(h%2>0)throw new H("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const d=s.map(p=>new bn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),l.push(...d)}if(r!=null)throw new Ze("Support for constants in Bidirectional layers is not implemented yet.");const c=o[0]instanceof gi;for(const h of o)if(h instanceof gi!==c)throw new H("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const h=[e].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return ie(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const c=s.slice(0,s.length/2),h=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:c})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:h}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=el(i,1));let l;return this.mergeMode==="concat"?l=eC([r,i]):this.mergeMode==="sum"?l=ve(r,i):this.mergeMode==="ave"?l=X(.5,ve(r,i)):this.mergeMode==="mul"?l=X(r,i):this.mergeMode==null&&(l=[r,i]),this.returnState?this.mergeMode==null?l.concat(o):[l].concat(o):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ja(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ja(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=di(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ze("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}q3.className="Bidirectional";xe(q3);class K3 extends rt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ie(()=>(e=Ge(e),e.dtype!=="float32"&&(e=ui(e,"float32")),ve(X(e,this.scale),this.offset)))}}K3.className="Rescaling";xe(K3);const{resizeBilinear:PQ,cropAndResize:zQ}=Vi;class X3 extends rt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,o,l,c){return ie(()=>{let h,d=!1;const p=t/o,m=s/l,y=(r+t)/o,b=(i+s)/l,x=[p,m,y,b],w=[];e.rank===3?(d=!0,h=Wi([e])):h=e;for(let E=0;E<h.shape[0];E++)w.push(x);const S=wh(w,[w.length,4]),T=Bh(0,w.length,1,"int32"),$=zQ(h,S,T,[r,i],"nearest");return ui(d?Ge(tl($)):$,c)})}upsize(e,t,s,r){return ie(()=>{const i=PQ(e,[t,s]);return ui(i,r)})}call(e,t){return ie(()=>{const s=Ge(e),r=s.dtype,i=s.shape,o=i[i.length-3],l=i[i.length-2];let c=0;o!==this.height&&(c=Math.floor((o-this.height)/2));let h=0;return l!==this.width&&(h=Math.floor((l-this.width)/2),h===0&&(h=1)),c>=0&&h>=0?this.centerCrop(s,c,h,this.height,this.width,o,l,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=ft(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}X3.className="CenterCrop";xe(X3);function BQ(n,e,t,s){let r=Ge(n);if(r.dtype!=="int32"&&(r=ui(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=ds(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=ds(r,-1)),r.rank>2)throw new H(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),l=r;let c;if(typeof s<"u"&&e==="count"?c=KI(l,s,t,o):c=KI(l,[],t,o),e!=="tfIdf")return c;if(s)return X(c,s);throw new H("When outputMode is 'tfIdf', weights must be provided.")}class Y3 extends rt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=ft(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ie(()=>{e=Ge(e),e.dtype!=="int32"&&(e=ui(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new H(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Ge(t.countWeights)}const r=Vr(e),i=Rm(e),o=Ys(this.numTokens,r).bufferSync().get(0),l=al(i,0).bufferSync().get(0);if(!(o&&l))throw new H(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return BQ(e,this.outputMode,this.numTokens,s)})}}Y3.className="CategoryEncoding";xe(Y3);const VQ=["bilinear","nearest"],LN=new Set(VQ);class J3 extends rt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(LN.has(e.interpolation))this.interpolation=e.interpolation;else throw new H(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=ft(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ie(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Vi.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Vi.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...LN]} are supported`)})}}J3.className="Resizing";xe(J3);class Z3{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}Z3.className="RandomSeed";class Q3 extends rt{constructor(e){super(e),this.randomGenerator=new Z3(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}Q3.className="BaseRandomLayer";const UQ=["bilinear","nearest"],PN=new Set(UQ);class eF extends Q3{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new H(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new H(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new H(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(PN.has(s))this.interpolation=s;else throw new H(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=ft(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ie(()=>{const s=Ge(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=ef([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Vi.resizeBilinear(e,o);case"nearest":return Vi.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...PN]} are supported`)}})}}eF.className="RandomWidth";xe(eF);const jQ=ce();jQ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var zN;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(zN||(zN={}));var BN;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(BN||(BN={}));var VN;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(VN||(VN={}));function Ae(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&L(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const GQ=KD;class A0 extends Zw{nextDataId(){return A0.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new wR(this,Qr())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ce().get("IS_NODE")&&Hs(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&ed(s[0])){const i=s.map(o=>Ro(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Hi(r,i)}return j5(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Lo(r));return nt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return nt(e.shape,e.dtype,t)}makeOutput(e,t,s){return Qr().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=hs();return e(),{kernelMs:hs()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ae([e],"where");const t=this.readSync(e.dataId);return GQ(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}A0.nextDataId=0;function tF(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const WQ=n=>{const{x:e}=n.inputs,t=n.backend;Ae(e,"abs");let s=new Float32Array(pe(e.shape));const r=t.data.get(e.dataId).values;return s=tF(r),t.makeOutput(s,e.shape,e.dtype)},HQ={kernelName:cg,backendName:"cpu",kernelFunc:WQ};function rn(n){return(e,t,s,r,i)=>{const o=Ye(e,t),l=o.length,c=Oe(o),h=pe(o),d=Hn(i,h),p=e.length,m=t.length,y=Oe(e),b=Oe(t),x=Oc(e,o),w=Oc(t,o);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=n(s[S%s.length],r[S%r.length]);else for(let S=0;S<d.length;++S){const T=Hc(S,l,c),k=T.slice(-p);x.forEach(_=>k[_]=0);const $=ai(k,p,y),E=T.slice(-m);w.forEach(_=>E[_]=0);const N=ai(E,m,b);d[S]=n(s[$],r[N])}return[d,o]}}function Es(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.makeTensorInfo(s.shape,"complex64"),c=t.data.get(l.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",o)},l}const qQ={kernelName:d1,backendName:"cpu",kernelFunc:Es};function qm(n,e,t="float32"){if(t==="complex64"){const r=qm(n,e,"float32"),i=qm(n,e,"float32");return Es({inputs:{real:r,imag:i},backend:n})}const s=qn(pe(e),t);return n.makeTensorInfo(e,t,s)}function yi(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const KQ={kernelName:wd,backendName:"cpu",kernelFunc:yi};function sl(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const XQ={kernelName:F1,backendName:"cpu",kernelFunc:sl};function nF(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=ol([0],t),[i,o]=rn((l,c)=>l!==c?1:0)(e,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Uo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return yi({inputs:{x:r},backend:t});const d=qm(t,r.shape,r.dtype),p=Uo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=Es({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){const d=sl({inputs:{input:r},backend:t}),p=Uo({inputs:{x:d},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(d),p}if(!CR(r.dtype,i)){const d=yi({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:i}}const o=t.data.get(r.dataId).values,[l,c,h]=nF(o,r.shape,r.dtype,i);return t.makeTensorInfo(l,c,h)}const YQ={kernelName:ld,backendName:"cpu",kernelFunc:Uo};function Sn(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a:o,b:l}=r,c=i;Ae([o,l],n);const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=o.dtype==="string"?qi(h):h,m=o.dtype==="string"?qi(d):d,y=s||o.dtype,[b,x]=e(o.shape,l.shape,p,m,y);return c.makeTensorInfo(x,y,b)}:({inputs:r,backend:i})=>{const{a:o,b:l}=r,c=i;if(o.dtype==="complex64"||l.dtype==="complex64"){const h=Uo({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(h.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=c.data.get(p.dataId).values,b=c.data.get(m.dataId).values,x=Uo({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),w=c.data.get(x.dataId),S=w.complexTensorInfos.real,T=w.complexTensorInfos.imag,k=c.data.get(S.dataId).values,$=c.data.get(T.dataId).values,[E,N,_]=t(o.shape,l.shape,y,b,k,$),R=c.makeTensorInfo(_,"float32",E),D=c.makeTensorInfo(_,"float32",N),M=Es({inputs:{real:R,imag:D},backend:c});return c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(R),c.disposeIntermediateTensorInfo(D),M}else{const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=s||o.dtype,[m,y]=e(o.shape,l.shape,h,d,p);return c.makeTensorInfo(y,p,m)}}}function xC(n){return(e,t,s,r,i,o)=>{const l=Ye(e,t),c=pe(l),h=l.length,d=Oe(l),p=Hn("float32",c),m=Hn("float32",c),y=Oc(e,l),b=Oc(t,l),x=Hi(s,r),w=Hi(i,o),S=e.length,T=Oe(e),k=t.length,$=Oe(t);if(y.length+b.length===0)for(let E=0;E<p.length;E++){const N=E%x.length,_=E%w.length,R=n(x[N*2],x[N*2+1],w[_*2],w[_*2+1]);p[E]=R.real,m[E]=R.imag}else for(let E=0;E<p.length;E++){const N=Hc(E,h,d),_=N.slice(-S);y.forEach(z=>_[z]=0);const R=ai(_,S,T),D=N.slice(-k);b.forEach(z=>D[z]=0);const M=ai(D,k,$),A=n(x[R*2],x[R*2+1],w[M*2],w[M*2+1]);p[E]=A.real,m[E]=A.imag}return[p,m,l]}}const sF=rn(((n,e)=>n+e)),JQ=xC(((n,e,t,s)=>({real:n+t,imag:e+s}))),Lc=Sn(qc,sF,JQ),ZQ={kernelName:qc,backendName:"cpu",kernelFunc:Lc};function vC(n,e,t,s,r){const i=pe(s),o=qn(r,t);for(let l=0;l<n.length;l++){const c=n[l];if(c<0)throw new Error("Input x must be non-negative!");c>=r||(i>0?o[c]+=e[l]:o[c]+=1)}return o}function rF(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],o=nt([r,t],e.dtype);for(let l=0;l<r;l++)for(let c=0;c<i;c++){const h=n.get(l,c);if(h<0)throw new Error("Input x must be non-negative!");h>=t||(s?o.set(1,l,h):e.size>0?o.set(o.get(l,h)+e.get(l,c),l,h):o.set(o.get(l,h)+1,l,h))}return o}const iF=rn(((n,e)=>n&e)),QQ=Sn(h1,iF),eee={kernelName:h1,backendName:"cpu",kernelFunc:QQ};function bi(n){return(e,t,s)=>{const r=Qt(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}function Ct(n,e,t){const s=bi(e);return Qo(n,s,t)}function Qo(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;Ae(o,n);const l=i,c=l.data.get(o.dataId).values;let h;if(o.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");h=qi(c)}else h=c;const d=t||o.dtype,p=e(h,d,r);return l.makeTensorInfo(o.shape,d,p)}}const oF=bi(n=>Math.ceil(n)),tee=Qo(cd,oF),nee={kernelName:cd,backendName:"cpu",kernelFunc:tee};function aF(n,e,t,s){const r=Qt(t,pe(e));if(s&&t!=="string"){let i=0;n.forEach(o=>{const l=pe(o.shape);r.set(o.vals,i),i+=l})}else{let i=0;n.forEach(o=>{const l=t==="string"?qi(o.vals):o.vals;let c=0;for(let h=0;h<o.shape[0];++h){const d=h*e[1]+i;for(let p=0;p<o.shape[1];++p)r[d+p]=l[c++]}i+=o.shape[1]})}return r}const lF=rn((n,e)=>n===e?1:0),cF=Sn(Tg,lF,null,"bool"),see={kernelName:Tg,backendName:"cpu",kernelFunc:cF};const uF=bi(n=>Math.exp(n)),hF=Qo(gd,uF,"float32"),ree={kernelName:gd,backendName:"cpu",kernelFunc:hF};const dF=bi(n=>Math.expm1(n)),iee=Qo(yd,dF),oee={kernelName:yd,backendName:"cpu",kernelFunc:iee};const fF=bi(n=>Math.floor(n)),aee=Qo(bd,fF),lee={kernelName:bd,backendName:"cpu",kernelFunc:aee};const pF=rn((n,e)=>Math.floor(n/e)),cee=Sn(xd,pF,null,"int32"),uee={kernelName:xd,backendName:"cpu",kernelFunc:cee};function mF(n,e,t,s,r,i,o,l,c){const h=nt([s,i],t);for(let d=0;d<s;d++){const p=[];let m=0;for(let y=0;y<r;y++){const b=n[d*r+y];m+=b*o[y],p.push(b)}if(m<0||m>=c/i)throw new Error(`Invalid indices: ${p} does not index into ${l}`);for(let y=0;y<i;y++)h.values[d*i+y]=e.get(...e.indexToLoc(m*i+y))}return h}function gF(n,e,t){const s=nt(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),l=o[0],c=o[2],h=e.locToIndex([l,c]);o[2]=e.values[h];const d=n.locToIndex(o);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const yF=rn((n,e)=>n>e?1:0),hee=Sn(Ig,yF,null,"bool"),dee={kernelName:Ig,backendName:"cpu",kernelFunc:hee};const bF=rn((n,e)=>n>=e?1:0),fee=Sn(vd,bF,null,"bool"),pee={kernelName:vd,backendName:"cpu",kernelFunc:fee};const xF=rn((n,e)=>n<e?1:0),mee=Sn(Ag,xF,null,"bool"),gee={kernelName:Ag,backendName:"cpu",kernelFunc:mee};const vF=rn((n,e)=>n<=e?1:0),yee=Sn(_g,vF,null,"bool"),bee={kernelName:_g,backendName:"cpu",kernelFunc:yee};function wF(n,e,t){const s=(e-n)/(t-1),r=qn(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const SF=bi(n=>Math.log(n)),xee=Qo(kd,SF),vee={kernelName:kd,backendName:"cpu",kernelFunc:xee};function CF(n,e,t,s){const r=Hn(s,pe(t));for(let i=0;i<r.length;++i){const o=i*e;let l=n[o];for(let c=0;c<e;++c){const h=n[o+c];(Number.isNaN(h)||h>l)&&(l=h)}r[i]=l}return r}const TF=rn(((n,e)=>Math.max(n,e))),wee=Sn(Ed,TF),See={kernelName:Ed,backendName:"cpu",kernelFunc:wee};const kF=rn(((n,e)=>Math.min(n,e))),Cee=Sn(Id,kF),Tee={kernelName:Id,backendName:"cpu",kernelFunc:Cee};const wC=rn(((n,e)=>n*e)),kee=xC(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),_0=Sn(Ad,wC,kee),$ee={kernelName:Ad,backendName:"cpu",kernelFunc:_0};function $F(n,e,t){const s=Wo(-1,t);return wC([],e,s,n,t)}function Eee(n){const{inputs:e,backend:t}=n,{x:s}=e;Ae(s,"neg");const r=t.data.get(s.dataId).values,[i,o]=$F(r,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,i)}const Iee={kernelName:Ug,backendName:"cpu",kernelFunc:Eee};const EF=rn(((n,e)=>n!==e?1:0)),Nee=Sn(jg,EF,null,"bool"),Aee={kernelName:jg,backendName:"cpu",kernelFunc:Nee};function SC(n,e,t,s,r){const i=e.length,o=pe(e),l=Oe(e),c=Oe(r),h=Hn(t,pe(r));for(let d=0;d<o;++d){const p=Hc(d,i,l),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[s[b]];const y=ai(m,i,c);h[y]=n[d]}return h}function ys(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;Ae(r,"transpose");const o=r.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=r.shape[i[p]];const c=s.data.get(r.dataId).values,h=SC(c,r.shape,r.dtype,i,l);return{dataId:s.write(h,l,r.dtype),shape:l,dtype:r.dtype}}const _ee={kernelName:kc,backendName:"cpu",kernelFunc:ys};function IF(n,e,t,s){const[r,i]=An(n,s),o=As(e,"int32"),l=qn(pe(r),o),c=pe(i);for(let h=0;h<l.length;++h){const d=h*c;let p=1;for(let m=0;m<c;++m)p*=t[d+m];l[h]=p}return{outVals:l,outShape:r,outDtype:o}}function Ree(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Ae(r,"prod");const l=r.shape.length,c=st(i,r.shape),h=Wt(c,l);let d=c,p=r;const m=[];h!=null&&(p=ys({inputs:{x:r},backend:t,attrs:{perm:h}}),m.push(p),d=nn(d.length,l));const y=t.data.get(p.dataId).values,{outVals:b,outShape:x,outDtype:w}=IF(p.shape,p.dtype,y,d);let S=x;return o&&(S=cn(x,c)),m.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.makeTensorInfo(S,w,b)}const Dee={kernelName:Xg,backendName:"cpu",kernelFunc:Ree};function Oee(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=Hc(r,e.length,Oe(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function Mee(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Fee(n,e,t,s){const r=[];let i=0;const o=e.length-1+t.length,l=new Array(o).fill(null).map(()=>[0]);Mee(t,s);let c=1;for(let h=0;h<e.length-1;++h){c*=e[h];const d=e[h+1];for(let p=1;p<c+1;++p)l[h].push(p*d)}for(let h=0;h<n.length;++h){let d=n[h],p=n[h]+1;for(let m=0;m<t.length;++m){const y=t[m],b=m+e.length-1;if(b>=0){const x=l[b],w=x[x.length-1]-y[d];for(let S=d;S<p;++S)l[b].push(y[S+1]+w)}d=y[d],p=y[p]}p!==d&&(r.push([d,p]),i+=p-d)}return{outSplits:l,valueSlices:r,numValues:i}}function Lee(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=Qt("int32",s);e.push(r),n[t].forEach((i,o)=>r[o]=i)}return e}function UN(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function Pee(n,e,t,s,r,i){const o=UN(e,2)[1],l=UN(i,2)[1];let c=0;for(const h of t)for(let d=h[0];d<h[1];++d){for(let p=0;p<s;++p)r[c*l+p]=n[d*o+p];++c}}function zee(n,e,t,s,r){const i=e.slice();i[0]=r;const o=Qt(t,pe(i)),l=n.length,c=l===0?0:l/e[0];return Pee(n,e,s,c,o,i),[o,i]}function NF(n,e,t,s,r,i,o,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const c=e[0][0]-1;if(Oee(i,o,c),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:p,numValues:m}=Fee(i,o,n,h),y=Lee(d),b=zee(t,s,r,p,m);return[y,b[0],b[1]]}const jN=2147483647;function AF(n,e,t,s,r,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const l=e.length===0,c=r.length===0,h=o.length===0,d=[];l||d.push(e[0]),c||d.push(r[0]),h||d.push(o[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=Qt("int32",p+1);m[0]=0;for(let w=0;w<p;++w){const S=l?n[0]:n[w],T=c?s[0]:s[w],k=h?i[0]:i[w];if(k===0)throw new Error("Requires delta != 0");let $;if(k>0&&T<S||k<0&&T>S)$=0;else if($=Math.ceil(Math.abs((T-S)/k)),$>jN)throw new Error(`Requires ((limit - start) / delta) <= ${jN}`);m[w+1]=m[w]+$}const y=m[p],b=Qt(t,y);let x=0;for(let w=0;w<p;++w){const S=m[w+1]-m[w];let T=l?n[0]:n[w];const k=h?i[0]:i[w];for(let $=0;$<S;++$)b[x++]=T,T+=k}return[m,b]}var ur=Pr;class Km{constructor(e,t,s,r,i,o,l,c,h,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=l,this.rowPartitionValues=c,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=mO(d),this.raggedRank=gO(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ur.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ur.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ur.VALUE_ROWIDS:return Km.getMaxWidthValueRowID(t);case ur.ROW_SPLITS:return Km.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ur[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let o=1;o<t;++o){const l=e[o];l!==r&&(r=l,i=Math.max(o-s,i),s=o)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return WN(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;yO(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=pO(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let l=1;l<=this.raggedRank;++l)o[l]<0&&(o[l]=this.getMaxWidth(l));return o}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let o=0;for(let l=0;l<r;++l,o+=t)i.push(o);for(let l=r;l<e;++l)i.push(-1);return L(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,o=[];for(let l=0;l<i-1;++l){const c=e[l+1]-e[l];let h=Math.min(r,c),d=t[l];d===-1&&(h=0);for(let p=0;p<h;++p)o.push(d),d+=s;for(let p=0;p<c-h;++p)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,o=[];if(i===0)return[];let l=0,c=e[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let h=t[c];o.push(h);for(let d=1;d<i;++d){const p=e[d];if(p===c)h>=0&&(++l,l<r?h+=s:h=-1);else{if(l=0,c=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);h=t[p]}o.push(h)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case ur.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case ur.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${ur[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ur.FIRST_DIM_SIZE:return e[0];case ur.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ur.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ur[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let c=r.length-2;c>=0;--c)r[c]=r[c+1]*s[c+1];const i=WN(s,!1),o=Qt(this.valuesDType,pe(i));if(r[0]*s[0]>0){let c=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)c=this.calculateOutputIndex(h-1,c,r[h],s[h]);this.setOutput(this.raggedRank,c,o,i)}return[i,o]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,o=s;let l=r.slice();l=l.slice(e+1);const c=pe(l),h=t.length;let d=this.defaultValue;if(d.length!==c&&d.length!==1){const b=this.defaultValueShape;ie(()=>{const x=te(d,b);d=Sh(x,l).dataSync()})}let p=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?t[b]:-1;if(x===y){++y;continue}if(m<y){const w=i.subarray(p*c),S=o.subarray(m*c),T=(y-m)*c;GN(S,w,T)}if(b>=h){const w=s.length;x=Math.floor(w/c)}if(x>y)if(this.defaultValue.length===1)o.subarray(y*c,x*c).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=o.slice(y*c);GN(w,d,c),++y}x<0?(p=b+1,m=y):(p=b,m=y,y=m+1)}}}function GN(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function WN(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function _F(n,e,t,s,r,i,o,l,c,h){return new Km(n,e,t,s,r,i,o,l,c,h).compute()}function RF(n,e,t,s){const r=n===e,i=n<e&&t<0,o=e<n&&t>1;if(r||i||o)return qn(0,s);const l=Math.abs(Math.ceil((e-n)/t)),c=qn(l,s);e<n&&t===1&&(t=-1),c[0]=n;for(let h=1;h<c.length;h++)c[h]=c[h-1]+t;return c}const DF=bi(n=>1/Math.sqrt(n)),Bee=Qo(Fd,DF),Vee={kernelName:Fd,backendName:"cpu",kernelFunc:Bee};function za(n,e,t,s,r,i,o,l,c,h){const d=[s/r,r],p=n.values,m=e.values;if(s===0)return nt(t,e.dtype);const y=c instanceof On?c:nt(d,e.dtype);typeof c=="string"||typeof c=="number"?y.values.fill(c):typeof c=="boolean"&&y.values.fill(+c);for(let b=0;b<i;b++){const x=[];let w=0;for(let S=0;S<o;S++){const T=p[b*o+S];x.push(T),w+=T*l[S]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let S=0;S<r;S++)h?y.values[w*r+S]+=m[b*r+S]:y.values[w*r+S]=e.rank===0?m[0]:m[b*r+S]}return y}const Uee=bi(n=>1/(1+Math.exp(-n))),OF=Ct(Vd,n=>1/(1+Math.exp(-n))),jee={kernelName:Vd,backendName:"cpu",kernelFunc:OF};function MF(n,e,t,s,r){const i=NS(s,e,t),o=pe(t),l=Oe(s);if(i){const p=AS(e,l);return r==="string"?n.slice(p,p+o):n.subarray(p,p+o)}const c=r==="string"?qi(n):n,h=nt(s,r,c),d=nt(t,r);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),y=m.map((b,x)=>b+e[x]);d.set(h.get(...y),...m)}return r==="string"?LO(d.values):d.values}function rl(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s;Ae(r,"slice");const[l,c]=g0(r,i,o);ES(r,l,c);const h=t.data.get(r.dataId).values,d=MF(h,l,c,r.shape,r.dtype);return t.makeTensorInfo(c,r.dtype,d)}const Gee={kernelName:t0,backendName:"cpu",kernelFunc:rl};function FF(n,e,t,s,r,i,o){const l=e[0],c=i[0],h=new Array(c),d=new Array(l),p=e[1];if(c===0){if(l!==0)throw new Error(TO(l));const w=Qt(t,0),S=Qt(r,0);return[w,[0,p],S,h,d]}let m=!0,y=0;const b=new Array(c).fill(0);for(let w=0;w<l;++w){const S=n[w*p];if(S<0)throw new Error(kO(w,S));if(S>=c)throw new Error($O(w,S,c));++b[S],m=m&&S>=y,y=S}let x=!0;for(let w=0;w<c;++w){const S=b[w]===0;h[w]=S,x=x&&!S,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,S=s;for(let T=0;T<l;++T)d[T]=T;return[w,[l,p],S,h,d]}else{const w=b[c-1],S=Qt(t,w*p),T=Qt(r,w),k=new Array(c).fill(0);for(let $=0;$<l;++$){const E=n[$*p],N=k[E],_=(E===0?0:b[E-1])+N;k[E]++;for(let R=0;R<p;++R)S[_*p+R]=n[$*p+R];T[_]=s[$],d[$]=_}for(let $=0;$<c;++$)if(k[$]===0){const N=$===0?0:b[$-1];S[N*p+0]=$;for(let _=1;_<p;++_)S[N*p+_]=0;T[N]=o}return[S,[w,p],T,h,d]}}function LF(n,e,t,s,r){const i=pe(s),o=e[0],l=r.length,c=[];let h=1,d=-1;for(let w=0;w<l;++w){const S=r[w];if(S===-1){if(d!==-1)throw new Error(EO(d,w));d=w,c.push(1)}else{if(S<0)throw new Error(IO(w,S));h*=S,c.push(S)}}if(d!==-1){if(h<=0)throw new Error(NO());const w=Math.trunc(i/h);if(h*w!==i)throw new Error(AO(s,c));c[d]=w}if(pe(c)!==i)throw new Error(_O(s,c));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(l>0){b[l-1]=1;for(let w=l-2;w>=0;--w)b[w]=b[w+1]*c[w+1]}const x=Qt(t,o*l);for(let w=0;w<o;++w){let S=0;for(let T=0;T<m;++T)S+=n[w*m+T]*y[T];for(let T=0;T<l;++T)x[w*l+T]=Math.trunc(S/b[T]),S%=b[T]}return[x,[o,l],c]}function CC(n,e,t,s,r,i=!1,o=0){const l=s.length,c=[e[0],n.length/e[0]],h=c[1],p=l>0?r[l-1]+1:0;if(p<0)throw new Error(Kv());const m=e.slice();m[0]=p;const y=m.reduce((k,$)=>k*$,1),b=Qt(t,y);if(l===0)return p>0&&b.fill(o),[b,m];if(p<=0)throw new Error(Kv());let x=0,w=1,S=0,T=r[x];for(;;){let k=0;if(w<l){if(k=r[w],T===k){++w;continue}if(T>=k)throw new Error(RO())}if(T<0||T>=p)throw new Error(DO(T,p));T>S&&b.fill(o,S*h,T*h);for(let $=x;$<w;++$){const E=s[$];if(E<0||E>=c[0])throw new Error(OO($,s[$],c[0]));for(let N=0;N<h;N++)b[T*h+N]+=n[E*h+N]}if(i)for(let $=0;$<h;$++)b[T*h+$]/=w-x;if(x=w,++w,S=T+1,T=k,w>l)break}return S<p&&b.fill(o,S*h,p*h),[b,m]}const Wee=bi(n=>Math.sqrt(n)),Hee=Ct(jd,n=>Math.sqrt(n)),qee={kernelName:jd,backendName:"cpu",kernelFunc:Hee};const PF=rn(((n,e)=>{const t=n-e;return t*t})),Kee=Sn(Gd,PF),Xee={kernelName:Gd,backendName:"cpu",kernelFunc:Kee};const zF=bi((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),Yee=Qo(B1,zF),Jee={kernelName:B1,backendName:"cpu",kernelFunc:Yee};function BF(n,e,t,s){const r=nt(n,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),l=new Array(o.length);for(let c=0;c<l.length;c++)l[c]=o[c]*t[c]+s[c];r.set(e.get(...l),...o)}return r}class Zee{constructor(e,t,s,r,i,o){this.separator=Ro(e),this.nGramWidths=t,this.leftPad=Ro(s),this.rightPad=Ro(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,o){for(let l=0;l<i;++l){const c=this.getPadWidth(o),h=Math.max(0,c-l),d=Math.max(0,c-(i-(l+1))),p=o-(h+d),m=t+(h>0?0:l-c);let y=0;y+=h*this.leftPad.length;for(let T=0;T<p;++T)y+=e[m+T].length;y+=d*this.rightPad.length;const b=h+d+p-1;y+=b*this.separator.length,s[r+l]=new Uint8Array(y);const x=s[r+l];let w=0;const S=T=>T.forEach(k=>x[w++]=k);for(let T=0;T<h;++T)S(this.leftPad),S(this.separator);for(let T=0;T<p-1;++T)S(e[m+T]),S(this.separator);if(p>0){S(e[m+p-1]);for(let T=0;T<d;++T)S(this.separator),S(this.rightPad)}else{for(let T=0;T<d-1;++T)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let h=1;h<r;++h){let d=t[h]>=c;if(d=d&&t[h]<=s,!d)throw new Error(`Invalid split value ${t[h]}, must be in [${c}, ${s}]`);c=t[h]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const i=r-1,o=Qt("int32",r);if(s===0||r===0){const c=new Array(s);for(let h=0;h<=i;++h)o[h]=0;return[c,o]}o[0]=0;for(let c=1;c<=i;++c){const h=t[c]-t[c-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&d===0&&(d=1),o[c]=o[c-1]+d}const l=new Array(o[i]);for(let c=0;c<i;++c){const h=t[c];let d=o[c];if(this.nGramWidths.forEach(p=>{const m=t[c+1]-t[c],y=this.getNumNGrams(m,p);this.createNGrams(e,h,l,d,y,p),d+=y}),this.preserveShort&&d===o[c]){const p=t[c+1]-t[c];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(e,h,l,d,1,m)}}return[l,o]}}function VF(n,e,t,s,r,i,o,l){return new Zee(t,s,r,i,o,l).compute(n,e)}function Qee(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const l=n.subarray(0,o);(!t||l.length!==0)&&s.push(l),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!t||o.length!==0)&&s.push(o),r=i+1}}function UF(n,e,t){const s=n.length,r=[];let i=0,o=0;const l=new Array(s);for(let m=0;m<s;++m){const y=r.length;Qee(n[m],e,t,r);const b=r.length-y;l[m]=b,i+=b,o=Math.max(o,b)}const c=Qt("int32",i*2),h=new Array(i),d=[s,o];let p=0;for(let m=0;m<s;++m)for(let y=0;y<l[m];++y)c[p*2]=m,c[p*2+1]=y,h[p]=r[p],++p;return[c,h,d]}function jF(n,e){const t=Qt("int32",n.length);for(let s=0;s<n.length;++s)t[s]=l6(n[s]).modulo(e).getLowBitsUnsigned();return t}const GF=rn(((n,e)=>n-e)),ete=xC(((n,e,t,s)=>({real:n-t,imag:e-s}))),TC=Sn(Wd,GF,ete),tte={kernelName:Wd,backendName:"cpu",kernelFunc:TC};function WF(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=nt(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let c=0;c<o.length;c++)o[c]=i[c]%n.shape[c];const l=n.locToIndex(o);s.values[r]=n.values[l]}return s}const hh=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function HF(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const l=s-t+1,c=e-t+1,h=Math.log(l),d=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*d*(l-d)/l)*Math.sign(c-l/2),m=Math.max(t,Math.floor(e-c*d/l+p)),y=Math.min(s,Math.floor(e+(l-c)*d/l+p));HF(n,e,m,y)}const r=n[e];let i=t,o=s;for(fc(n,t,e),hh(n[s],r)>0&&fc(n,t,s);i<o;){for(fc(n,i,o),i++,o--;hh(n[i],r)<0;)i=i+1;for(;hh(n[o],r)>0;)o=o-1}hh(n[t],r)===0?fc(n,t,o):(o=o+1,fc(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function qF(n,e,t,s,r){const i=e[e.length-1],[o,l]=[n.length/i,i],c=Hn(t,o*s),h=Hn("int32",o*s);for(let p=0;p<o;p++){const m=p*l,y=n.subarray(m,m+l);let b=new Array(y.length);y.forEach((T,k)=>b[k]={value:T,index:k}),s<b.length&&(HF(b,s),b=b.slice(0,s)),r&&b.sort(hh);const x=p*s,w=c.subarray(x,x+s),S=h.subarray(x,x+s);for(let T=0;T<s;T++)w[T]=b[T].value,S[T]=b[T].index}const d=e.slice();return d[d.length-1]=s,[nt(d,t,c),nt(d,"int32",h)]}function KF(n,e,t,s){const r=st(e,t)[0],i=[1,t[0],1];for(let b=0;b<r;b++)i[0]*=t[b];i[1]=t[r];for(let b=r+1;b<t.length;b++)i[2]*=t[b];const o=new Map,l=new Int32Array(t[r]),c=new On(i,s,n),h=[],d=i[0]===1&&i[2]===1;for(let b=0;b<t[r];b++){let x;if(d)x=n[b].toString();else{const S=[];for(let T=0;T<i[0];T++)for(let k=0;k<i[2];k++)S.push(c.get(T,b,k));x=S.join(",")}const w=o.get(x);if(w!=null)l[b]=w;else{const S=o.size;o.set(x,S),l[b]=S,h.push(b)}}const p=i.slice();p[1]=o.size;const m=new On(p,s);h.forEach((b,x)=>{for(let w=0;w<i[0];w++)for(let S=0;S<i[2];S++)m.set(c.get(w,b,S),w,x,S)});const y=t.slice();return y[r]=p[1],{outputValues:m.values,outputShape:y,indices:l}}const nte=Object.freeze(Object.defineProperty({__proto__:null,addImpl:sF,bincountImpl:vC,bincountReduceImpl:rF,bitwiseAndImpl:iF,castImpl:nF,ceilImpl:oF,concatImpl:aF,equalImpl:lF,expImpl:uF,expm1Impl:dF,floorDivImpl:pF,floorImpl:fF,gatherNdImpl:mF,gatherV2Impl:gF,greaterEqualImpl:bF,greaterImpl:yF,lessEqualImpl:vF,lessImpl:xF,linSpaceImpl:wF,logImpl:SF,maxImpl:CF,maximumImpl:TF,minimumImpl:kF,multiplyImpl:wC,negImpl:$F,notEqualImpl:EF,prodImpl:IF,raggedGatherImpl:NF,raggedRangeImpl:AF,raggedTensorToTensorImpl:_F,rangeImpl:RF,rsqrtImpl:DF,scatterImpl:za,sigmoidImpl:Uee,simpleAbsImpl:tF,sliceImpl:MF,sparseFillEmptyRowsImpl:FF,sparseReshapeImpl:LF,sparseSegmentReductionImpl:CC,sqrtImpl:Wee,squaredDifferenceImpl:PF,staticRegexReplaceImpl:zF,stridedSliceImpl:BF,stringNGramsImpl:VF,stringSplitImpl:UF,stringToHashBucketFastImpl:jF,subImpl:GF,tileImpl:WF,topKImpl:qF,transposeImpl:SC,uniqueImpl:KF},Symbol.toStringTag,{value:"Module"}));dD("cpu",()=>new A0,1);const XF=Ct(pd,n=>n>=0?n:Math.exp(n)-1),ste={kernelName:pd,backendName:"cpu",kernelFunc:XF};function YF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;Ae([r],"leakyRelu");const o=pe(r.shape),l=t.data.get(r.dataId).values,c=Hn("float32",o);for(let h=0;h<l.length;h++)c[h]=l[h]<0?i*l[h]:l[h];return t.makeTensorInfo(r.shape,"float32",c)}const rte={kernelName:Ng,backendName:"cpu",kernelFunc:YF};const ite=rn((n,e)=>n<0?e*n:n);function JF(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;Ae([s,r],"prelu");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,[l,c]=ite(s.shape,r.shape,i,o,"float32");return t.makeTensorInfo(c,"float32",l)}const ote={kernelName:Kg,backendName:"cpu",kernelFunc:JF};const ZF=Ct(Dd,n=>Math.max(0,n)),ate={kernelName:Dd,backendName:"cpu",kernelFunc:ZF};const QF=Ct(Od,n=>Math.min(Math.max(0,n),6)),lte={kernelName:Od,backendName:"cpu",kernelFunc:QF};function Xm(n,e,t,s,r){if(t==="linear")return yi({inputs:{x:e},backend:n});if(t==="relu")return ZF({inputs:{x:e},backend:n});if(t==="elu")return XF({inputs:{x:e},backend:n});if(t==="relu6")return QF({inputs:{x:e},backend:n});if(t==="prelu")return JF({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return YF({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return OF({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function Ot(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=pe(r.shape),l=SR(i,o),c=pe(l);L(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const h=t.data.get(r.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;d.shape=l,p.shape=l}return{dataId:r.dataId,shape:l,dtype:r.dtype}}const cte={kernelName:Yg,backendName:"cpu",kernelFunc:Ot};function eL(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:l}=s;Ae([r,i],"matMul");const c=r.shape.length,h=i.shape.length,d=o?r.shape[c-2]:r.shape[c-1],p=l?i.shape[h-1]:i.shape[h-2],m=o?r.shape[c-1]:r.shape[c-2],y=l?i.shape[h-2]:i.shape[h-1],b=r.shape.slice(0,-2),x=i.shape.slice(0,-2),w=pe(b),S=pe(x),k=Ye(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,y]);L(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${l} must match.`);const $=o?[w,d,m]:[w,m,d],E=l?[S,y,p]:[S,p,y],N=Ot({inputs:{x:r},backend:t,attrs:{shape:$}}),_=Ot({inputs:{x:i},backend:t,attrs:{shape:E}}),R=o?N.shape[1]:N.shape[2],D=o?N.shape[2]:N.shape[1],M=l?_.shape[1]:_.shape[2],A=Math.max(w,S),z=t.data.get(N.dataId).values,W=t.data.get(_.dataId).values,Y=Oe(N.shape),K=Oe(_.shape),[P,B,G]=o?[Y[0],1,Y[1]]:[Y[0],Y[1],1],[ee,Z,F]=l?[1,K[1],K[0]]:[K[1],1,K[0]],V=D*M,Q=nt([A,D,M],N.dtype),re=Q.values,he=t.blockSize;for(let ye=0;ye<A;ye++){const we=ye%w,Ie=ye%S;for(let Ce=0;Ce<D;Ce+=he){const Pe=Math.min(Ce+he,D);for(let Te=0;Te<M;Te+=he){const ze=Math.min(Te+he,M);for(let Ke=0;Ke<R;Ke+=he){const Qe=Math.min(Ke+he,R);for(let We=Ce;We<Pe;We++)for(let qe=Te;qe<ze;qe++){let wt=0;for(let pt=Ke;pt<Qe;pt++){const Ds=z[we*P+We*B+pt*G],Kt=W[pt*ee+qe*Z+Ie*F];wt+=Ds*Kt}re[ye*V+(We*M+qe)]+=wt}}}}}return t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(k,Q.dtype,Q.values)}const ute={kernelName:pg,backendName:"cpu",kernelFunc:eL};function hte(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=e,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;let m,y,b;const x=[];m=eL({inputs:{a:r,b:i},attrs:{transposeA:c,transposeB:h},backend:t}),o&&(y=Lc({inputs:{a:m,b:o},backend:t}),x.push(m),m=y),d&&(b=Xm(t,m,d,l,p),x.push(m),m=b);for(const S of x)t.disposeIntermediateTensorInfo(S);return m}const dte={kernelName:Em,backendName:"cpu",kernelFunc:hte};const fte=Ct(td,n=>Math.acos(n)),pte={kernelName:td,backendName:"cpu",kernelFunc:fte};const mte=Ct(nd,n=>Math.acosh(n)),gte={kernelName:nd,backendName:"cpu",kernelFunc:mte};function yte(n){const{inputs:e,backend:t}=n,s=e;Ae(e,"addN");const r=s.map(l=>t.data.get(l.dataId).values),i=nt(s[0].shape,s[0].dtype),o=i.values;for(let l=0;l<s.length;l++){const c=r[l];for(let h=0;h<o.length;h++)o[h]+=c[h]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const bte={kernelName:i1,backendName:"cpu",kernelFunc:yte};function xte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Ae(r,"all");const l=st(i,r.shape);let c=l;const h=Wt(c,r.shape.length);let d=r;h!=null&&(d=ys({inputs:{x:r},backend:t,attrs:{perm:h}}),c=nn(c.length,r.shape.length)),Fn("all",c,d.shape.length);const[p,m]=An(d.shape,c),y=pe(m),b=qn(pe(p),d.dtype),x=t.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k&&E}b[S]=k}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(o){const S=cn(p,l),T=Ot({inputs:{x:w},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(w),T}return w}const vte={kernelName:o1,backendName:"cpu",kernelFunc:xte};function wte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Ae(r,"any");const l=st(i,r.shape);let c=l;const h=Wt(c,r.shape.length);let d=r;h!=null&&(d=ys({inputs:{x:r},backend:t,attrs:{perm:h}}),c=nn(c.length,r.shape.length)),Fn("any",c,d.shape.length);const[p,m]=An(d.shape,c),y=pe(m),b=qn(pe(p),d.dtype),x=t.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k||E}b[S]=k}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(o){const S=cn(p,l),T=Ot({inputs:{x:w},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(w),T}return w}const Ste={kernelName:a1,backendName:"cpu",kernelFunc:wte};function Cte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Ae(r,"argMax");let o=st(i,r.shape);const l=Wt(o,r.shape.length);let c=r;const h=[];l!=null&&(c=ys({inputs:{x:r},backend:t,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),o=[o[0]],Fn("argMax",o,c.shape.length);const[d,p]=An(c.shape,o),m=pe(d),y=qn(m,"int32"),b=pe(p),x=t.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E>T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const Tte={kernelName:ug,backendName:"cpu",kernelFunc:Cte};function kte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Ae(r,"argMin");let o=st(i,r.shape);const l=Wt(o,r.shape.length);let c=r;const h=[];l!=null&&(c=ys({inputs:{x:r},backend:t,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),o=[o[0]],Fn("argMin",o,c.shape.length);const[d,p]=An(c.shape,o),m=pe(d),y=qn(m,"int32"),b=pe(p),x=t.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E<T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const $te={kernelName:hg,backendName:"cpu",kernelFunc:kte};const Ete=Ct(sd,n=>Math.asin(n)),Ite={kernelName:sd,backendName:"cpu",kernelFunc:Ete};const Nte=Ct(rd,n=>Math.asinh(n)),Ate={kernelName:rd,backendName:"cpu",kernelFunc:Nte};const _te=Ct(id,n=>Math.atan(n)),Rte={kernelName:id,backendName:"cpu",kernelFunc:_te};const Dte=rn((n,e)=>Math.atan2(n,e)),Ote=Sn(ad,Dte),Mte={kernelName:ad,backendName:"cpu",kernelFunc:Ote};const Fte=Ct(od,n=>Math.atanh(n)),Lte={kernelName:od,backendName:"cpu",kernelFunc:Fte};function kC(n,e,t,s,r,i){const o=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=nt(r.outShape,t),w=x.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3],T=r.outShape[2]*r.outShape[3],k=r.outShape[3];for(let $=0;$<r.batchSize;++$){const E=$*S,N=$*s[0];for(let _=0;_<r.inChannels;++_)for(let R=0;R<r.outHeight;++R){const D=R*o-m,M=Math.max(0,D),A=Math.min(r.inHeight,d+D),z=E+R*T;for(let W=0;W<r.outWidth;++W){const Y=W*l-y,K=Math.max(0,Y),P=Math.min(r.inWidth,p+Y);let B=b,G=0,ee=0;for(let F=M;F<A;F+=c){const V=N+F*s[1];for(let Q=K;Q<P;Q+=h){const re=V+Q*s[2],he=n[re+_];i==="max"&&he>B?B=he:i==="avg"&&(G+=he,ee++)}if(isNaN(B))break}const Z=z+W*k+_;w[Z]=i==="avg"?G/ee:B}}}return x}function tL(n,e,t,s,r=!1,i=!1){const o=nt(s.outShape,"int32"),l=s.strideHeight,c=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=nt(e,t,n);for(let w=0;w<s.batchSize;++w)for(let S=0;S<s.inChannels;++S)for(let T=0;T<s.outHeight;++T){const k=T*l-y;let $=k;for(;$<0;)$+=h;const E=Math.min(s.inHeight,p+k);for(let N=0;N<s.outWidth;++N){const _=N*c-b;let R=_;for(;R<0;)R+=d;const D=Math.min(s.inWidth,m+_);let M=Number.NEGATIVE_INFINITY,A=-1;for(let z=$;z<E;z+=h){const W=z-k;for(let Y=R;Y<D;Y+=d){const K=Y-_,P=x.get(w,z,Y,S);P>M&&(M=P,r?A=i?((w*s.inHeight+z)*s.inWidth+Y)*s.inChannels+S:(z*s.inWidth+Y)*s.inChannels+S:A=W*m+K)}}o.set(A,w,T,N,S)}}return o}function nL(n,e,t,s,r,i){const o=r.strideDepth,l=r.strideHeight,c=r.strideWidth,h=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,S=r.padInfo.left,T=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=nt(r.outShape,t),$=k.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[3]*r.outShape[4],R=r.outShape[4];for(let D=0;D<r.batchSize;++D){const M=D*E,A=D*s[0];for(let z=0;z<r.inChannels;++z)for(let W=0;W<r.outDepth;++W){const Y=W*o-x;let K=Y;for(;K<0;)K+=h;const P=Math.min(r.inDepth,m+Y),B=M+W*N;for(let G=0;G<r.outHeight;++G){const ee=G*l-w;let Z=ee;for(;Z<0;)Z+=d;const F=Math.min(r.inHeight,y+ee),V=B+G*_;for(let Q=0;Q<r.outWidth;++Q){const re=Q*c-S;let he=re;for(;he<0;)he+=p;const ye=Math.min(r.inWidth,b+re),we=V+Q*R;let Ie=T,Ce=0,Pe=0;for(let ze=K;ze<P;ze+=h){const Ke=A+ze*s[1];for(let Qe=Z;Qe<F;Qe+=d){const We=Ke+Qe*s[2];for(let qe=he;qe<ye;qe+=p){const wt=We+qe*s[3],pt=n[wt+z];if(i==="max"&&pt>Ie?Ie=pt:i==="avg"&&(Ce+=pt,Pe++),isNaN(Ie))break}if(isNaN(Ie))break}if(isNaN(Ie))break}const Te=we+z;$[Te]=i==="avg"?Ce/Math.max(Pe,1):Ie}}}}return k}function Pte(n,e){const t=nt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let w=0;w<e.inChannels;++w)for(let S=0;S<e.outDepth;++S){const T=S*s-m;let k=T;for(;k<0;)k+=o;const $=Math.min(e.inDepth,h+T);for(let E=0;E<e.outHeight;++E){const N=E*r-y;let _=N;for(;_<0;)_+=l;const R=Math.min(e.inHeight,d+N);for(let D=0;D<e.outWidth;++D){const M=D*i-b;let A=M;for(;A<0;)A+=c;const z=Math.min(e.inWidth,p+M);let W=Number.NEGATIVE_INFINITY,Y=-1;for(let K=k;K<$;K+=o){const P=K-T;for(let B=_;B<R;B+=l){const G=B-N;for(let ee=A;ee<z;ee+=c){const Z=ee-M,F=n.get(x,K,B,ee,w);F>=W&&(W=F,Y=P*d*p+G*d+Z)}}}t.set(Y,x,S,E,D,w)}}}return t}function zte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Ae(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Xn(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=wr(r.shape,i,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))p=yi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=Oe(r.shape),b=kC(m,r.shape,r.dtype,y,d,"avg");p=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const Bte={kernelName:dg,backendName:"cpu",kernelFunc:zte};function Vte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Ae(r,"avgPool3d");const d=Yi(r.shape,i,o,1,l,c,h),p=t.data.get(r.dataId).values,m=nL(p,r.shape,r.dtype,Oe(r.shape),d,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const Ute={kernelName:fg,backendName:"cpu",kernelFunc:Vte};function jte(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Ae([r,i],"avgPool3DGrad");const d=Yi(i.shape,o,l,1,c,h),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,S=d.dilationDepth,T=d.dilationHeight,k=d.dilationWidth,$=d.effectiveFilterDepth,E=d.effectiveFilterHeight,N=d.effectiveFilterWidth,_=$-1-d.padInfo.front,R=N-1-d.padInfo.left,D=E-1-d.padInfo.top,M=nt(i.shape,"float32"),A=1/(b*x*w),z=t.bufferSync(r);for(let W=0;W<d.batchSize;++W)for(let Y=0;Y<d.inChannels;++Y)for(let K=0;K<d.inDepth;++K)for(let P=0;P<d.inHeight;++P)for(let B=0;B<d.inWidth;++B){const G=K-_,ee=P-D,Z=B-R;let F=0;for(let V=0;V<$;V+=S){const Q=(G+V)/p;if(!(Q<0||Q>=d.outDepth||Math.floor(Q)!==Q))for(let re=0;re<E;re+=T){const he=(ee+re)/m;if(!(he<0||he>=d.outHeight||Math.floor(he)!==he))for(let ye=0;ye<N;ye+=k){const we=(Z+ye)/y;if(we<0||we>=d.outWidth||Math.floor(we)!==we)continue;const Ie=z.get(W,Q,he,we,Y);F+=Ie}}}M.set(F*A,W,K,P,B,Y)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const Gte={kernelName:c1,backendName:"cpu",kernelFunc:jte};function Wte(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;Ae([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=wr(o.shape,l,c,1,h),p=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,S=d.effectiveFilterHeight,T=d.effectiveFilterWidth,k=T-1-d.padInfo.left,$=S-1-d.padInfo.top,E=nt(o.shape,"float32"),N=1/(y*b),_=t.data.get(r.dataId).values,R=nt(r.shape,"float32",_);for(let D=0;D<d.batchSize;++D)for(let M=0;M<d.inChannels;++M)for(let A=0;A<d.inHeight;++A)for(let z=0;z<d.inWidth;++z){const W=A-$,Y=z-k;let K=0;for(let P=0;P<S;P+=x){const B=(W+P)/p;if(!(B<0||B>=d.outHeight||Math.floor(B)!==B))for(let G=0;G<T;G+=w){const ee=(Y+G)/m;if(ee<0||ee>=d.outWidth||Math.floor(ee)!==ee)continue;const Z=R.get(D,B,ee,M);K+=Z}}E.set(K*N,D,A,z,M)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Hte={kernelName:l1,backendName:"cpu",kernelFunc:Wte};function qte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:o,mean:l,variance:c}=e;L(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(i==null||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ae([r,l,c,i,o],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=t.data.get(r.dataId).values,p=t.data.get(l.dataId).values,m=t.data.get(c.dataId).values,y=i?t.data.get(i.dataId).values:new Float32Array([1]),b=o?t.data.get(o.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,S=y.length,T=m.length,k=p.length;let $=0,E=0,N=0,_=0;for(let R=0;R<d.length;++R)x[R]=b[$++]+(d[R]-p[E++])*y[N++]/Math.sqrt(m[_++]+h),$>=w&&($=0),E>=k&&(E=0),N>=S&&(N=0),_>=T&&(_=0);return t.makeTensorInfo(r.shape,r.dtype,x)}const Kte={kernelName:$g,backendName:"cpu",kernelFunc:qte};function Xte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;Ae([r],"batchToSpaceND");const l=i.reduce((S,T)=>S*T),c=sf(r.shape,i,l),h=rf(c.length,i.length),d=of(r.shape,i,l),p=MS(o,i.length),m=FS(d,o,i.length),y=Ot({inputs:{x:r},backend:t,attrs:{shape:c}}),b=ys({inputs:{x:y},backend:t,attrs:{perm:h}}),x=Ot({inputs:{x:b},backend:t,attrs:{shape:d}}),w=rl({inputs:{x},backend:t,attrs:{begin:p,size:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const Yte={kernelName:mg,backendName:"cpu",kernelFunc:Xte};function Jte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,h=vC(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}const Zte={kernelName:u1,backendName:"cpu",kernelFunc:Jte};function Qte(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=Ye(Array.from(i),Array.from(o));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const ene={kernelName:IR,backendName:"cpu",kernelFunc:Qte};const tne=Ct(ud,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),nne={kernelName:ud,backendName:"cpu",kernelFunc:tne};const sne=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(pe(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,l=t.data.get(i.dataId).values,c=t.data.get(o.dataId).values;for(let h=0;h<l.length;h++){const d=l[h],p=c[h];s[h]=Math.hypot(d,p)}return t.makeOutput(s,e.shape,"float32")},rne={kernelName:gg,backendName:"cpu",kernelFunc:sne};function Pc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const ine={kernelName:I1,backendName:"cpu",kernelFunc:Pc};function zc(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=st(r,e[0].shape)[0],o=e.map(x=>x.shape);RS(o,i);let l=ci(e.map(x=>x.shape),i);if(pe(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const c=e.filter(x=>pe(x.shape)>0);if(c.length===1)return yi({inputs:{x:c[0]},backend:t});if(c[0].dtype==="complex64"){const x=c.map($=>sl({inputs:{input:$},backend:t})),w=c.map($=>Pc({inputs:{input:$},backend:t})),S=zc({inputs:x,backend:t,attrs:{axis:i}}),T=zc({inputs:w,backend:t,attrs:{axis:i}}),k=Es({inputs:{real:S,imag:T},backend:t});return x.forEach($=>t.disposeIntermediateTensorInfo($)),w.forEach($=>t.disposeIntermediateTensorInfo($)),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(T),k}const h=c.map(x=>{const S=[-1,pe(x.shape.slice(i))];return Ot({inputs:{x},backend:t,attrs:{shape:S}})}),d=h.map(x=>({vals:t.data.get(x.dataId).values,shape:x.shape}));l=ci(h.map(x=>x.shape),1);const p=h[0].shape[0]===1,m=aF(d,l,e[0].dtype,p),y=ci(c.map(x=>x.shape),i),b=t.makeTensorInfo(y,e[0].dtype,m);return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const one={kernelName:yg,backendName:"cpu",kernelFunc:zc};function sL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s;Ae([r,i],"conv2d");const p=Ji(c),m=Mn(r.shape,i.shape,o,h,l,d,!1,p),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,S=m.padInfo.left,T=m.padInfo.top,k=m.dataFormat==="channelsLast",$=new On(m.outShape,r.dtype),E=Oe(r.shape),N=Oe(i.shape),_=E[0],R=k?E[1]:E[2],D=k?E[2]:1,M=k?1:E[1],A=$.strides[0],z=k?$.strides[1]:$.strides[2],W=k?$.strides[2]:1,Y=k?1:$.strides[1],K=t.data.get(r.dataId).values,P=t.data.get(i.dataId).values,B=$.values;for(let G=0;G<m.batchSize;++G){const ee=G*_,Z=G*A;for(let F=0;F<m.outHeight;++F){const V=Z+F*z,Q=F*m.strideHeight-T;for(let re=0;re<y;++re){const he=Q+re*x;if(he<0||he>=m.inHeight)continue;const ye=re*N[0],we=ee+he*R;for(let Ie=0;Ie<m.outWidth;++Ie){const Ce=V+Ie*W,Pe=Ie*m.strideWidth-S;for(let Te=0;Te<b;++Te){const ze=Pe+Te*w;if(ze<0||ze>=m.inWidth)continue;const Ke=ye+Te*N[1],Qe=we+ze*D;let We=Ke;for(let qe=0;qe<m.inChannels;++qe){const wt=K[Qe+qe*M];for(let pt=0;pt<m.outChannels;++pt)B[Ce+pt*Y]+=wt*P[We+pt];We+=m.outChannels}}}}}}return t.makeTensorInfo($.shape,$.dtype,B)}const ane={kernelName:bg,backendName:"cpu",kernelFunc:sL};function lne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s;Ae([r,i],"conv2dBackpropFilter");const p=Ji(c),m=Mn(r.shape,d,o,1,l,h,!1,p),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,S=m.dataFormat==="channelsLast",T=new On(m.filterShape,"float32"),k=m.padInfo.left,$=m.padInfo.top,E=t.data.get(r.dataId).values,N=t.data.get(i.dataId).values,_=new On(r.shape,r.dtype,E),R=new On(i.shape,i.dtype,N);for(let D=0;D<x;++D){const M=Math.max(0,Math.ceil(($-D)/y)),A=Math.min(m.outHeight,(m.inHeight+$-D)/y);for(let z=0;z<w;++z){const W=Math.max(0,Math.ceil((k-z)/b)),Y=Math.min(m.outWidth,(m.inWidth+k-z)/b);for(let K=0;K<m.inChannels;++K)for(let P=0;P<m.outChannels;++P){let B=0;for(let G=0;G<m.batchSize;++G)for(let ee=M;ee<A;++ee){const Z=D+ee*y-$;for(let F=W;F<Y;++F){const V=z+F*b-k;S?B+=_.get(G,Z,V,K)*R.get(G,ee,F,P):B+=_.get(G,K,Z,V)*R.get(G,P,ee,F)}}T.set(B,D,z,K,P)}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const cne={kernelName:f1,backendName:"cpu",kernelFunc:lne};function une(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s;Ae([r,i],"conv2dBackpropInput");const p=Oe(i.shape),m=Oe(r.shape);let y=Ji(h);const b=Mn(o,i.shape,l,1,c,d,!1,y),x=new On(b.inShape,"float32"),w=x.values,S=t.data.get(r.dataId).values,T=t.data.get(i.dataId).values,[k,$,E]=p,{batchSize:N,filterHeight:_,filterWidth:R,inChannels:D,inHeight:M,inWidth:A,outChannels:z,outHeight:W,outWidth:Y,strideHeight:K,strideWidth:P}=b;y=b.dataFormat;const B=_-1-b.padInfo.top,G=R-1-b.padInfo.left,ee=y==="channelsLast",Z=x.strides[0],F=ee?x.strides[1]:x.strides[2],V=ee?x.strides[2]:1,Q=ee?1:x.strides[1],re=m[0],he=ee?m[1]:m[2],ye=ee?m[2]:1,we=ee?1:m[1];for(let Ie=0;Ie<N;++Ie)for(let Ce=0;Ce<D;++Ce)for(let Pe=0;Pe<M;++Pe){const Te=Pe-B,ze=Math.max(0,Math.ceil(Te/K)),Ke=Math.min(W,(_+Te)/K);for(let Qe=0;Qe<A;++Qe){const We=Qe-G,qe=Math.max(0,Math.ceil(We/P)),wt=Math.min(Y,(R+We)/P);let pt=0;for(let Kt=ze;Kt<Ke;++Kt){const Zs=Kt*K-Te;for(let as=qe;as<wt;++as){const xi=as*P-We,Lt=re*Ie+he*Kt+ye*as,Tr=k*(_-1-Zs)+$*(R-1-xi)+E*Ce;for(let kr=0;kr<z;++kr){const $r=S[Lt+we*kr],Os=T[Tr+kr];pt+=$r*Os}}}const Ds=Z*Ie+F*Pe+V*Qe+Q*Ce;w[Ds]=pt}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const hne={kernelName:xg,backendName:"cpu",kernelFunc:une};function dne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:c}=s;Ae([r,i],"conv3d");const h=qo(r.shape,i.shape,o,c,l),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,S=w.front,T=w.left,k=w.top,$=new On(h.outShape,r.dtype),E=t.data.get(r.dataId).values,N=t.data.get(i.dataId).values,_=$.values,R=Oe(r.shape),D=Oe(i.shape);for(let M=0;M<h.batchSize;++M){const A=M*R[0],z=M*$.strides[0];for(let W=0;W<h.outDepth;++W){const Y=z+W*$.strides[1],K=W*h.strideDepth-S;for(let P=0;P<d;++P){const B=K+P*y;if(B<0||B>=h.inDepth)continue;const G=P*D[0],ee=A+B*R[1];for(let Z=0;Z<h.outHeight;++Z){const F=Y+Z*$.strides[2],V=Z*h.strideHeight-k;for(let Q=0;Q<p;++Q){const re=V+Q*b;if(re<0||re>=h.inHeight)continue;const he=G+Q*D[1],ye=ee+re*R[2];for(let we=0;we<h.outWidth;++we){const Ie=F+we*h.outChannels,Ce=we*h.strideWidth-T;for(let Pe=0;Pe<m;++Pe){const Te=Ce+Pe*x;if(Te<0||Te>=h.inWidth)continue;const ze=he+Pe*D[2],Ke=ye+Te*h.inChannels;let Qe=ze;for(let We=0;We<h.inChannels;++We){const qe=E[Ke+We];for(let wt=0;wt<h.outChannels;++wt)_[Ie+wt]+=qe*N[Qe+wt];Qe+=h.outChannels}}}}}}}}return t.makeTensorInfo($.shape,$.dtype,$.values)}const fne={kernelName:vg,backendName:"cpu",kernelFunc:dne};function pne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,filterShape:c}=s;Ae([r,i],"conv3dBackpropFilterV2");const h=Oe(r.shape),d=Oe(i.shape),p=qo(r.shape,c,o,1,l),m=p.strideDepth,y=p.strideHeight,b=p.strideWidth,x=p.filterDepth,w=p.filterHeight,S=p.filterWidth,T=new On(p.filterShape,"float32"),k=T.values,[$,E,N,_]=T.strides,R=t.data.get(i.dataId).values,[D,M,A,z]=d,W=t.data.get(r.dataId).values,[Y,K,P,B]=h,G=p.padInfo.front,ee=p.padInfo.left,Z=p.padInfo.top;for(let F=0;F<x;++F){const V=Math.max(0,Math.ceil((G-F)/m)),Q=Math.min(p.outDepth,(p.inDepth+G-F)/m),re=F*$;for(let he=0;he<w;++he){const ye=Math.max(0,Math.ceil((Z-he)/y)),we=Math.min(p.outHeight,(p.inHeight+Z-he)/y),Ie=he*E+re;for(let Ce=0;Ce<S;++Ce){const Pe=Math.max(0,Math.ceil((ee-Ce)/b)),Te=Math.min(p.outWidth,(p.inWidth+ee-Ce)/b),ze=Ce*N+Ie;for(let Ke=0;Ke<p.inChannels;++Ke){const Qe=Ke*_+ze;for(let We=0;We<p.outChannels;++We){let qe=0;for(let wt=0;wt<p.batchSize;++wt){const pt=wt*Y,Ds=wt*D;for(let Kt=V;Kt<Q;++Kt){const as=(F+Kt*m-G)*K+pt,xi=Kt*M+Ds;for(let Lt=ye;Lt<we;++Lt){const kr=(he+Lt*y-Z)*P+as,$r=Lt*A+xi;for(let Os=Pe;Os<Te;++Os){const gl=(Ce+Os*b-ee)*B+kr,au=Os*z+$r;qe+=W[gl+Ke]*R[au+We]}}}}k[Qe+We]=qe}}}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const mne={kernelName:p1,backendName:"cpu",kernelFunc:pne};function gne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:l,inputShape:c}=s;Ae([r],"conv3dBackpropInputV2");const h=Oe(r.shape),d=Oe(i.shape),p=qo(c,i.shape,l,1,o),m=new On(p.inShape,"float32"),y=m.values,[b,x,w,S]=m.strides,T=t.data.get(r.dataId).values,[k,$,E,N]=h,_=t.data.get(i.dataId).values,[R,D,M,A]=d,{batchSize:z,filterDepth:W,filterHeight:Y,filterWidth:K,inChannels:P,inDepth:B,inHeight:G,inWidth:ee,outChannels:Z,outDepth:F,outHeight:V,outWidth:Q,strideDepth:re,strideHeight:he,strideWidth:ye}=p,we=W-1-p.padInfo.front,Ie=Y-1-p.padInfo.top,Ce=K-1-p.padInfo.left;for(let Pe=0;Pe<z;++Pe)for(let Te=0;Te<P;++Te)for(let ze=0;ze<B;++ze){const Ke=ze-we,Qe=Math.max(0,Math.ceil(Ke/re)),We=Math.min(F,(W+Ke)/re);for(let qe=0;qe<G;++qe){const wt=qe-Ie,pt=Math.max(0,Math.ceil(wt/he)),Ds=Math.min(V,(Y+wt)/he);for(let Kt=0;Kt<ee;++Kt){const Zs=Kt-Ce,as=Math.max(0,Math.ceil(Zs/ye)),xi=Math.min(Q,(K+Zs)/ye);let Lt=0;for(let Tr=Qe;Tr<We;++Tr){const kr=Tr*re-Ke;for(let $r=pt;$r<Ds;++$r){const Os=$r*he-wt;for(let ta=as;ta<xi;++ta){const gl=ta*ye-Zs,au=k*Pe+$*Tr+E*$r+N*ta,L0=R*(W-1-kr)+D*(Y-1-Os)+M*(K-1-gl)+A*Te;for(let qr=0;qr<Z;++qr){const ls=T[au+qr],Kr=_[L0+qr];Lt+=ls*Kr}}}}y[b*Pe+x*ze+w*qe+S*Kt+Te]=Lt}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const yne={kernelName:m1,backendName:"cpu",kernelFunc:gne};const bne=Ct(hd,n=>Math.cos(n)),xne={kernelName:hd,backendName:"cpu",kernelFunc:bne};const vne=Ct(dd,n=>Math.cosh(n)),wne={kernelName:dd,backendName:"cpu",kernelFunc:vne};function Sne(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:l,method:c,extrapolationValue:h}=s,[d,p,m,y]=r.shape,b=i.shape[0],[x,w]=l,S=nt([b,x,w,y],"float32"),T=t.data.get(i.dataId).values,k=t.data.get(o.dataId).values,$=t.data.get(r.dataId).values,E=Oe(r.shape),N=Oe(S.shape);for(let _=0;_<b;_++){const R=_*4,D=T[R],M=T[R+1],A=T[R+2],z=T[R+3],W=k[_];if(W>=d)continue;const Y=x>1?(A-D)*(p-1)/(x-1):0,K=w>1?(z-M)*(m-1)/(w-1):0;for(let P=0;P<x;P++){const B=x>1?D*(p-1)+P*Y:.5*(D+A)*(p-1);if(B<0||B>p-1){for(let G=0;G<w;G++)for(let ee=0;ee<y;ee++){const Z=ee+G*N[2]+P*N[1]+_*N[0];S.values[Z]=h}continue}if(c==="bilinear"){const G=Math.floor(B),ee=Math.ceil(B),Z=B-G;for(let F=0;F<w;F++){const V=w>1?M*(m-1)+F*K:.5*(M+z)*(m-1);if(V<0||V>m-1){for(let ye=0;ye<y;ye++){const we=ye+F*N[2]+P*N[1]+_*N[0];S.values[we]=h}continue}const Q=Math.floor(V),re=Math.ceil(V),he=V-Q;for(let ye=0;ye<y;ye++){let we=ye+Q*E[2]+G*E[1]+W*E[0];const Ie=$[we];we=ye+re*E[2]+G*E[1]+W*E[0];const Ce=$[we];we=ye+Q*E[2]+ee*E[1]+W*E[0];const Pe=$[we];we=ye+re*E[2]+ee*E[1]+W*E[0];const Te=$[we],ze=Ie+(Ce-Ie)*he,Ke=Pe+(Te-Pe)*he;we=ye+F*N[2]+P*N[1]+_*N[0],S.values[we]=ze+(Ke-ze)*Z}}}else for(let G=0;G<w;++G){const ee=w>1?M*(m-1)+G*K:.5*(M+z)*(m-1);if(ee<0||ee>m-1){for(let V=0;V<y;V++){const Q=V+G*N[2]+P*N[1]+_*N[0];S.values[Q]=h}continue}const Z=Math.round(ee),F=Math.round(B);for(let V=0;V<y;V++){const Q=V+Z*E[2]+F*E[1]+W*E[0],re=V+G*N[2]+P*N[1]+_*N[0];S.values[re]=$[Q]}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const Cne={kernelName:y1,backendName:"cpu",kernelFunc:Sne};function Tne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;Ae(r,"cumprod");const c=Wt([i],r.shape.length);let h=r;c!=null&&(h=ys({inputs:{x:r},backend:t,attrs:{perm:c}}));const d=nn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=As(h.dtype,"int32"),m=n1(pe(h.shape),p),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?1:y[k];else{const $=x(S,T-1);m[k]=o?y[$]*m[$]:y[k]*m[$]}}const w=t.makeTensorInfo(h.shape,p,m);if(c!=null){const S=Ko(c),T=ys({inputs:{x:w},backend:t,attrs:{perm:S}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),T}return w}const kne={kernelName:g1,backendName:"cpu",kernelFunc:Tne};function $ne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;Ae(r,"cumsum");const c=Wt([i],r.shape.length);let h=r;c!=null&&(h=ys({inputs:{x:r},backend:t,attrs:{perm:c}}));const d=nn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=As(h.dtype,"int32"),m=qn(pe(h.shape),p),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?0:y[k];else{const $=x(S,T-1);m[k]=o?y[$]+m[$]:y[k]+m[$]}}const w=t.makeTensorInfo(h.shape,p,m);if(c!=null){const S=Ko(c),T=ys({inputs:{x:w},backend:t,attrs:{perm:S}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),T}return w}const Ene={kernelName:wg,backendName:"cpu",kernelFunc:$ne};function Ine(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=vC(c,h,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,d)}else if(r.shape.length===2){const c=t.bufferSync(r),h=t.bufferSync(i),d=rF(c,h,o,l);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Nne={kernelName:b1,backendName:"cpu",kernelFunc:Ine};function Ane(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s;L(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const l=r.shape[0],c=r.shape[1],h=r.shape[2],d=r.shape[3],p=c*i,m=h*i,y=d/(i*i),b=t.data.get(r.dataId).values,x=new Float32Array(l*p*m*y);let w=0;for(let S=0;S<l;++S)for(let T=0;T<p;++T){const k=Math.floor(T/i),$=T%i;for(let E=0;E<m;++E){const N=Math.floor(E/i),_=E%i,R=($*i+_)*y;for(let D=0;D<y;++D){const A=D+R+d*(N+h*(k+c*S));x[w++]=b[A]}}}return t.makeTensorInfo([l,p,m,y],r.dtype,x)}const _ne={kernelName:x1,backendName:"cpu",kernelFunc:Ane};function rL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;Ae([r,i],"depthwiseConv2DNative");const d=Oe(r.shape),p=Oe(i.shape);let m=c;m==null&&(m=[1,1]),L(Xn(o,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);const y=Mn(r.shape,i.shape,o,m,l,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:S,padInfo:T}=y,k=T.left,$=T.top,E=y.outChannels/y.inChannels,N=new On(y.outShape,r.dtype),_=t.data.get(r.dataId).values,R=t.data.get(i.dataId).values,D=N.values;for(let M=0;M<y.batchSize;++M){const A=M*d[0],z=M*N.strides[0];for(let W=0;W<y.outHeight;++W){const Y=z+W*N.strides[1],K=W*y.strideHeight-$;for(let P=0;P<b;++P){const B=K+P*w;if(B<0||B>=y.inHeight)continue;const G=P*p[0],ee=A+B*d[1];for(let Z=0;Z<y.outWidth;++Z){const F=Y+Z*N.strides[2],V=Z*y.strideWidth-k;for(let Q=0;Q<x;++Q){const re=V+Q*S;if(re<0||re>=y.inWidth)continue;const he=G+Q*p[1],ye=ee+re*y.inChannels;let we=F,Ie=he;for(let Ce=0;Ce<y.inChannels;++Ce){const Pe=_[ye+Ce];for(let Te=0;Te<E;++Te)D[we+Te]+=Pe*R[Ie+Te];we+=E,Ie+=E}}}}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const Rne={kernelName:Sg,backendName:"cpu",kernelFunc:rL};function Dne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s;Ae([r,i],"depthwiseConv2dNativeBackpropFilter");const p=Mn(r.shape,d,o,l,c,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=p,w=new On(p.filterShape,"float32"),S=p.padInfo.left,T=p.padInfo.top,k=p.outChannels/p.inChannels,$=t.data.get(r.dataId).values,E=new On(r.shape,r.dtype,$),N=t.data.get(i.dataId).values,_=new On(i.shape,i.dtype,N);for(let R=0;R<b;++R){const D=Math.max(0,Math.ceil((T-R)/m)),M=Math.min(p.outHeight,(p.inHeight+T-R)/m);for(let A=0;A<x;++A){const z=Math.max(0,Math.ceil((S-A)/y)),W=Math.min(p.outWidth,(p.inWidth+S-A)/y);for(let Y=0;Y<p.outChannels;++Y){const K=Math.trunc(Y/k),P=Y%k;let B=0;for(let G=0;G<p.batchSize;++G)for(let ee=D;ee<M;++ee){const Z=R+ee*m-T;for(let F=z;F<W;++F){const V=A+F*y-S;B+=E.get(G,Z,V,K)*_.get(G,ee,F,Y)}}w.set(B,R,A,K,P)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const One={kernelName:v1,backendName:"cpu",kernelFunc:Dne};function Mne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s;Ae([r,i],"depthwiseConv2DNativeBackpropInput");const p=Oe(r.shape),m=Oe(i.shape),y=Mn(d,i.shape,o,l,c,h,!0),b=new On(y.inShape,"float32"),x=b.values,[w,S,T]=b.strides,k=t.data.get(r.dataId).values,[$,E,N]=p,_=t.data.get(i.dataId).values,[R,D,M]=m,{batchSize:A,filterHeight:z,filterWidth:W,inChannels:Y,inHeight:K,inWidth:P,outChannels:B,outHeight:G,outWidth:ee,strideHeight:Z,strideWidth:F}=y,V=z-1-y.padInfo.top,Q=W-1-y.padInfo.left,re=B/Y;for(let he=0;he<A;++he)for(let ye=0;ye<Y;++ye)for(let we=0;we<K;++we){const Ie=we-V,Ce=Math.max(0,Math.ceil(Ie/Z)),Pe=Math.min(G,(z+Ie)/Z);for(let Te=0;Te<P;++Te){const ze=Te-Q,Ke=Math.max(0,Math.ceil(ze/F)),Qe=Math.min(ee,(W+ze)/F);let We=0;for(let qe=Ce;qe<Pe;++qe){const wt=qe*Z-Ie;for(let pt=Ke;pt<Qe;++pt){const Ds=pt*F-ze,Kt=$*he+E*qe+N*pt,Zs=R*(z-1-wt)+D*(W-1-Ds)+M*ye;for(let as=0;as<re;++as){const xi=ye*re+as,Lt=k[Kt+xi],Tr=_[Zs+as];We+=Lt*Tr}}}x[w*he+S*we+T*Te+ye]=We}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const Fne={kernelName:w1,backendName:"cpu",kernelFunc:Mne};function Lne(n){const{inputs:e,backend:t}=n,{x:s}=e,r=pe(s.shape),i=t.data.get(s.dataId).values,o=nt([r,r],s.dtype),l=o.values;for(let h=0;h<i.length;h++)l[h*r+h]=i[h];const c=[...s.shape,...s.shape];return t.makeTensorInfo(c,o.dtype,o.values)}const Pne={kernelName:NR,backendName:"cpu",kernelFunc:Lne};const zne={kernelName:Cg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:l}=t,c=e,h=c.data.get(s.dataId).values,d=s.shape.length,p=c.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:S,outWidth:T,padInfo:k,strideHeight:$,strideWidth:E,filterHeight:N,filterWidth:_,dilationHeight:R,dilationWidth:D,outShape:M}=Zd(s.shape,r.shape,i,o,"NHWC",l),A=pe(M),z=M.length,W=Qt(s.dtype,A);for(let K=0;K<y;++K)for(let P=0;P<S;++P){const B=P*$-k.top;for(let G=0;G<T;++G){const ee=G*E-k.left;for(let Z=0;Z<w;++Z){let F=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<N;++Q){const re=B+Q*R;if(re>=0&&re<b)for(let he=0;he<_;++he){const ye=ee+he*D;if(ye>=0&&ye<x){const we=ai([K,re,ye,Z],d,Oe(s.shape)),Ie=ai([Q,he,Z],m,Oe(r.shape)),Ce=h[we]+p[Ie];Ce>F&&(F=Ce)}}}const V=ai([K,P,G,Z],z,Oe(M));W[V]=F}}}return{dataId:c.write(ol(W,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}};const Bne={kernelName:Dv,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:c}=t,h=e,d=Br(s.shape,h.data.get(s.dataId).values),p=Br(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Zd(s.shape,r.shape,o,l,"NHWC",c);L(i.rank===D.length,()=>`Error in ${Dv}, dy must have the same rank as output ${D.length}, but got ${i.rank}`);const M=Br(D,h.data.get(i.dataId).values),A=kR(r.shape,r.dtype);for(let W=0;W<m;++W)for(let Y=0;Y<w;++Y){const K=Y*k-T.top;for(let P=0;P<S;++P){const B=P*$-T.left;for(let G=0;G<x;++G){let ee=Number.MIN_SAFE_INTEGER,Z=0,F=0;for(let V=0;V<E;++V){const Q=K+V*_;if(Q>=0&&Q<y)for(let re=0;re<N;++re){const he=B+re*R;if(he>=0&&he<b){const ye=d[W][Q][he][G]+p[V][re][G];ye>ee&&(ee=ye,Z=V,F=re)}}}A[Z][F][G]+=M[W][Y][P][G]}}}return{dataId:h.write(ol(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const Vne={kernelName:Rv,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:c}=t,h=e,d=Br(s.shape,h.data.get(s.dataId).values),p=Br(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Zd(s.shape,r.shape,o,l,"NHWC",c);L(i.rank===D.length,()=>`Error in ${Rv}, dy must have the same rank as output ${D.length}, but got ${i.rank}`);const M=Br(D,h.data.get(i.dataId).values),A=kR(s.shape,s.dtype);for(let W=0;W<m;++W)for(let Y=0;Y<w;++Y){const K=Y*k-T.top;for(let P=0;P<S;++P){const B=P*$-T.left;for(let G=0;G<x;++G){let ee=Number.MIN_SAFE_INTEGER,Z=K<0?0:K,F=B<0?0:B;for(let V=0;V<E;++V){const Q=K+V*_;if(Q>=0&&Q<y)for(let re=0;re<N;++re){const he=B+re*R;if(he>=0&&he<b){const ye=d[W][Q][he][G]+p[V][re][G];ye>ee&&(ee=ye,Z=Q,F=he)}}}A[W][Z][F][G]+=M[W][Y][P][G]}}}return{dataId:h.write(ol(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Une(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:o}=s,{contextOptions:l,imageOptions:c}=o||{},h=c?.alpha||1,d=l?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const p=i.getContext(d,l?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],x=t.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,S=new Uint8ClampedArray(y*m*4);for(let k=0;k<m*y;++k){const $=[0,0,0,255*h];for(let N=0;N<b;N++){const _=x[k*b+N];if(r.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(r.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);b===1?($[0]=_*w,$[1]=_*w,$[2]=_*w):$[N]=_*w}const E=k*4;S[E+0]=Math.round($[0]),S[E+1]=Math.round($[1]),S[E+2]=Math.round($[2]),S[E+3]=Math.round($[3])}i.width=y,i.height=m;const T=new ImageData(S,y,m);return p.putImageData(T,0,0),r}const jne={kernelName:J5,backendName:"cpu",kernelFunc:Une};function mf(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Ae(r,"sum");let l;r.dtype==="bool"?l=Uo({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):l=yi({inputs:{x:r},backend:t});const c=l.shape.length,h=st(i,l.shape),d=Wt(h,c);let p=h,m=l;d!=null&&(m=ys({inputs:{x:l},backend:t,attrs:{perm:d}}),p=nn(p.length,c)),Fn("sum",p,m.shape.length);const[y,b]=An(m.shape,p),x=As(m.dtype,"int32");let w=qm(t,y,x);const S=pe(b),T=t.data.get(w.dataId).values,k=t.data.get(m.dataId).values;for(let $=0;$<T.length;++$){const E=$*S;let N=0;for(let _=0;_<S;++_)N+=k[E+_];T[$]=N}if(o){const $=cn(w.shape,h),E=w;w=Ot({inputs:{x:w},backend:t,attrs:{shape:$}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(l),d!=null&&t.disposeIntermediateTensorInfo(m),w}const Gne={kernelName:n0,backendName:"cpu",kernelFunc:mf};function Wne(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:l,idDims:c}=GS(r,i.length);HS(o.length,c,i);const{path:h,steps:d}=qS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=WS(y,c[w]);let k;KS(S)?k=i[w]:(k=ys({inputs:{x:i[w]},backend:t,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);xt(k.shape,$)||(k=Ot({inputs:{x:k},backend:t,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=_0({inputs:{a:k,b:m},backend:t}),b.push(m))}x<p-1&&(h[x]>=0&&(m=mf({inputs:{x:m},backend:t,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const Hne={kernelName:S1,backendName:"cpu",kernelFunc:Wne};function qne(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;Ae([s,r],"eluGrad");const i=new Float32Array(pe(r.shape)),o=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values;for(let c=0;c<o.length;++c){const h=o[c];h>=0?i[c]=l[c]:i[c]=l[c]*(h+1)}return t.makeTensorInfo(r.shape,"float32",i)}const Kne={kernelName:C1,backendName:"cpu",kernelFunc:qne};const Xne=LS,Yne=PS,Jne=zS,Zne=BS,Qne=VS,ese=US,tse=Ct(md,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Xne*t);return e*(1-((((ese*s+Qne)*s+Zne)*s+Jne)*s+Yne)*s*Math.exp(-t*t))}),nse={kernelName:md,backendName:"cpu",kernelFunc:tse};function Ym(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,o=r.shape.length,l=r.shape.slice();let c=i;return i<0&&(L(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+i+1),l.splice(c,0,1),Ot({inputs:{x:r},backend:t,attrs:{shape:l}})}const sse={kernelName:kg,backendName:"cpu",kernelFunc:Ym};const rse=rn((n,e)=>n/e),$C=Sn(fd,rse),rw={kernelName:fd,backendName:"cpu",kernelFunc:$C};function iL(n,e,t){const s=n.shape,r=s[0],i=s[1],o=t.data.get(n.dataId),l=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,h=[r,i],d=pe(h),p=Hn("float32",d),m=Hn("float32",d);for(let w=0;w<r;w++){const S=rl({inputs:{x:l},backend:t,attrs:{begin:[w,0],size:[1,i]}}),T=rl({inputs:{x:c},backend:t,attrs:{begin:[w,0],size:[1,i]}}),k=Es({inputs:{real:S,imag:T},backend:t}),{real:$,imag:E}=ise(k,e,t),N=Hi($,E);for(let _=0;_<i;_++){const R=jS(N,_);p[w*i+_]=R.real,m[w*i+_]=R.imag}t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(k)}const y=t.makeTensorInfo(h,"float32",p),b=t.makeTensorInfo(h,"float32",m),x=Es({inputs:{real:y,imag:b},backend:t});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}function ise(n,e,t){const s=pe(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(ose(s)){const l=iw(i,o,s,e,t),c=[n.shape[0],n.shape[1]];if(e){const h=t.makeTensorInfo(c,"float32",l.real),d=t.makeTensorInfo(c,"float32",l.imag),p=t.makeTensorInfo([],"float32",Wo(s,"float32")),m=yi({inputs:{x:p},backend:t}),y=rw.kernelFunc({inputs:{a:h,b:p},backend:t}),b=rw.kernelFunc({inputs:{a:d,b:m},backend:t}),x=t.data.get(y.dataId).values,w=t.data.get(b.dataId).values;return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return l}else{const l=Hi(i,o),c=ase(l,s,e);return bO(c)}}function ose(n){return(n&n-1)===0}function iw(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=Hi(n,e),o=t/2,l=xO(i),c=l.real,h=l.imag,d=[c.length],p=r.makeTensorInfo(d,"float32",c),m=r.makeTensorInfo(d,"float32",h),y=Es({inputs:{real:p,imag:m},backend:r}),b=vO(i),x=b.real,w=b.imag,S=[x.length],T=r.makeTensorInfo(S,"float32",x),k=r.makeTensorInfo(S,"float32",w),$=Es({inputs:{real:T,imag:k},backend:r}),E=iw(c,h,o,s,r),N=E.real,_=E.imag,R=[N.length],D=r.makeTensorInfo(R,"float32",N),M=r.makeTensorInfo(R,"float32",_),A=Es({inputs:{real:D,imag:M},backend:r}),z=iw(x,w,o,s,r),W=z.real,Y=z.imag,K=[W.length],P=r.makeTensorInfo(K,"float32",W),B=r.makeTensorInfo(K,"float32",Y),G=Es({inputs:{real:P,imag:B},backend:r}),ee=SO(t,s),Z=[ee.real.length],F=r.makeTensorInfo(Z,"float32",ee.real),V=r.makeTensorInfo(Z,"float32",ee.imag),Q=Es({inputs:{real:F,imag:V},backend:r}),re=_0({inputs:{a:Q,b:G},backend:r}),he=Lc({inputs:{a:A,b:re},backend:r}),ye=TC({inputs:{a:A,b:re},backend:r}),we=sl({inputs:{input:he},backend:r}),Ie=sl({inputs:{input:ye},backend:r}),Ce=Pc({inputs:{input:he},backend:r}),Pe=Pc({inputs:{input:ye},backend:r}),Te=zc({inputs:[we,Ie],backend:r,attrs:{axis:0}}),ze=zc({inputs:[Ce,Pe],backend:r,attrs:{axis:0}}),Ke=r.data.get(Te.dataId).values,Qe=r.data.get(ze.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(ye),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(Ie),r.disposeIntermediateTensorInfo(Pe),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(ze),{real:Ke,imag:Qe}}function ase(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,o=0;for(let l=0;l<e;l++){const c=CO(r*l,e,t),h=jS(n,l);i+=h.real*c.real-h.imag*c.imag,o+=h.real*c.imag+h.imag*c.real}t&&(i/=e,o/=e),wO(s,i,o,r)}return s}function lse(n){const{inputs:e,backend:t}=n,{input:s}=e,r=pe(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=Ot({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),c=iL(l,!1,t),h=Ot({inputs:{x:c},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),h}const cse={kernelName:T1,backendName:"cpu",kernelFunc:lse};function EC(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,o=i||Wc(r),l=Qt(o,pe(s));return hse(l,r,o),e.makeTensorInfo(s,o,l)}const use={kernelName:k1,backendName:"cpu",kernelFunc:EC};function hse(n,e,t){n.fill(e)}const dse={kernelName:$1,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=Hn(s.dtype,pe(s.shape)),[o,l,c,h]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<o;m++){const y=m*c*l*h;for(let b=0;b<l;b++){const x=b*(c*h);for(let w=0;w<c;w++){const S=w*h;for(let T=0;T<h;T++){const k=Math.round(c-w-1),$=y+x+S+T;let E=d[$];if(k>=0&&k<c){const N=k*h,_=y+x+N+T;E=d[_]}i[$]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function fse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=sL({inputs:{x:r,filter:i},backend:t,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;if(d==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const S=Ot({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});x=Lc({inputs:{a:x,b:S},backend:t}),t.disposeIntermediateTensorInfo(S)}else x=Lc({inputs:{a:x,b:o},backend:t});t.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const S=Ot({inputs:{x:l},backend:t,attrs:{shape:[l.shape[0],1,1]}});x=Xm(t,x,y,S,b),t.disposeIntermediateTensorInfo(S)}else x=Xm(t,x,y,l,b);t.disposeIntermediateTensorInfo(w)}return x}const pse={kernelName:Im,backendName:"cpu",kernelFunc:fse};function mse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=rL({inputs:{x:r,filter:i},backend:t,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;x=Lc({inputs:{a:x,b:o},backend:t}),t.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=Xm(t,x,y,l,b),t.disposeIntermediateTensorInfo(w)}return x}const gse={kernelName:KR,backendName:"cpu",kernelFunc:mse};function yse(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=pe(s.shape),o=r.shape,l=o[o.length-1],[c,h,d,p]=$S(s,r);if(h===0)return t.makeTensorInfo(c,s.dtype,[]);const m=t.data.get(r.dataId).values,y=t.bufferSync(s),b=mF(m,y,s.dtype,h,l,d,p,s.shape,i);return t.makeTensorInfo(c,s.dtype,b.values)}const bse={kernelName:AR,backendName:"cpu",kernelFunc:yse};function xse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:l}=s;Ae([r,i],"gatherV2");const c=st(o,r.shape)[0],h=t.data.get(i.dataId).values,d=r.shape[c];for(let $=0;$<h.length;++$){const E=h[$];L(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=l;l==null&&(p=0);const m=pe(i.shape),y=YS(r,i,c,p),b=Ot({inputs:{x:r},backend:t,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=Ot({inputs:{x:i},backend:t,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],S=t.bufferSync(x),T=t.bufferSync(b),k=gF(T,S,w);return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.makeTensorInfo(y.outputShape,k.dtype,k.values)}const vse={kernelName:Eg,backendName:"cpu",kernelFunc:xse};function wse(n){const{inputs:e,backend:t}=n,{input:s}=e,r=pe(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=Ot({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),c=iL(l,!0,t),h=Ot({inputs:{x:c},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),h}const Sse={kernelName:E1,backendName:"cpu",kernelFunc:wse};const Cse=Ct(Sd,n=>Number.isFinite(n)?1:0,"bool"),Tse={kernelName:Sd,backendName:"cpu",kernelFunc:Cse};const kse=Ct(Cd,n=>Math.abs(n)===1/0?1:0,"bool"),$se={kernelName:Cd,backendName:"cpu",kernelFunc:kse};const Ese=Ct(Td,n=>Number.isNaN(n)?1:0,"bool"),Ise={kernelName:Td,backendName:"cpu",kernelFunc:Ese};function Nse(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=wF(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const Ase={kernelName:_R,backendName:"cpu",kernelFunc:Nse};const _se=Ct($d,n=>Math.log1p(n)),Rse={kernelName:$d,backendName:"cpu",kernelFunc:_se};const Dse=rn((n,e)=>n&&e),Ose=Sn(Rg,Dse,null,"bool"),Mse={kernelName:Rg,backendName:"cpu",kernelFunc:Ose};const Fse=Ct(Dg,n=>n?0:1,"bool"),Lse={kernelName:Dg,backendName:"cpu",kernelFunc:Fse};const Pse=rn((n,e)=>n||e),zse=Sn(Og,Pse,null,"bool"),Bse={kernelName:Og,backendName:"cpu",kernelFunc:zse};function Vse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:l,beta:c}=s;Ae(r,"LRN");const h=r.shape[3],d=h-1,p=t.data.get(r.dataId).values,m=pe(r.shape),y=new Float32Array(m);function b(x){const w=x%h;let S=x-w+Math.max(0,w-i);const T=x-w+Math.min(w+i,d);let k=0;for(;S<=T;S++){const $=p[S];k+=$*$}return k}for(let x=0;x<m;x++){const w=b(x),S=p[x]*Math.pow(o+l*w,-c);y[x]=S}return t.makeTensorInfo(r.shape,r.dtype,y)}const Use={kernelName:Mg,backendName:"cpu",kernelFunc:Vse};function jse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:l,bias:c,alpha:h,beta:d}=s;Ae(o,"LRNGrad");const p=pe(o.shape),m=o.shape[3],y=t.data.get(o.dataId).values,b=t.data.get(r.dataId).values,x=t.data.get(i.dataId).values,w=new Float32Array(p),S=p;for(let T=0;T<S;T++){const k=T%m,$=T-k+Math.max(0,k-l),E=T-k+Math.min(m,k+l+1);let N=0;for(let _=$;_<E;_++)N+=Math.pow(b[_],2);N=h*N+c;for(let _=$;_<E;_++){let R=-2*h*d*b[_]*x[T]/N;T===_&&(R+=Math.pow(N,-d)),R*=y[T],w[_]+=R}}return t.makeTensorInfo(o.shape,r.dtype,w)}const Gse={kernelName:N1,backendName:"cpu",kernelFunc:jse};function oL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,l=t;let c=r.shape;const h=c.length,d=st(i,c);let p=d;const m=Wt(p,h);let y=l.data.get(r.dataId).values;if(m!=null){const $=new Array(h);for(let E=0;E<$.length;E++)$[E]=c[m[E]];y=SC(y,c,r.dtype,m,$),p=nn(p.length,h),c=$}Ae(r,"max"),Fn("max",p,h);const[b,x]=An(c,p),w=pe(x),S=CF(y,w,b,r.dtype),T=l.write(S,b,r.dtype);let k=b;return o&&(k=cn(b,d)),{dataId:T,shape:k,dtype:r.dtype}}const Wse={kernelName:Fg,backendName:"cpu",kernelFunc:oL};function Hse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Ae(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Xn(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=wr(r.shape,i,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))p=yi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=Oe(r.shape),b=kC(m,r.shape,r.dtype,y,d,"max");p=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const qse={kernelName:Lg,backendName:"cpu",kernelFunc:Hse};function Kse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Ae(r,"maxPool3d");const d=Yi(r.shape,i,o,1,l,c,h),p=t.data.get(r.dataId).values,m=nL(p,r.shape,r.dtype,Oe(r.shape),d,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const Xse={kernelName:Pg,backendName:"cpu",kernelFunc:Kse};function Yse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Ae([r,i],"maxPool3DGrad");const d=Yi(i.shape,o,l,1,c,h),p=t.bufferSync(i),m=Pte(p,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,S=d.dilationHeight,T=d.dilationWidth,k=d.effectiveFilterDepth,$=d.effectiveFilterHeight,E=d.effectiveFilterWidth,N=k-1-d.padInfo.front,_=E-1-d.padInfo.left,R=$-1-d.padInfo.top,D=nt(i.shape,"float32"),M=t.bufferSync(r);for(let A=0;A<d.batchSize;++A)for(let z=0;z<d.inChannels;++z)for(let W=0;W<d.inDepth;++W)for(let Y=0;Y<d.inHeight;++Y)for(let K=0;K<d.inWidth;++K){const P=W-N,B=Y-R,G=K-_;let ee=0;for(let Z=0;Z<k;Z+=w){const F=(P+Z)/y;if(!(F<0||F>=d.outDepth||Math.floor(F)!==F))for(let V=0;V<$;V+=S){const Q=(B+V)/b;if(!(Q<0||Q>=d.outHeight||Math.floor(Q)!==Q))for(let re=0;re<E;re+=T){const he=(G+re)/x;if(he<0||he>=d.outWidth||Math.floor(he)!==he)continue;const ye=k*$*E-1-m.get(A,F,Q,he,z),we=Z*$*E+V*E+re,Ie=ye===we?1:0;if(Ie===0)continue;const Ce=M.get(A,F,Q,he,z);ee+=Ce*Ie}}}D.set(ee,A,W,Y,K,z)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const Jse={kernelName:_1,backendName:"cpu",kernelFunc:Yse};function Zse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,l=i;Ae([i,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=wr(l.shape,c,h,1,d,p),y=t.data.get(l.dataId).values,b=nt(m.outShape,l.dtype,tL(y,l.shape,l.dtype,m).values),x=m.strideHeight,w=m.strideWidth,S=m.dilationHeight,T=m.dilationWidth,k=m.effectiveFilterHeight,$=m.effectiveFilterWidth,E=$-1-m.padInfo.left,N=k-1-m.padInfo.top,_=nt(l.shape,"float32"),R=t.data.get(r.dataId).values,D=nt(r.shape,"float32",R);for(let M=0;M<m.batchSize;++M)for(let A=0;A<m.inChannels;++A)for(let z=0;z<m.inHeight;++z)for(let W=0;W<m.inWidth;++W){const Y=z-N,K=W-E;let P=0;for(let B=0;B<k;B+=S){const G=(Y+B)/x;if(!(G<0||G>=m.outHeight||Math.floor(G)!==G))for(let ee=0;ee<$;ee+=T){const Z=(K+ee)/w;if(Z<0||Z>=m.outWidth||Math.floor(Z)!==Z)continue;const F=k*$-1-b.get(M,G,Z,A),V=B*$+ee,Q=F===V?1:0;if(Q===0)continue;const re=D.get(M,G,Z,A);P+=re*Q}}_.set(P,M,z,W,A)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const Qse={kernelName:A1,backendName:"cpu",kernelFunc:Zse};function ere(n,e,t,s,r){const i=Oe(e),o=kC(n,e,t,i,r,"max"),l=tL(n,e,t,r,!0,s);return[o.values,l.values]}const tre={kernelName:RR,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=e,c=t;Ae(s,"MaxPoolWithArgmax");const h=c.data.get(s.dataId).values,d=wr(s.shape,r,i,[1,1],o),[p,m]=ere(h,s.shape,s.dtype,l,d),y=c.write(p,d.outShape,s.dtype),b=c.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function nre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=st(i,r.shape),h=An(r.shape,l)[1],d=pe(h),p=[],m=t.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const y=Uo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});p.push(y);const b=$C({inputs:{a:y,b:m},backend:t});p.push(b);const x=mf({inputs:{x:b},backend:t,attrs:{axis:i,keepDims:o}});return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const sre={kernelName:zg,backendName:"cpu",kernelFunc:nre};function rre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Ae(r,"min");const l=st(i,r.shape);let c=l;const h=Wt(c,r.shape.length);let d=r;h!=null&&(d=ys({inputs:{x:r},backend:t,attrs:{perm:h}}),c=nn(c.length,r.shape.length)),Fn("min",c,d.shape.length);const[p,m]=An(d.shape,c),y=pe(m),b=qn(pe(p),d.dtype),x=t.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];(Number.isNaN(E)||E<k)&&(k=E)}b[S]=k}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(o){const S=cn(p,l),T=Ot({inputs:{x:w},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(w),T}return w}const ire={kernelName:Bg,backendName:"cpu",kernelFunc:rre};function ore(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:o}=s;Ae(r,"mirrorPad");const l=i.map((k,$)=>k[0]+r.shape[$]+k[1]),c=i.map(k=>k[0]),h=i.map((k,$)=>k[0]+r.shape[$]),d=o==="reflect"?0:1,p=t.data.get(r.dataId).values,m=r.shape.length,y=Oe(r.shape),b=pe(l),x=l.length,w=Oe(l),S=Hn(r.dtype,b);for(let k=0;k<b;k++){let $=Hc(k,x,w);for(let N=0;N<x;N++)$[N]<c[N]?$[N]=c[N]*2-$[N]-d:$[N]>=h[N]&&($[N]=(h[N]-1)*2-$[N]+d);$=$.map((N,_)=>N-c[_]);const E=ai($,m,y);S[k]=p[E]}return{dataId:t.write(S,l,r.dtype),shape:l,dtype:r.dtype}}const are={kernelName:Vg,backendName:"cpu",kernelFunc:ore};const lre=rn(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),cre=Sn(Nd,lre),ure={kernelName:Nd,backendName:"cpu",kernelFunc:cre};function aL(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=r.shape.length;let l=i;if(l===-1&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const c=st([l],r.shape),h=oL({inputs:{x:r},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),d=cn(h.shape,c),p=Ot({inputs:{x:h},backend:t,attrs:{shape:d}}),m=TC({inputs:{a:r,b:p},backend:t}),y=hF({inputs:{x:m},backend:t}),b=mf({inputs:{x:y},backend:t,attrs:{axis:c,keepDims:!1}}),x=Ot({inputs:{x:b},backend:t,attrs:{shape:d}}),w=$C({inputs:{a:y,b:x},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const hre={kernelName:i0,backendName:"cpu",kernelFunc:aL};function dre(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:l}=s;Ae(r,"multinomial");const c=l?r:aL({inputs:{logits:r},backend:t,attrs:{dim:-1}}),h=c.shape[0],d=c.shape[1],p=t.data.get(c.dataId).values,m=[h,i],y=qn(pe(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=p[x];for(let k=1;k<w.length;++k)w[k]=w[k-1]+p[x+k];const S=hS.alea(o.toString()),T=b*i;for(let k=0;k<i;++k){const $=S();y[T+k]=w.length;for(let E=0;E<w.length;E++)if($<w[E]){y[T+k]=E;break}}}return l||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(m,"int32",y)}const fre={kernelName:DR,backendName:"cpu",kernelFunc:dre};const pre=vS;function mre(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s;Ae(r,"NonMaxSuppression");const h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:p}=pre(h,d,o,l,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const gre={kernelName:R1,backendName:"cpu",kernelFunc:mre};const yre=wS;function bre(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s;Ae(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,{selectedIndices:m,validOutputs:y}=yre(d,p,o,l,c,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const xre={kernelName:D1,backendName:"cpu",kernelFunc:bre};const vre=SS;function wre(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s;Ae(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=vre(d,p,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const Sre={kernelName:O1,backendName:"cpu",kernelFunc:wre};function Cre(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:l,offValue:c}=s;Ae(r,"oneHot");const h=pe(r.shape),d=new Float32Array(h*o);d.fill(c);const p=t.data.get(r.dataId).values;for(let m=0;m<h;++m)p[m]>=0&&p[m]<o&&(d[m*o+p[m]]=l);return t.makeTensorInfo([...r.shape,o],i,d)}const Tre={kernelName:Wg,backendName:"cpu",kernelFunc:Cre};function Jm(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=sl({inputs:{input:s},backend:t}),i=Jm({inputs:{x:r},backend:t}),o=Pc({inputs:{input:s},backend:t}),l=Jm({inputs:{x:o},backend:t}),c=Es({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}else return EC({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const kre={kernelName:l0,backendName:"cpu",kernelFunc:Jm};function lL(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=sl({inputs:{input:s},backend:t}),i=lL({inputs:{x:r},backend:t}),o=Pc({inputs:{input:s},backend:t}),l=Jm({inputs:{x:o},backend:t}),c=Es({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}else return EC({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const $re={kernelName:Gg,backendName:"cpu",kernelFunc:lL};function cL(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Ym({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(d=>{e1(i,d.shape,"All tensors passed to stack must have matching shapes"),L(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=e.map(d=>{const p=Ym({inputs:{input:d},backend:t,attrs:{dim:r}});return l.push(p),p}),h=zc({inputs:c,backend:t,attrs:{axis:r}});return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const Ere={kernelName:Hg,backendName:"cpu",kernelFunc:cL};function Ire(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;Ae(r,"pad");const l=i.map((T,k)=>T[0]+r.shape[k]+T[1]),c=i.map(T=>T[0]),h=t.data.get(r.dataId).values,d=pe(r.shape),p=r.shape.length,m=Oe(r.shape),y=pe(l),b=l.length,x=Oe(l),w=Hn(r.dtype,y);o!==0&&w.fill(o);for(let T=0;T<d;T++){const $=Hc(T,p,m).map((N,_)=>N+c[_]),E=ai($,b,x);w[E]=h[T]}return{dataId:t.write(w,l,r.dtype),shape:l,dtype:r.dtype}}const uL={kernelName:qg,backendName:"cpu",kernelFunc:Ire};const Nre=rn((n,e)=>Math.pow(n,e)),Are=Sn(_d,Nre),_re={kernelName:_d,backendName:"cpu",kernelFunc:Are};function Rre(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:l}=s,c=r.map(S=>t.data.get(S.dataId).values),h=r.map(S=>S.shape),d=t.data.get(i.dataId).values,p=t.data.get(o.dataId).values,[m,y,b]=NF(c,h,d,i.shape,i.dtype,p,o.shape),x=m.map(S=>t.makeTensorInfo([S.length],"int32",S)),w=t.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const Dre={kernelName:OR,backendName:"cpu",kernelFunc:Rre};function Ore(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,[h,d]=AF(o,s.shape,s.dtype,l,r.shape,c,i.shape),p=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Mre={kernelName:MR,backendName:"cpu",kernelFunc:Ore};function Fre(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=e,{rowPartitionTypes:c}=s,h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,p=t.data.get(o.dataId).values,m=l.map(w=>t.data.get(w.dataId).values),y=l.map(w=>w.shape),[b,x]=_F(h,r.shape,d,i.shape,i.dtype,p,o.shape,m,y,c);return t.makeTensorInfo(b,i.dtype,x)}const Lre={kernelName:FR,backendName:"cpu",kernelFunc:Fre};function Pre(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:o}=t,l=RF(s,r,o,i);return e.makeTensorInfo([l.length],i,l)}const zre={kernelName:M1,backendName:"cpu",kernelFunc:Pre};const Bre=Ct(Rd,n=>1/n),Vre={kernelName:Rd,backendName:"cpu",kernelFunc:Bre};function Ure(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s;Ae(r,"resizeBilinear");const c=Oe(r.shape),[h,d]=l,[p,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(pe([p,h,d,b])),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],T=[i&&h>1?h-1:h,i&&d>1?d-1:d];let k=0;const $=S[0]/T[0],E=S[1]/T[1];for(let N=0;N<p;N++)for(let _=0;_<h;_++){let R;o?R=$*(_+.5)-.5:R=$*_;const D=Math.max(0,Math.floor(R)),M=R-D,A=Math.min(m-1,Math.ceil(R)),z=N*c[0]+D*c[1],W=N*c[0]+A*c[1];for(let Y=0;Y<d;Y++){let K;o?K=E*(Y+.5)-.5:K=E*Y;const P=Math.max(0,Math.floor(K)),B=K-P,G=Math.min(y-1,Math.ceil(K)),ee=z+P*c[2],Z=W+P*c[2],F=z+G*c[2],V=W+G*c[2];for(let Q=0;Q<b;Q++){const re=x[ee+Q],he=x[Z+Q],ye=x[F+Q],we=x[V+Q],Ie=re+(ye-re)*B,Ce=he+(we-he)*B,Pe=Ie+(Ce-Ie)*M;w[k++]=Pe}}}return t.makeTensorInfo([p,h,d,b],"float32",w)}const jre={kernelName:Zg,backendName:"cpu",kernelFunc:Ure};function Gre(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;Ae([i,r],"resizeBilinearGrad");const l=Oe(r.shape),[c,h,d,p]=r.shape,[,m,y]=i.shape,b=new Float32Array(c*h*d*p),x=[o&&m>1?h-1:h,o&&y>1?d-1:d],w=[o&&m>1?m-1:m,o&&y>1?y-1:y],S=x[0]/w[0],T=x[1]/w[1],k=t.data.get(i.dataId).values;let $=0;for(let E=0;E<c;E++){const N=E*l[0];for(let _=0;_<m;_++){const R=_*S,D=Math.floor(R),M=Math.min(Math.ceil(R),h-1),A=N+D*l[1],z=N+M*l[1],W=R-D,Y=1-W;for(let K=0;K<y;K++){const P=K*T,B=Math.floor(P),G=Math.min(Math.ceil(P),d-1),ee=P-B,Z=1-ee,F=A+B*l[2],V=A+G*l[2],Q=z+B*l[2],re=z+G*l[2],he=Y*Z,ye=Y*ee,we=W*Z,Ie=W*ee;for(let Ce=0;Ce<p;Ce++){const Pe=k[$++];b[F+Ce]+=Pe*he,b[V+Ce]+=Pe*ye,b[Q+Ce]+=Pe*we,b[re+Ce]+=Pe*Ie}}}}return t.makeTensorInfo([c,d,h,p],"float32",b)}const Wre={kernelName:P1,backendName:"cpu",kernelFunc:Gre};function Hre(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s;Ae(r,"resizeNearestNeighbor");const c=Oe(r.shape),[h,d]=l,[p,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(p*h*d*b),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],T=[i&&h>1?h-1:h,i&&d>1?d-1:d],k=S[0]/T[0],$=S[1]/T[1];let E=0;for(let N=0;N<p;N++){const _=N*c[0];for(let R=0;R<h;R++){const D=o?k*(R+.5):k*R;let M=Math.min(m-1,i?Math.round(D):Math.floor(D));o&&(M=Math.max(0,M));const A=_+M*c[1];for(let z=0;z<d;z++){const W=o?$*(z+.5):$*z;let Y=Math.min(y-1,i?Math.round(W):Math.floor(W));o&&(Y=Math.max(0,Y));const K=A+Y*c[2];for(let P=0;P<b;P++){const B=x[K+P];w[E++]=B}}}}return t.makeTensorInfo([p,h,d,b],r.dtype,w)}const qre={kernelName:Jg,backendName:"cpu",kernelFunc:Hre};function Kre(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;Ae([i,r],"resizeNearestNeighborGrad");const l=Oe(r.shape),c=Oe(i.shape),[h,d,p,m]=r.shape,[,y,b]=i.shape,x=new Float32Array(h*d*p*m),w=t.data.get(i.dataId).values,S=[o&&y>1?d-1:d,o&&b>1?p-1:p],T=[o&&y>1?y-1:y,o&&b>1?b-1:b],k=S[0]/T[0],$=S[1]/T[1],E=1/k,N=1/$,_=Math.ceil(E)*2+2,R=Math.ceil(N)*2+2;for(let D=0;D<h;D++){const M=D*l[0];for(let A=0;A<d;A++){const z=M+A*l[1],W=Math.floor(A*E),Y=Math.floor(W-_/2);for(let K=0;K<p;K++){const P=z+K*l[2],B=Math.floor(K*N),G=Math.floor(B-R/2);for(let ee=0;ee<m;ee++){let Z=0;for(let F=0;F<_;F++){const V=F+Y;if(V<0||V>=y)continue;const Q=M+V*c[1],re=V*k,he=Math.min(d-1,o?Math.round(re):Math.floor(re));if(A===he)for(let ye=0;ye<R;ye++){const we=ye+G;if(we<0||we>=b)continue;const Ie=Q+we*c[2],Ce=we*$,Pe=Math.min(p-1,o?Math.round(Ce):Math.floor(Ce));K===Pe&&(Z+=w[Ie+ee])}}x[P+ee]=Z}}}}return t.makeTensorInfo(r.shape,r.dtype,x)}const Xre={kernelName:L1,backendName:"cpu",kernelFunc:Kre};function Yre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;Ae(r,"reverse");const o=r.shape.length,l=st(i,r.shape);if(o===0)return yi({inputs:{x:r},backend:t});const c=new On(r.shape,r.dtype),h=t.bufferSync(r);for(let d=0;d<c.size;d++){const p=c.indexToLoc(d),m=p.slice();l.forEach(y=>m[y]=r.shape[y]-1-m[y]),c.set(h.get(...m),...p)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}const Jre={kernelName:Qg,backendName:"cpu",kernelFunc:Yre};const Zre={kernelName:W1,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,l=t,c=Hn(s.dtype,pe(s.shape)),[h,d,p,m]=s.shape,[y,b]=OS(o,d,p),x=255,w=Math.sin(r),S=Math.cos(r),T=l.data.get(s.dataId).values;for(let $=0;$<h;$++){const E=$*p*d*m;for(let N=0;N<d;N++){const _=N*(p*m);for(let R=0;R<p;R++){const D=R*m;for(let M=0;M<m;M++){const A=[h,N,R,M],z=A[2],W=A[1];let Y=(z-y)*S-(W-b)*w,K=(z-y)*w+(W-b)*S;Y=Math.round(Y+y),K=Math.round(K+b);let P=i;if(typeof i!="number"&&(M===3?P=x:P=i[M]),Y>=0&&Y<p&&K>=0&&K<d){const G=K*(p*m),ee=Y*m,Z=E+G+ee+M;P=T[Z]}const B=E+_+D+M;c[B]=P}}}}return{dataId:l.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const Qre=Ct(Md,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),eie={kernelName:Md,backendName:"cpu",kernelFunc:Qre};function tie(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(i,r,o),m=!0,y=t.bufferSync(r),b=t.bufferSync(i),x=za(y,b,o,p,h,c,l,d,0,m);return t.makeTensorInfo(o,x.dtype,x.values)}const nie={kernelName:LR,backendName:"cpu",kernelFunc:tie};function sie(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function rie(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function iie(n,e,t,s,r,i){const o=Qt("int32",t*r);for(let l=0;l<t;++l){const c=n.slice(l*s,(l+1)*s),h=l*r;for(let d=0;d<r;++d)o[h+d]=i==="left"?sie(c,e[d+h]):rie(c,e[d+h])}return o}function oie(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,h=iie(l,c,r.shape[0],r.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",h)}const aie={kernelName:zR,backendName:"cpu",kernelFunc:oie};function lie(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;Ae([s,r,i],"select");const o=s.shape.length,l=t.data.get(s.dataId).values,c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=As(r.dtype,i.dtype),p=qn(pe(r.shape),d);let m=0;const y=o===0||o>1||r.shape.length===1?1:pe(r.shape.slice(1));for(let b=0;b<l.length;b++)for(let x=0;x<y;x++)l[b]===1?p[m++]=c[b]:p[m++]=h[b];return t.makeTensorInfo(r.shape,d,p)}const cie={kernelName:e0,backendName:"cpu",kernelFunc:lie};const uie=b0,hie=x0,die=Ct(Ld,n=>n>=0?hie*n:uie*(Math.exp(n)-1)),fie={kernelName:Ld,backendName:"cpu",kernelFunc:die};const pie=Ct(Bd,n=>n<0?-1:n>0?1:0),mie={kernelName:Bd,backendName:"cpu",kernelFunc:pie};const gie=Ct(Pd,n=>Math.sin(n)),yie={kernelName:Pd,backendName:"cpu",kernelFunc:gie};const bie=Ct(zd,n=>Math.sinh(n)),xie={kernelName:zd,backendName:"cpu",kernelFunc:bie};const vie=11920928955078125e-23,HN=Math.log(vie)+2,wie=Ct(Ud,n=>{const e=n>-HN,t=n<HN,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),Sie={kernelName:Ud,backendName:"cpu",kernelFunc:wie};function Cie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;Ae([r],"spaceToBatchND");const l=pe(i),c=[[0,0]];c.push(...o);for(let N=1+i.length;N<r.shape.length;++N)c.push([0,0]);const h=uL.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:c,constantValue:0}}),d=sf(h.shape,i,l,!1),p=rf(d.length,i.length,!1),m=of(h.shape,i,l,!1),x=Ot({inputs:{x:h},backend:t,attrs:{shape:d}}),T=ys({inputs:{x},backend:t,attrs:{perm:p}}),E=Ot({inputs:{x:T},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(T),E}const Tie={kernelName:s0,backendName:"cpu",kernelFunc:Cie};function kie(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=t.data.get(s.dataId).values,c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=t.data.get(o.dataId).values[0],[p,m,y,b,x]=FF(l,s.shape,s.dtype,c,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const $ie={kernelName:BR,backendName:"cpu",kernelFunc:kie};function Eie(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(r.dataId).values),l=t.data.get(s.dataId).values,c=Array.from(t.data.get(i.dataId).values),[h,d,p]=LF(l,s.shape,s.dtype,o,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const Iie={kernelName:VR,backendName:"cpu",kernelFunc:Eie};function Nie(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,[h,d]=CC(o,s.shape,s.dtype,l,c,!0);return t.makeTensorInfo(d,s.dtype,h)}const Aie={kernelName:UR,backendName:"cpu",kernelFunc:Nie};function _ie(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,[h,d]=CC(o,s.shape,s.dtype,l,c);return t.makeTensorInfo(d,s.dtype,h)}const Rie={kernelName:jR,backendName:"cpu",kernelFunc:_ie};function Die(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=cl(i,r,l),y=!1,b=t.bufferSync(r);let x;switch(i.dtype){case"bool":{const w=t.bufferSync(i),S=!!t.data.get(o.dataId).values[0];x=za(b,w,l,m,d,h,c,p,S,y);break}case"float32":{const w=t.bufferSync(i),S=t.data.get(o.dataId).values[0];x=za(b,w,l,m,d,h,c,p,S,y);break}case"int32":{const w=t.bufferSync(i),S=t.data.get(o.dataId).values[0];x=za(b,w,l,m,d,h,c,p,S,y);break}case"string":{const w=t.bufferSync(i),S=Lo(t.data.get(o.dataId).values[0]);x=za(b,w,l,m,d,h,c,p,S,y);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(l,x.dtype,x.values)}const Oie={kernelName:GR,backendName:"cpu",kernelFunc:Die};function Mie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,l=st(o,r.shape)[0],c=XS(r,i,l),h=new Array(r.shape.length).fill(0),d=r.shape.slice();return c.map(p=>{const m=[...d];m[l]=p;const y=rl({inputs:{x:r},backend:t,attrs:{begin:h,size:m}});return h[l]+=p,y})}const Fie={kernelName:r0,backendName:"cpu",kernelFunc:Mie};const Lie={kernelName:z1,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Ae(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let l=0;l<r.length;++l){const c=r[l];i[l]=c*c}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const Pie=Ct(Xd,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),zie={kernelName:Xd,backendName:"cpu",kernelFunc:Pie};function Bie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;Ae(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=_S(r.shape,i,o,l,c,h,d,p,m);let E;if(x)E=Ot({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||S){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=IS(T,k,$),_=rl({inputs:{x:r},backend:t,attrs:{begin:T,size:N}});E=Ot({inputs:{x:_},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(_)}else{const N=t.bufferSync(r),_=BF(y,N,$,T);E=t.makeTensorInfo(b,_.dtype,_.values)}return E}const Vie={kernelName:V1,backendName:"cpu",kernelFunc:Bie};function Uie(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=e,m=t.data.get(d.dataId).values,y=t.data.get(p.dataId).values,[b,x]=VF(m,y,r,i,o,l,c,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(p.shape,"int32",x)]}const jie={kernelName:WR,backendName:"cpu",kernelFunc:Uie};function Gie(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=t.data.get(i.dataId).values,c=t.data.get(o.dataId).values[0],[h,d,p]=UF(l,c,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const Wie={kernelName:HR,backendName:"cpu",kernelFunc:Gie};function Hie(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,l=jF(o,r);return t.makeTensorInfo(i.shape,"int32",l)}const qie={kernelName:qR,backendName:"cpu",kernelFunc:Hie};const Kie=Ct(Hd,n=>Math.tan(n)),Xie={kernelName:Hd,backendName:"cpu",kernelFunc:Kie};const Yie=Ct(qd,n=>Math.tanh(n)),Jie={kernelName:qd,backendName:"cpu",kernelFunc:Yie};function Zie(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=cl(i,r,s.shape),p=!1,m=t.bufferSync(r),y=t.bufferSync(i),b=t.bufferSync(s),x=za(m,y,s.shape,d,c,l,o,h,b,p);return t.makeTensorInfo(s.shape,x.dtype,x.values)}const Qie={kernelName:PR,backendName:"cpu",kernelFunc:Zie};function eoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;Ae(r,"tile");const o=WF(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const toe={kernelName:Kd,backendName:"cpu",kernelFunc:eoe};function noe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s;Ae(r,"topk");const l=t.data.get(r.dataId).values,[c,h]=qF(l,r.shape,r.dtype,i,o);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(h.shape,h.dtype,h.values)]}const soe={kernelName:U1,backendName:"cpu",kernelFunc:noe};function roe(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=t,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=Oe(r.shape),T=S[0],k=S[1],$=S[2],E=Oe(w),N=E[0],_=E[1],R=E[2],D=Hn(r.dtype,pe(w));D.fill(c);const M=s.data.get(r.dataId).values,A=s.data.get(i.dataId).values;for(let W=0;W<d;++W){const Y=i.shape[0]===1?A:A.subarray(W*8,W*8+8);for(let K=0;K<b;++K)for(let P=0;P<x;++P)for(let B=0;B<y;++B){let G;const ee=Y[6]*P+Y[7]*K+1;if(ee===0)continue;const Z=(Y[0]*P+Y[1]*K+Y[2])/ee,F=(Y[3]*P+Y[4]*K+Y[5])/ee,V=qN(Z,m,l),Q=qN(F,p,l);switch(o){case"nearest":G=uoe(M,p,m,T,k,$,W,Q,V,B,c);break;case"bilinear":G=hoe(M,p,m,T,k,$,W,Q,V,B,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const re=W*N+K*_+P*R+B;D[re]=G}return s.makeTensorInfo(w,r.dtype,D)}return{dataId:s.write(D,w,r.dtype),shape:r.shape,dtype:r.dtype}}const ioe={kernelName:j1,backendName:"cpu",kernelFunc:roe};function qN(n,e,t){switch(t){case"reflect":return ooe(n,e);case"wrap":return aoe(n,e);case"nearest":return coe(n,e);default:return loe(n)}}function ooe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Wa(0,t,e-1)}function aoe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Wa(0,t,e-1)}function loe(n,e){return n}function coe(n,e){return Wa(0,n,e-1)}function dh(n,e,t,s,r,i,o,l,c,h,d){const p=o*s+l*r+c*i+h;return 0<=l&&l<e&&0<=c&&c<t?n[p]:d}function uoe(n,e,t,s,r,i,o,l,c,h,d){const p=Math.round(l),m=Math.round(c);return dh(n,e,t,s,r,i,o,p,m,h,d)}function hoe(n,e,t,s,r,i,o,l,c,h,d){const p=Math.floor(l),m=Math.floor(c),y=p+1,b=m+1,x=(b-c)*dh(n,e,t,s,r,i,o,p,m,h,d)+(c-m)*dh(n,e,t,s,r,i,o,p,b,h,d),w=(b-c)*dh(n,e,t,s,r,i,o,y,m,h,d)+(c-m)*dh(n,e,t,s,r,i,o,y,b,h,d);return(y-l)*x+(l-p)*w}function doe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Ae(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:l,outputShape:c,indices:h}=KF(o,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const foe={kernelName:G1,backendName:"cpu",kernelFunc:doe};function poe(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,l=r.shape[i],c=new Array(o-1);let h=0;for(let y=0;y<o;y++)y!==i&&(c[h++]=r.shape[y]);const d=new Array(o).fill(0),p=r.shape.slice();p[i]=1;const m=new Array(l);for(let y=0;y<m.length;y++){d[i]=y;const b=rl({inputs:{x:r},backend:t,attrs:{begin:d,size:p}});m[y]=Ot({inputs:{x:b},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(b)}return m}const moe={kernelName:o0,backendName:"cpu",kernelFunc:poe};function goe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s;Ae(r,"unsortedSegmentSum");const l=r.shape.length,c=i.shape.length,h=[],d=[],p=l-c;let m=i;for(let b=0;b<p;++b){const x=Ym({inputs:{input:m},backend:t,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<o;++b){const x=Wo(b,"int32"),w=t.makeTensorInfo([],"int32",x),S=cF({inputs:{a:w,b:m},backend:t}),T=Uo({inputs:{x:S},backend:t,attrs:{dtype:"float32"}}),k=_0({inputs:{a:T,b:r},backend:t}),$=mf({inputs:{x:k},backend:t,attrs:{axis:0,keepDims:!1}});h.push($),d.push(w),d.push(S),d.push(T),d.push(k),d.push($)}const y=cL({inputs:h,backend:t,attrs:{axis:0}});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const yoe={kernelName:a0,backendName:"cpu",kernelFunc:goe};const boe=[dte,HQ,pte,gte,ZQ,bte,vte,Ste,Tte,$te,Ite,Ate,Rte,Mte,Lte,Bte,Ute,Gte,Hte,ute,Kte,Yte,Zte,eee,ene,YQ,nee,nne,qQ,rne,one,ane,cne,hne,fne,mne,yne,xne,wne,Cne,kne,Ene,Nne,_ne,Rne,One,Fne,Pne,zne,Bne,Vne,jne,Hne,ste,Kne,see,nse,ree,sse,oee,cse,use,dse,lee,uee,pse,gse,bse,vse,dee,pee,KQ,Sse,ine,Tse,$se,Ise,rte,gee,bee,Ase,vee,Rse,Mse,Lse,Bse,Use,Gse,Wse,See,qse,Xse,Jse,Qse,tre,sre,ire,Tee,are,ure,fre,$ee,Iee,gre,xre,Sre,Aee,Tre,$re,Ere,uL,_re,ote,Dee,Dre,Mre,Lre,zre,XQ,rw,Vre,ate,lte,cte,jre,Wre,qre,Xre,Jre,Zre,eie,Vee,nie,aie,cie,fie,jee,mie,yie,xie,Gee,hre,Sie,Tie,$ie,Iie,Aie,Rie,Oie,Fie,qee,Lie,Xee,Jee,zie,Vie,jie,Wie,qie,tte,Gne,Xie,Jie,Qie,toe,soe,ioe,_ee,foe,moe,yoe,kre];for(const n of boe)XR(n);const Oa={},Yp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xoe(n,e){Oa[n]=e}function Wr(n,e){if(!(n in Oa)||e!=null){const s=woe(n,e);if(s!==null)Oa[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Oa[n];return t==null||t.isContextLost()?(delete Oa[n],Wr(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Oa[n])}function voe(n){if(!ce().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function woe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??voe(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Oa[n]},!1),ce().getBool("SOFTWARE_WEBGL_ENABLED")&&(Yp.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Yp)||t.getContext("experimental-webgl",Yp):t.getContext("webgl2",Yp)}var Wh;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Wh||(Wh={}));var qs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(qs||(qs={}));var Dn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Dn||(Dn={}));function gf(n,e){return[e,n]}function Soe(n,e){return n*e}function Jp(n){const e=pe(n),t=Math.ceil(e/4);return Iv(t)}function Qc(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Coe(n,e){const[t,s]=Qc(n,e);return t*s*4}function IC(n,e){const t=n;let s,r,i,o,l,c,h,d,p,m;return ce().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,o=t.RGBA32F,l=t.RED,h=4,d=1,p=t.HALF_FLOAT,m=t.FLOAT,c=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=t.RGBA,l=n.RGBA,h=4,d=4,p=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,c=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:c,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function $e(n,e){const t=e();return ce().getBool("DEBUG")&&Toe(n),t}function Toe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Ioe(n,e))}const koe=596e-10,$oe=65504;function Eoe(n){return!!(ce().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||koe<Math.abs(n)&&Math.abs(n)<$oe)}function Ioe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Zp(n,e){return Zi(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Noe(n,e){const t=Zi(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if($e(n,()=>n.shaderSource(t,e)),$e(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Aoe(n,e){const t=Zi(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if($e(n,()=>n.shaderSource(t,e)),$e(n,()=>n.compileShader(t)),ce().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw hL(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const _oe=/ERROR: [0-9]+:([0-9]+):/g;function hL(n,e){const t=_oe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((p,m)=>Tc((m+1).toString(),i)+p);let l=0;for(let p=0;p<o.length;p++)l=Math.max(o[p].length,l);const c=o.slice(0,s-1),h=o.slice(s-1,s),d=o.slice(s);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Tc(h[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function Roe(n){return Zi(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Doe(n,e){if($e(n,()=>n.linkProgram(e)),!ce().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Vx(n,e){if($e(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Ooe(n,e){const t=Zi(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return $e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),$e(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Moe(n,e){const t=Zi(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return $e(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),$e(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Foe(n){return Zi(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Loe(n,e){const t=ce().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Poe(n){return Zi(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function KN(n,e,t,s,r,i,o){const l=n.getAttribLocation(e,t);return l===-1?!1:($e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),$e(n,()=>n.vertexAttribPointer(l,r,n.FLOAT,!1,i,o)),$e(n,()=>n.enableVertexAttribArray(l)),!0)}function zoe(n,e,t){Goe(n,t),$e(n,()=>n.activeTexture(n.TEXTURE0+t)),$e(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Boe(n,e,t){return Zi(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Voe(n,e,t){return n.getUniformLocation(e,t)}function Uoe(n,e,t,s){$e(n,()=>zoe(n,e,s)),$e(n,()=>n.uniform1i(t,s))}function Ux(n,e,t){$e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),$e(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function XN(n,e){$e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),$e(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Qp(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+joe(n,e))}function joe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Zi(n,e,t){const s=$e(n,()=>e());if(s==null)throw new Error(t);return s}function Goe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Bc(n,e=2){return pe(n.slice(0,n.length-e))}function Vc(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function em(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Bc(n),...Vc(n)]),e}function Woe(n,e=!1){let t=ce().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ce().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ce().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((l,c)=>c>=n.length-2?Qw(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Go(n).newShape);let r=pe(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const l=Bc(n);let c=2,h=2;n.length&&([c,h]=Vc(n)),r=l*(c/2)*(h/2),i=Iv(r).map(d=>d*2)}else i=Iv(r);return i}function tm(n){return n%2===0}function Zm(n,e){if(n=n.slice(-2),e=e.slice(-2),xt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||tm(t)&&tm(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&tm(n[0])&&tm(e[0])}let jx,Gx;function Hoe(n){if(jx==null){const e=Wr(n);jx=e.getParameter(e.MAX_TEXTURE_SIZE)}return jx}function qoe(n){if(Gx==null){const e=Wr(n);Gx=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Gx)}function Koe(n){if(n===0)return 0;let e;const t=Wr(n);return yr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:yr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function yr(n,e){return n.getExtension(e)!=null}function YN(n){try{if(Wr(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Xoe(n){if(n===0)return!1;const e=Wr(n);if(n===1){if(!yr(e,"OES_texture_float"))return!1}else if(!yr(e,"EXT_color_buffer_float"))return!1;return ow(e)}function Yoe(n){if(n===0)return!1;const e=Wr(n);if(n===1){if(!yr(e,"OES_texture_float")||!yr(e,"WEBGL_color_buffer_float"))return!1}else{if(yr(e,"EXT_color_buffer_float"))return ow(e);const s="EXT_color_buffer_half_float";if(yr(e,s)){const r=e.getExtension(s);return Joe(e,r)}return!1}return ow(e)}function ow(n){const e=IC(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function Joe(n,e){const t=IC(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),l}function Zoe(n){return n!==2?!1:Wr(n).fenceSync!=null}function yf(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&L(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const _e=ce();_e.registerFlag("HAS_WEBGL",()=>_e.getNumber("WEBGL_VERSION")>0);_e.registerFlag("WEBGL_VERSION",()=>YN(2)?2:YN(1)?1:0);_e.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);_e.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>_e.get("WEBGL_VERSION")===2);_e.registerFlag("WEBGL_CPU_FORWARD",()=>!0);_e.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);_e.registerFlag("WEBGL_PACK",()=>_e.getBool("HAS_WEBGL"));_e.registerFlag("WEBGL_PACK_NORMALIZATION",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_CLIP",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_REDUCE",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_LAZILY_UNPACK",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_CONV_IM2COL",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>_e.getBool("WEBGL_PACK"));_e.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Hoe(_e.getNumber("WEBGL_VERSION")));_e.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>qoe(_e.getNumber("WEBGL_VERSION")));_e.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=_e.getNumber("WEBGL_VERSION");return n===0?0:Koe(n)});_e.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>_e.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!lD());_e.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Xoe(_e.getNumber("WEBGL_VERSION")));_e.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>_e.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:_e.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));_e.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Yoe(_e.getNumber("WEBGL_VERSION")));_e.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Zoe(_e.getNumber("WEBGL_VERSION")));_e.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>_e.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);_e.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});_e.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>lD()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});_e.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);_e.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);_e.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);_e.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);_e.registerFlag("WEBGL_EXP_CONV",()=>!1);_e.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>_e.getBool("IS_TEST"));_e.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);_e.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);_e.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);_e.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function os(){let n,e,t,s,r,i,o,l,c,h;return ce().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",l=ce().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",o="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:c,defineRound:h}}function dl(n,e,t="index"){const s=Oe(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / ${r}`,l=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${l};`}).join("")}function R0(n,e,t="index"){const s=Oe(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,l=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${l};`}).join("")}function Qoe(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function eae(n,e,t="index"){const s=n.map((i,o)=>o),r=Qoe(s,e);return r.map((i,o)=>{const l=`int ${n[o]} = ${t} / ${r[o]}`,c=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${l}; ${c};`}).join("")}function NC(n){const e=Oe(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function AC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const dL=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:fL}=V7;function tae(n,e,t){const s=[];if(n.forEach(y=>{const b=pe(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),t.enableShapeUniforms){const{uniformShape:x}=_C(t.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>nae(y,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,l=os(),c=iae(l);let h,d,p=lae(l);return e.isPacked?(h=sae(e.logicalShape,o,t.enableShapeUniforms),d=aae(l)):(h=rae(e.logicalShape,o,t.enableShapeUniforms),d=oae(l)),t.packedInputs&&(p+=dae),[p,c,d,r,h,i,t.userCode].join(`
`)}function eu(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Tae(n,e);case 1:return $ae(n,e);case 2:return Iae(n,e);case 3:return Aae(n,e);case 4:return Rae(n,e);case 5:return Dae(n);case 6:return Oae(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function pL(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Cae(n);case 1:return kae(n,e);case 2:return Eae(n,e);case 3:return Nae(n,e);default:return _ae(n,e)}}function nae(n,e,t=!1,s){let r="";t?r+=pL(n,s):r+=eu(n,s);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?r+=Mae(n,e):r+=Fae(n,e)),r}function sae(n,e,t){switch(n.length){case 0:return mL();case 1:return fae(n,e,t);case 2:return wae(n,e,t);case 3:return mae(n,e,t);default:return yae(n,e,t)}}function rae(n,e,t){switch(n.length){case 0:return mL();case 1:return pae(n,e,t);case 2:return Sae(n,e,t);case 3:return gae(n,e,t);case 4:return bae(n,e,t);case 5:return xae(n,e);case 6:return vae(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function iae(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function oae(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function aae(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function lae(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${cae}
    ${uae}
    ${hae}
  `}const cae=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uae=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hae=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,dae=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function mL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function fae(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function pae(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function mae(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function gae(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${R0(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=dl(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function yae(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,l="",c="b, r, c";for(let h=2;h<n.length-1;h++)o*=n[n.length-h-1],l=`
      int b${h} = index / ${o};
      index -= b${h} * ${o};
    `+l,c=`b${h}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${c});
    }
  `}function bae(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${R0(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=dl(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function xae(n,e){const t=dl(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function vae(n,e){const t=dl(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function wae(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(xt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Sae(n,e,t){return xt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function fl(n){return`offset${n}`}function Cae(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=os();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function Tae(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=fl(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[l,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${c}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function kae(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=os();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function $ae(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${tu(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const l=fl(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${l});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${l});
      return sampleTexture(${t}, uv);
    }
  `}function Eae(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],l=i[1],c=os();if(i!=null&&xt(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${o}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function Iae(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&xt(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:l}=Go(t),c=o;if(c.length<t.length){const m=nu(n,c),y=["row","col"];return`
      ${eu(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${su(y,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${tu(n)}
      }
    `;const h=i[0],d=i[1],p=fl(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function Nae(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const m=t.slice(1),y=[1,2],b=nu(n,m),x=["b","row","col"];return`
        ${pL(b,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${su(x,y)});
        }
      `}const l=os();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=o[0],h=o[1],d=Math.ceil(t[2]/2),p=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${h}, ${p}, ${d}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Aae(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],o=t[2],{newShape:l,keptDims:c}=Go(t),h=l;if(h.length<t.length){const x=nu(n,h),w=["row","col","depth"];return`
        ${eu(x,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${su(w,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${tu(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===o&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=fl(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function _ae(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=os();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,l=n.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],h=c[0],d=c[1],p=Math.ceil(i[o-1]/2);let m=p*Math.ceil(i[o-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<o-1;x++)y=`int b${x}, `+y,m*=i[o-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Rae(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],o=t[2]*i,l=t[1]*o,{newShape:c,keptDims:h}=Go(t);if(c.length<t.length){const T=nu(n,c),k=["row","col","depth","depth2"];return`
      ${eu(T,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${su(k,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${i}, 1)));
        ${tu(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===l&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const S=fl(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${S});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${S});
      return sampleTexture(${s}, uv);
    }
  `}function Dae(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,l=e[1]*o,{newShape:c,keptDims:h}=Go(e);if(c.length<e.length){const x=nu(n,c),w=["row","col","depth","depth2","depth3"];return`
      ${eu(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${su(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${i}, ${r})) +
          depth3;
        ${tu(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===l&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=fl(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Oae(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Go(e);if(r.length<e.length){const w=nu(n,r),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${eu(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${su(S,i)});
      }
    `}const o=e[5],l=e[4]*o,c=e[3]*l,h=e[2]*c,d=e[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${c}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${tu(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${c}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(b===o&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=fl(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${c} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${t}, uv);
    }
  `}function tu(n){const e=n.name,t=pe(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Mae(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,l=fL(n.shapeInfo.logicalShape,e.logicalShape),c=$t(o),h=o-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":o<2&&l.length>=1?d="coords = 0;":d=l.map(T=>`coords.${p[T+h]} = 0;`).join(`
`);let m="";o<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((T,k)=>`coords.${p[k+h]}`).join(", ");let y="return outputValue;";const x=pe(n.shapeInfo.logicalShape)===1,S=pe(e.logicalShape)===1;if(i===1&&!x&&!S)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)o===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(l.length){const T=i-2,k=i-1;l.indexOf(T)>-1&&l.indexOf(k)>-1?y="return vec4(outputValue.x);":l.indexOf(T)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(k)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function Fae(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&l===c&&n.shapeInfo.flatOffset==null&&xt(o,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const h=$t(c),d=fL(n.shapeInfo.logicalShape,e.logicalShape),p=c-l;let m;const y=["x","y","z","w","u","v"];l===0?m="":c<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+p]} = 0;`).join(`
`);let b="";return c<2&&l>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+p]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function $t(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function _C(n,e,t){const{newShape:s,keptDims:r}=Go(e),i=e.length,o=n&&i===3&&e[0]===1,l=o?e.slice(1):s,c=!n&&i>1&&!xt(e,t)&&s.length<i||o;return{useSqueezeShape:c,uniformShape:c?l:e,keptDims:r}}function nu(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function su(n,e){return e.map(t=>n[t]).join(", ")}function Lae(n,e,t,s){const r=t.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=tae(r,o,e),c=Aoe(n.gl,l),h=n.createProgram(c);return ce().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:e,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:i,outShapeInfo:o},gL(n,e,h)))}function gL(n,e,t){const s=[],r=[];let i,o,l,c=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ce().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const p of e.variableNames){const m={name:p,uniform:n.getUniformLocation(t,p,d),offset:n.getUniformLocation(t,`offset${p}`,d)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${p}Shape`,d),m.texShape=n.getUniformLocation(t,`${p}TexShape`,d)),s.push(m)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),l=n.getUniformLocation(t,"outShapeStrides",d),o=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const p of e.customUniforms)r.push(n.getUniformLocation(t,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:c,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:o}}function JN(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],o=i.shape;if(!xt(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const l=t.texShape,c=i.isUniform?null:i.texData.texShape;if(!xt(l,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${c} must match`)})}function Pae(n,e,t,s,r){e.program.enableShapeUniforms||(JN(e.inShapeInfos,t),JN([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ce().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let c=0;c<t.length;++c){const h=t[c],{uniform:d,offset:p,shape:m,texShape:y}=e.variablesLocations[c];if(m){const{uniformShape:b}=_C(e.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(pe(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,c)}}const l=e.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const c=Oe(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let c=0;c<e.program.customUniforms.length;++c){const h=e.program.customUniforms[c],d=e.customUniformLocations[c],p=r[c];if(h.type==="float")n.gl.uniform1fv(d,p);else if(h.type==="vec2")n.gl.uniform2fv(d,p);else if(h.type==="vec3")n.gl.uniform3fv(d,p);else if(h.type==="vec4")n.gl.uniform4fv(d,p);else if(h.type==="int")n.gl.uniform1iv(d,p);else if(h.type==="ivec2")n.gl.uniform2iv(d,p);else if(h.type==="ivec3")n.gl.uniform3iv(d,p);else if(h.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function zae(n,e,t){let s="";e.concat(t).forEach(o=>{const l=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const c=o.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:p}=_C(n.packedInputs,o.shape,c);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Oe(d);b=`${E[0]===c[1]}_${E[E.length-1]===c[1]}`}const x=o.shape.length,w=d.length===2&&xt(o.shape,c),S=pe(o.shape)===1,T=Oc(o.shape,t.shape),k=!n.packedInputs&&x===t.shape.length&&xt(c,t.texData.texShape),$=n.packedInputs||d.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${x}_${k}_${h?p:""}_${d.length}_${S}_${T}_${w}_${m}_${y}_${b}_${$}_${l}`}else{const c=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${c}_${l}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${ce().getNumber("WEBGL_VERSION")}`,i}function Jn(n){return ce().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Bae{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Wh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=os();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?R0(["r","c","d"],e):dl(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class Vae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Wh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=os();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?R0(["r","c","d"],e):dl(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class Uae{constructor(e){this.variableNames=["A"],this.outTexUsage=qs.DOWNLOAD;const t=os();this.outputShape=e,this.userCode=`
      ${dL}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class jae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qs.DOWNLOAD;const t=os();this.outputShape=e,this.userCode=`
      ${dL}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const Gae={R:0,G:1,B:2,A:3};class ZN{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=os();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let l=0;l<s.length;l++){const c=s[l];o+=`
          if(offset == ${l}) {
            result = values[${Gae[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?AC():NC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class Wae{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=os();this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){const c=o*2+l;r+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?AC():NC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function Hae(n){const e=os(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Noe(n,t)}function qae(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Ooe(n,e)}function Kae(n){const e=new Uint16Array([0,1,2,2,1,3]);return Moe(n,e)}function bf(n,e,t,s,r,i){Loe(e,t);const o=Foe(n),l=n.TEXTURE_2D;return $e(n,()=>n.bindTexture(l,o)),$e(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),$e(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),$e(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),$e(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),ce().getNumber("WEBGL_VERSION")===1?$e(n,()=>n.texImage2D(l,0,s,e,t,0,r,i,null)):$e(n,()=>n.texStorage2D(l,1,s,e,t)),$e(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function yL(n){return n.internalFormatFloat}function Xae(n,e,t,s){const[r,i]=gf(e,t);return bf(n,r,i,yL(s),s.textureFormatFloat,n.FLOAT)}function bL(n){return n.internalFormatHalfFloat}function Yae(n,e,t,s){const[r,i]=gf(e,t);return bf(n,r,i,bL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function xL(n){return n.downloadTextureFormat}function Jae(n,e,t,s){const[r,i]=gf(e,t);return bf(n,r,i,xL(s),n.RGBA,n.UNSIGNED_BYTE)}function vL(n){return n.internalFormatPackedFloat}function Zae(n,e,t,s){const[r,i]=Qc(e,t);return bf(n,r,i,vL(s),n.RGBA,n.FLOAT)}function wL(n){return n.internalFormatPackedHalfFloat}function Qae(n,e,t,s){const[r,i]=Qc(e,t);return bf(n,r,i,wL(s),n.RGBA,s.textureTypeHalfFloat)}function ele(n,e,t){return $e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),KN(n,e,"clipSpacePos",t,3,20,0)&&KN(n,e,"uv",t,2,20,12)}function tle(n,e,t,s,r,i){$e(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,l,c;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),l=n.UNSIGNED_BYTE,c=n.RGBA):(o=new Float32Array(t*s*4),l=n.FLOAT,c=i.internalFormatPackedFloat),o.set(r),ce().getNumber("WEBGL_VERSION")===2?$e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,l,o)):$e(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,s,0,n.RGBA,l,o)),$e(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function nle(n,e,t){$e(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ce().getNumber("WEBGL_VERSION")===2?$e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):$e(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ce().getNumber("WEBGL_VERSION")===2?$e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):$e(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),$e(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function sle(n,e,t,s){const r=n.createBuffer();$e(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const l=4*4*e*t;return $e(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),$e(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),$e(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function rle(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function ile(n,e,t,s){const[r,i]=gf(e,t),o=4,l=new Uint8Array(Soe(e*t,o));return $e(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function ole(n,e,t,s,r,i,o,l){const c=n,h=new Float32Array(Coe(i,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,h),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),h}function ale(n,e,t){const s=new Float32Array(e*t*4);return $e(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}class Wx{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ce().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,xoe(t,e)):this.gl=Wr(t),e=this.gl,ce().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>$e(i,()=>i.createVertexArray()),this.bindVertexArray=o=>$e(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>$e(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>$e(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>$e(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>$e(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>$e(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>$e(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ce().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Zp(this.gl,i),yr(this.gl,o))this.textureHalfFloatExtension=Zp(this.gl,o);else if(ce().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),yr(this.gl,r))this.colorBufferHalfFloatExtension=Zp(this.gl,r);else if(ce().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",yr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(yr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=qae(this.gl),this.indexBuffer=Kae(this.gl),this.framebuffer=Poe(this.gl),this.textureConfig=IC(this.gl,this.textureHalfFloatExtension)}get debug(){return ce().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;$e(e,()=>e.finish()),$e(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),$e(e,()=>e.deleteFramebuffer(this.framebuffer)),$e(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),$e(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),$e(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Xae(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Yae(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Jae(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),nle(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),tle(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Qae(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Zae(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(XN(this.gl,this.framebuffer),this.outputTexture=null),$e(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>ile(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,o){return ole(this.gl,e,t,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return rle(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=sle(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ce().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=i}else ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>ale(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=Hae(t));const s=Roe(t);$e(t,()=>t.attachShader(s,this.vertexShader)),$e(t,()=>t.attachShader(s,e)),Doe(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Vx(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;$e(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),ele(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&($e(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Vx(this.gl,this.program),$e(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Boe(this.gl,e,t):Voe(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),$e(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Uoe(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Qc(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Vx(this.gl,this.program),Qp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}$e(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),$e(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Zp(this.gl,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await _I(()=>this.disposed||this.isQueryAvailable(e,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=lle(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ce().platform&&(s=ce().platform.setTimeoutCustom.bind(ce().platform)),_I(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ux(this.gl,e,this.framebuffer),this.debug&&Qp(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ux(this.gl,this.outputTexture,this.framebuffer),this.debug&&Qp(this.gl)):XN(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;Ux(r,e,this.framebuffer),this.debug&&Qp(r),this.outputTexture=e,$e(r,()=>r.viewport(0,0,t,s)),$e(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),$e(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function lle(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:cle,bincountImpl:SL,bincountReduceImpl:ule,bitwiseAndImpl:hle,castImpl:dle,ceilImpl:fle,concatImpl:ple,equalImpl:mle,expImpl:gle,expm1Impl:yle,floorImpl:ble,gatherNdImpl:xle,gatherV2Impl:vle,greaterImpl:wle,greaterEqualImpl:Sle,lessImpl:Cle,lessEqualImpl:Tle,linSpaceImpl:kle,logImpl:$le,maxImpl:Ele,maximumImpl:Ile,minimumImpl:Nle,multiplyImpl:Ale,negImpl:_le,notEqualImpl:Rle,prodImpl:Dle,raggedGatherImpl:Ole,raggedRangeImpl:Mle,raggedTensorToTensorImpl:Fle,rangeImpl:Lle,rsqrtImpl:Ple,scatterImpl:zle,sigmoidImpl:Ble,simpleAbsImpl:CL,sliceImpl:Vle,sparseFillEmptyRowsImpl:Ule,sparseReshapeImpl:jle,sparseSegmentReductionImpl:TL,sqrtImpl:Gle,staticRegexReplaceImpl:Wle,stridedSliceImpl:Hle,stringNGramsImpl:qle,stringSplitImpl:Kle,stringToHashBucketFastImpl:Xle,subImpl:Yle,tileImpl:Jle,topKImpl:Zle,transposeImpl:RC,uniqueImpl:Qle}=nte;function kL(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function ts(n,e){return e===1?[n]:kL(n,e)}function ece(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class tce{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Jn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=ts("rc",this.rank),s=$t(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class $L{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${nce(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?AC():NC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function nce(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?eae(["r","c","d"],"inputShape"):dl(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class sce{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=eA(t,s),i=tA(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=QN(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const c=this.freeTextures[i].pop();return this.usedTextures[i].push(c),c}let l;return r===Dn.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Dn.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Dn.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Dn.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Dn.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(l),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),l}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=eA(s,r),o=tA(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const l=QN(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),c=ce().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const h=this.usedTextures[o],d=h&&h.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function rce(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function QN(n,e,t,s,r){const i=ice(e,s);let o;if(r){const[c,h]=Qc(n[0],n[1]);o=c*h}else{const[c,h]=gf(n[0],n[1]);o=c*h}const l=rce(t,i);return o*l}function ice(n,e){switch(n){case Dn.PACKED_2X2_FLOAT32:return vL(e);case Dn.PACKED_2X2_FLOAT16:return wL(e);case Dn.UNPACKED_FLOAT32:return yL(e);case Dn.UNPACKED_FLOAT16:return bL(e);case Dn.PACKED_4X1_UNSIGNED_BYTE:return xL(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function oce(n){return ce().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Dn.PACKED_2X2_FLOAT32:Dn.UNPACKED_FLOAT32:n?Dn.PACKED_2X2_FLOAT16:Dn.UNPACKED_FLOAT16}function eA(n,e){if(n===qs.UPLOAD)return Dn.PACKED_2X2_FLOAT32;if(n===qs.RENDER||n==null)return oce(e);if(n===qs.DOWNLOAD||n===qs.PIXELS)return Dn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function tA(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class ri{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Cr="if (isnan(x)) return x;",ace="return x;",nA="return abs(x);",lce="return (x >= 0.0) ? x : (exp(x) - 1.0);",cce=Cr+`
  return (x < 0.0) ? 0.0 : x;
`,uce=Cr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,$o="return x;",hce="return 1.0 / (1.0 + exp(-1.0 * x));";const dce="return x;",fce=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,pce=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mce=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gce="return 1.0 / (1.0 + exp(-1.0 * x));";class Ao{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class yce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);const t=e.length,s=ts("rc",t),r=$t(t),i=ece(t,s),o=s.slice(-2),l=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}const bce=KD,xce=1e-7,vce=1e-4,nm={};function wce(n){return n in nm||(nm[n]={}),nm[n]}const Sce=ce().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Cce=600;function Tce(){return ce().global.screen==null?1024:ce().global.screen.height*ce().global.screen.width*window.devicePixelRatio*Cce/1024/1024}class D0 extends Zw{nextDataId(){return D0.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ce().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Wx)t=e;else{const s=Wr(ce().getNumber("WEBGL_VERSION"),e);t=new Wx(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Wr(ce().getNumber("WEBGL_VERSION"));t=new Wx(s),this.binaryCache=wce(ce().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new sce(this.gpgpu),this.numMBBeforeWarning=Tce(),this.texData=new wR(this,Qr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,o){const l=this.makeTensorInfo(t,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[r,i]},c.texShape=[r,i];const h=em(t),d=new ZN(h,!1,o),p=this.runWebGLProgram(d,[l],s,[[r,i]]);return p.shape=t,c.texture=null,this.disposeIntermediateTensorInfo(l),p.dataId}write(e,t,s){if((ce().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ce().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:qs.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(ce().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:qs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:l,isPacked:c}=t;if(o!=null){let m;c?m=new Ao(l,$o):m=new ri(l,$o);const y=this.runWebGLProgram(m,[{dataId:e,shape:l,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=hs());let p;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);p=Hi(m,y)}else p=this.getValuesFromTexture(e);return h&&(this.downloadWaitMs+=hs()-d),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const b=this.pendingRead.get(e);return new Promise(x=>b.push(x))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:l,isPacked:c}=t;if(i!=null){let b;c?b=new Ao(r,$o):b=new ri(r,$o);const x=this.runWebGLProgram(b,[{dataId:e,shape:r,dtype:o}],o),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(e);if(ce().getBool("DEBUG")&&!ce().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ce().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(o!=="complex64"&&ce().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Jp(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(o==="complex64"){const b=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),x=b[0],w=b[1];p=Hi(x,w)}else if(h==null)p=this.getValuesFromTexture(e);else{const b=pe(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;$e(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(e,p),y=this.pendingRead.get(e);return this.pendingRead.delete(e),y.forEach(b=>b(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Qr().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:o,dtype:l,isPacked:c,texture:h}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let y;c?y=new Ao(i,$o):y=new ri(i,$o);const b=this.runWebGLProgram(y,[{dataId:e,shape:i,dtype:l}],l),x=this.readToGPU(b,t);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),p=Qr().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Lo(r));return nt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return nt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!Eoe(s))throw ce().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=pe(t);if(ce().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Jp(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),b}const o=ce().getBool("WEBGL_PACK")&&r===!0,l=o?em(t):t,c=o?new jae(l):new Uae(l),h=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Ha(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Ha(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(i);l.kernelMs=P5(c),l.getExtraProfileInfo=()=>c.map((h,d)=>({name:o[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:hs(),endMs:null}}endTimer(e){return ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=hs(),e)}async getQueryTime(e){if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:o,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,h=this.dataRefCount.get(c);h>1?this.dataRefCount.set(c,h-1):(this.dataRefCount.delete(c),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,o)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Sce){return ce().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&pe(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Hs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return bce(e.shape,t)}packedUnaryOp(e,t,s){const r=new Ao(e.shape,t),i=this.compileAndRun(r,[e],s);return Qr().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=CL(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ce().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,nA,e.dtype);const t=new ri(e.shape,nA),s=this.compileAndRun(t,[e]);return Qr().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&ed(s[0])){const i=s.map(o=>Ro(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Qr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new yce(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new tce(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[Bc(e.shape),...Vc(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Bc(t),...Vc(t)],o=new $L(i,s),l=!0,c=[s],h=this.runWebGLProgram(o,[r],e.dtype,c,l);return{dataId:h.dataId,shape:t,dtype:h.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:o}=s;if(t!=null){const m=pe(i),y=t[0]*t[1]*4;L(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=em(i);let c;r?c=new Vae(l):c=new Bae(l);const h=!0,d=[t??Jp(l)],p=this.runWebGLProgram(c,[{shape:l,dtype:o,dataId:e}],o,d,h,t);return{dtype:o,shape:i,dataId:p.dataId}}runWebGLProgram(e,t,s,r,i=!1,o){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Wh.DENSE){const S=o??Jp(e.outputShape);c.texShape=S.map(T=>T*2)}if(e.outTexUsage!=null&&(c.usage=e.outTexUsage),pe(l.shape)===0)return c.values=Hn(l.dtype,0),l;const h=[],d=t.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(S.dataId);if(T.texture==null){if(!e.packedInputs&&pe(S.shape)<=ce().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:T.values};e.packedInputs&&(T.isPacked=!0,T.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!T.isPacked!=!!e.packedInputs)S=T.isPacked?this.unpackTensor(S):this.packTensor(S),h.push(S),T=this.texData.get(S.dataId);else if(T.isPacked&&!Zm(T.shape,S.shape)){const k=S,$=S.shape;S.shape=T.shape,S=this.packedReshape(S,$),h.push(S),T=this.texData.get(S.dataId),k.shape=$}return{shape:S.shape,texData:T,isUniform:!1}});this.uploadToGPU(l.dataId);const p={shape:l.shape,texData:c,isUniform:!1},m=zae(e,d,p),y=this.getAndSaveBinary(m,()=>Lae(this.gpgpu,e,d,p)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),ce().get("ENGINE_COMPILE_ONLY")||Pae(this.gpgpu,y,d,p,r),h.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=ce().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=hs();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!ce().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){const S=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),S}return l}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ce().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ie(()=>{if(!ce().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ce().getBool("DEBUG");ce().set("DEBUG",!1);const t=this.abs(bt(1e-8)).dataSync()[0];if(ce().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?xce:vce}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:l,isPacked:c}=t;if(o!=null)return;const h=this.activeTimers!=null;let d;h&&(d=hs());let p=t.texShape;if(p==null&&(p=Woe(s,c),t.texShape=p),i!=null){const m=em(s);let y,b=p[1],x=p[0];const w=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!w)&&([b,x]=Qc(p[0],p[1])),c?y=new Wae(m,w):y=new ZN(m,w);const S=w?[x,b]:p,T=this.makeTensorInfo(S,r),k=this.texData.get(T.dataId);w?k.usage=qs.PIXELS:k.usage=qs.UPLOAD,k.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),b,x,i);const $=[[x,b]],N=this.runWebGLProgram(y,[T],r,$,!0),_=this.texData.get(N.dataId);t.texShape=_.texShape,t.isPacked=_.isPacked,t.usage=_.usage,ce().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(t.texture=_.texture,t.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(T),h&&(this.uploadWaitMs+=hs()-d)}else{const m=this.acquireTexture(p,l,r,c);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=kce(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*$m(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await fO(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(hL(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:c}=gL(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:o,channels:l}=e,c=Qr().backend;if(!c.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=c.writeTexture(r,t,s,i,o,l);return Qr().makeTensorFromDataId(h,t,s,c)}}D0.nextDataId=0;function kce(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}cD()&&dD("webgl",()=>new D0,2);const DC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class il{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Ye(t,s),this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const pl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ru{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ye(t,s);const i=this.outputShape.length;this.enableShapeUniforms=Jn(i);let o="";if(r)if(i===0||pe(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${$t(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=ts("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function Rs(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const $ce={kernelName:wd,backendName:"webgl",kernelFunc:Rs};function ea(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(i.dataId),l=Rs({inputs:{x:s},backend:t}),c=Rs({inputs:{x:r},backend:t});return o.complexTensorInfos={real:l,imag:c},i}const Ece={kernelName:d1,backendName:"webgl",kernelFunc:ea};const EL="return (a < 0.) ? b * a : a;",IL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ice(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=t.makeTensorInfo([],"float32",Wo(i,"float32")),l=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(IL,r.shape,o.shape):new il(EL,r.shape,o.shape),c=t.runWebGLProgram(l,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),c}const Nce={kernelName:Ng,backendName:"webgl",kernelFunc:Ice};const NL="return (a < 0.) ? b * a : a;",AL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ace(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(AL,s.shape,r.shape):new il(NL,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const _ce={kernelName:Kg,backendName:"webgl",kernelFunc:Ace};const iu="if (isnan(x)) return x;";function dt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,l=i,c=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&t!=null){const p=l.texData.get(o.dataId),m=t(p.values,c);return l.makeTensorInfo(o.shape,c,m)}const h=ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return h?d=new Ao(o.shape,e):d=new ri(o.shape,n),l.runWebGLProgram(d,[o],c)}}function Ln({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:l})=>{const{a:c,b:h}=o,d=l;if(s&&c.dtype==="complex64"){const b=d.texData.get(c.dataId),x=d.texData.get(h.dataId),[w,S]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(k=>{const[$,E]=k,N={dataId:$.dataId,dtype:$.dtype,shape:c.shape},_={dataId:E.dataId,dtype:E.dtype,shape:h.shape},R=new il(n,c.shape,h.shape);return d.runWebGLProgram(R,[N,_],As($.dtype,E.dtype))}),T=ea({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),T}const p=i||As(c.dtype,h.dtype);if((c.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([c,h]))&&r!=null){const b=d.texData.get(c.dataId).values,x=d.texData.get(h.dataId).values,w=c.dtype==="string"?qi(b):b,S=c.dtype==="string"?qi(x):x,[T,k]=r(c.shape,h.shape,w,S,p),$=d.makeTensorInfo(k,p),E=d.texData.get($.dataId);return E.values=T,$}const m=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let y;return m?y=new ru(e,c.shape,h.shape,t):y=new il(n,c.shape,h.shape),d.runWebGLProgram(y,[c,h],p)}}function Hh(n,e=!1){if(n==="linear")return e?dce:ace;if(n==="relu")return e?pce:cce;if(n==="elu")return e?fce:lce;if(n==="relu6")return e?mce:uce;if(n==="prelu")return e?AL:NL;if(n==="leakyrelu")return e?IL:EL;if(n==="sigmoid")return e?gce:hce;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class _L{constructor(e,t,s,r=!1,i=!1,o=!1,l=null,c=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Jn(this.outputShape.length);const d=r?e[1]:e[2],p=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";l&&(c?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:w=`vec4 activation(vec4 x) {
          ${l}
        }`,S="result = activation(result);");const T=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let k="rc.x",$="rc.x";e[0]<t[0]?k=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&($=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${$};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${S}

        setOutput(result);
      }
    `}}const sA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class rA{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ye(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const iA="return a * b;";function OC(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=As(s.dtype,r.dtype);if(s.dtype==="complex64"){const l=t.texData.get(s.dataId),c=t.texData.get(r.dataId),h=new rA(sA.REAL,s.shape,r.shape),d=new rA(sA.IMAG,s.shape,r.shape),p=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:r.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(h,p,"float32"),y=t.runWebGLProgram(d,p,"float32"),b=ea({inputs:{real:m,imag:y},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}if(t.shouldExecuteOnCPU([s,r])){const l=t.texData.get(s.dataId),c=t.texData.get(r.dataId),[h,d]=Ale(s.shape,r.shape,l.values,c.values,i),p=t.makeTensorInfo(d,i),m=t.texData.get(p.dataId);return m.values=h,p}let o;return ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new ru(iA,s.shape,r.shape):o=new il(iA,s.shape,r.shape),t.runWebGLProgram(o,[s,r],i)}const Rce={kernelName:Ad,backendName:"webgl",kernelFunc:OC};function Dce(n,e,t){const s=[Bc(n.shape),...Vc(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[Bc(e),...Vc(e)],o=new $L(i,s),l=!0,c=[s],h=t.runWebGLProgram(o,[r],n.dtype,c,l);return{dataId:h.dataId,shape:e,dtype:h.dtype}}function ke(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=t,l=pe(r.shape),c=SR(i,l),h=pe(c);L(l===h,()=>`The new shape (${c}) has ${h} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(r.dataId);return d.isPacked&&!Zm(r.shape,c)&&!(d.texture!==null&&Zm(d.shape,c))?Dce(r,c,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype})}const Oce={kernelName:Yg,backendName:"webgl",kernelFunc:ke};class oA{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const l=Math.floor(s/4)*4,c=s%4;let h="sumValue += dot(values, ones);";if(t!=null){const p=1/t;h=`sumValue += dot(values * ${_c(p)?p.toPrecision(2):p}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class Mce{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let l="0.0",c="";t==="prod"?l="1.0":t==="min"?(l="1.0 / 1e-20",c="min"):t==="max"&&(l="-1.0 / 1e-20",c="max");let h=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?h="sumValue":t==="prod"?h="prodValue":t==="all"?h="allValue":t==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";t==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):t==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function Fce(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=y0(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function ml(n,e,t,s){const r=Fce(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:l,windowSize:c,outSize:h}=r[o];let d,p;t==="mean"?d=o===0?new oA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},l):new oA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h}):d=new Mce({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},t),p=i,i=s.runWebGLProgram(d,[i],e),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}class Lce{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=$t(this.rank),i=Pce(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Pce(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class zce{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=$t(this.rank),i=kL("rc",this.rank),o=new Array(this.rank);for(let d=0;d<t.length;d++)o[t[d]]=i[d];const l=`vec2(${o.slice(-2).join()})`,c=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${o.join()}), ${l})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${c}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${c}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function O0(n,e,t){const s=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zce(n.shape,e):new Lce(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function Bce(n,e,t,s){const r=e,i=n.shape.length,o=st(r,n.shape);let l=o;const c=Wt(l,i),h=c!=null;let d=n;h&&(d=O0(n,c,s),l=nn(l.length,i)),Fn("sum",l,i);const[p,m]=An(d.shape,l);let y=p;t&&(y=cn(p,o));const b=pe(m),w=pe(n.shape)/b,S=ke({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),T=H1(n.dtype),k=ml(S,T,"sum",s),$=ke({inputs:{x:k},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(k),h&&s.disposeIntermediateTensorInfo(d),$}function M0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return Bce(r,i,o,t)}const Vce={kernelName:n0,backendName:"webgl",kernelFunc:M0};function rs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,l=r.shape.length,c=new Array(l);for(let d=0;d<c.length;d++)c[d]=r.shape[i[d]];let h;if(o.shouldExecuteOnCPU([r])){const p=o.texData.get(r.dataId).values,m=RC(p,r.shape,r.dtype,i,c);h=o.makeTensorInfo(c,r.dtype);const y=o.texData.get(h.dataId);y.values=m}else h=O0(r,i,o);return h}const Uce={kernelName:kc,backendName:"webgl",kernelFunc:rs};const RL=1e3;function Qm({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:c=null}){const h=n.shape.length,d=e.shape.length,p=t?n.shape[h-2]:n.shape[h-1],m=s?e.shape[d-1]:e.shape[d-2],y=t?n.shape[h-1]:n.shape[h-2],b=s?e.shape[d-2]:e.shape[d-1],x=n.shape.slice(0,-2),w=e.shape.slice(0,-2),S=pe(x),T=pe(w),$=Ye(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([y,b]);L(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[S,p,y]:[S,y,p],N=s?[T,b,m]:[T,m,b],_=ke({inputs:{x:n},backend:r,attrs:{shape:E}}),R=ke({inputs:{x:e},backend:r,attrs:{shape:N}}),D=[_,R],M=Math.max(S,T),A=t?_.shape[1]:_.shape[2],z=i!=null,W=o!=null,Y=c==="leakyrelu",K=c!=null?Hh(c,!0):null,P=z||W||Y||K!=null;let B;if((y===1||b===1)&&A>RL&&P===!1){let ee=_,Z=R;t&&(ee=rs({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),D.push(ee)),s&&(Z=rs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),D.push(Z));const F=b!==1,V=b===1;let Q=ee;F&&(Q=ke({inputs:{x:ee},backend:r,attrs:{shape:[M,A,1]}}),D.push(Q));const re=b===1?2:1;let he=Z;V&&(he=ke({inputs:{x:Z},backend:r,attrs:{shape:[M,1,A]}}),D.push(he));const ye=OC({inputs:{a:Q,b:he},backend:r});B=M0({inputs:{x:ye},backend:r,attrs:{axis:re,keepDims:!0}}),D.push(ye)}else{const ee=As(n.dtype,e.dtype),Z=new _L(E,N,[M,y,b],t,s,z,K,W,Y),F=[_,R];if(i!=null&&F.push(i),W&&F.push(o),Y){const V=r.makeTensorInfo([],"float32",Wo(l,"float32"));F.push(V),D.push(V)}B=r.runWebGLProgram(Z,F,ee)}const G=ke({inputs:{x:B},backend:r,attrs:{shape:$}});D.push(B);for(const ee of D)r.disposeIntermediateTensorInfo(ee);return G}function jce(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=e,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;return Qm({a:r,b:i,transposeA:c,transposeB:h,backend:t,bias:o,preluActivationWeights:l,leakyreluAlpha:p,activation:d})}const Gce={kernelName:Em,backendName:"webgl",kernelFunc:jce};const aA="return abs(x);";function Wce(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),o=CL(i.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ao(s.shape,aA):r=new ri(s.shape,aA),t.runWebGLProgram(r,[s],s.dtype)}const Hce={kernelName:cg,backendName:"webgl",kernelFunc:Wce};const qce=Cr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Kce=dt({opSnippet:qce}),Xce={kernelName:td,backendName:"webgl",kernelFunc:Kce};const Yce=Cr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Jce=dt({opSnippet:Yce}),Zce={kernelName:nd,backendName:"webgl",kernelFunc:Jce};const lA="return a + b;",Qce=Ln({opSnippet:lA,packedOpSnippet:lA,supportsComplex:!0,cpuKernelImpl:cle}),eue={kernelName:qc,backendName:"webgl",kernelFunc:Qce};class tue{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class nue{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function gm(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Rs({inputs:{x:s[0]},backend:t});if(s.length>ce().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),h=gm({inputs:s.slice(0,c),backend:t}),d=gm({inputs:s.slice(c),backend:t});return gm({inputs:[h,d],backend:t})}const r=s.map(c=>c.dtype).reduce((c,h)=>As(c,h)),i=s.map(c=>c.shape),l=ce().getBool("WEBGL_PACK")?new nue(s[0].shape,i):new tue(s[0].shape,i);return t.runWebGLProgram(l,s,r)}const sue={kernelName:i1,backendName:"webgl",kernelFunc:gm};function rue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,c=st(i,r.shape);let h=c;const d=Wt(h,l);let p=r;d!=null&&(p=rs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=nn(h.length,l)),Fn("all",h,l);const[m,y]=An(p.shape,h),b=pe(y),x=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"all",t);let S;if(o){const T=cn(m,c);S=ke({inputs:{x:w},backend:t,attrs:{shape:T}})}else S=ke({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),S}const iue={kernelName:o1,backendName:"webgl",kernelFunc:rue};function oue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,c=st(i,r.shape);let h=c;const d=Wt(h,l);let p=r;d!=null&&(p=rs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=nn(h.length,l)),Fn("any",h,l);const[m,y]=An(p.shape,h),b=pe(y),x=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"any",t);let S;if(o){const T=cn(m,c);S=ke({inputs:{x:w},backend:t,attrs:{shape:T}})}else S=ke({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),S}const aue={kernelName:a1,backendName:"webgl",kernelFunc:oue};class lue{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const l=t==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class cue{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,L(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,c=l.length,h=$t(c),d=ts("coords",c);let p,m;if(o===1){m=c+1;const R=$t(m);p=`
        ${R} sourceLocR = ${R}(${d.join()}, 0);
        ++${d[c-1]};
        ${R} sourceLocG = ${R}(${d.join()}, 0);
        ++${d[c-2]};
        ${R} sourceLocA = ${R}(${d.join()}, 0);
        --${d[c-1]};
        ${R} sourceLocB = ${R}(${d.join()}, 0);
        --${d[c-2]};`}else m=c,p=`
        ${h} sourceLocR = coords;
        ++${d[c-1]};
        ${h} sourceLocG = coords;
        ++${d[c-2]};
        ${h} sourceLocA = coords;
        --${d[c-1]};
        ${h} sourceLocB = coords;
        --${d[c-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(R=>"int "+R),w=ts("sourceLocR",m-1).concat("inIdx.r"),S=ts("sourceLocG",m-1).concat("inIdx.g"),T=ts("sourceLocB",m-1).concat("inIdx.b"),k=ts("sourceLocA",m-1).concat("inIdx.a"),$=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${k.join()})));`,N=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,_=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[c-1]} < ${l[c-1]-1};
        bool hasNextRow = ${d[c-2]} < ${l[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function DL(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=y0(i),l={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},c=new lue(l,t,s==null),h=[e];s!=null&&h.push(s);const d=n.runWebGLProgram(c,h,"int32");if(d.shape[1]===1)return d;const p=DL(n,e,t,d);return n.disposeIntermediateTensorInfo(d),p}function OL(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=y0(i),l=new cue(r,o,t,s==null),c=s==null?[e]:[e,s],h=n.runWebGLProgram(l,c,"int32");if(h.shape.length===e.shape.length){const d=OL(n,e,t,h);return n.disposeIntermediateTensorInfo(h),d}return h}function ML(n,e,t,s){const r=[t];if(Fn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ce().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),l=o!==null&&o.isPacked;let c=e;l&&(c=n.unpackTensor(e),i.push(c));const[h,d]=An(c.shape,r),p=pe(d),m=ke({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});i.push(m);const y=DL(n,m,s);i.push(y);const b=ke({inputs:{x:y},backend:n,attrs:{shape:h}});return i.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return OL(n,e,s)}function uue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=st(i,r.shape);const l=Wt(o,r.shape.length);let c=r;const h=[];l!=null&&(c=rs({inputs:{x:r},backend:t,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),Fn("argMax",[o[0]],c.shape.length);const d=ML(t,c,o[0],"max");return h.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const hue={kernelName:ug,backendName:"webgl",kernelFunc:uue};function due(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=st(i,r.shape);const l=Wt(o,r.shape.length);let c=r;const h=[];l!=null&&(c=rs({inputs:{x:r},backend:t,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),Fn("argMin",[o[0]],c.shape.length);const d=ML(t,c,o[0],"min");return h.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const fue={kernelName:hg,backendName:"webgl",kernelFunc:due};const pue=Cr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,mue=dt({opSnippet:pue}),gue={kernelName:sd,backendName:"webgl",kernelFunc:mue};const yue=Cr+"return log(x + sqrt(x * x + 1.0));",bue=dt({opSnippet:yue}),xue={kernelName:rd,backendName:"webgl",kernelFunc:bue};const vue=Cr+`
  return atan(x);
`,wue=dt({opSnippet:vue}),Sue={kernelName:id,backendName:"webgl",kernelFunc:wue};const Cue=DC+`
  return atan(a, b);
`,Tue=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,kue=Ln({opSnippet:Cue,packedOpSnippet:Tue}),$ue={kernelName:ad,backendName:"webgl",kernelFunc:kue};const Eue=Cr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Iue=dt({opSnippet:Eue}),Nue={kernelName:od,backendName:"webgl",kernelFunc:Iue};class qh{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,S=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let T="0.0";if(x||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${l}, ${c});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?w:S:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const k="max";let $=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&($="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,N=o%4,_=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${E};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${$});
      }
    `}}class MC{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,l=e.strideDepth,c=e.strideHeight,h=e.strideWidth,d=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,S=e.padInfo.top,T=e.padInfo.left;this.outputShape=e.outShape;const k=t==="avg";let $="0.0";if(k||($="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${c}, ${h});
        const ivec3 pads = ivec3(${w}, ${S}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / max(count, 1.0)");const _=Math.floor(o/4)*4,R=o%4,D=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${c}, ${h});
      const ivec3 pads = ivec3(${w}, ${S}, ${T});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${_};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${N});
      }
    `}}function Aue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;yf(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Xn(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=wr(r.shape,i,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))return Rs({inputs:{x:r},backend:t});const p=new qh(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const _ue={kernelName:dg,backendName:"webgl",kernelFunc:Aue};function Rue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s,d=[1,1,1],p=Yi(r.shape,i,o,d,l,c,h),m=new MC(p,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const Due={kernelName:fg,backendName:"webgl",kernelFunc:Rue};class Oue{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=c-1-e.padInfo.top,p=h-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Mue{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,b=p-1-e.padInfo.front,x=m-1-e.padInfo.top,w=y-1-e.padInfo.left,S=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Fue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Yi(o.shape,l,c,p,h,d),y=new Mue(m);return t.runWebGLProgram(y,[r],o.dtype)}const Lue={kernelName:c1,backendName:"webgl",kernelFunc:Fue};function Pue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;yf([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=wr(o.shape,l,c,1,h),p=new Oue(d);return t.runWebGLProgram(p,[r],o.dtype)}const zue={kernelName:l1,backendName:"webgl",kernelFunc:Pue};function Bue(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:l}=s;return Qm({a:r,b:i,transposeA:o,transposeB:l,backend:t})}const Vue={kernelName:pg,backendName:"webgl",kernelFunc:Bue};class Uue{constructor(e,t,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ye(e,t),Ye(e,s);let l="0.0";r!=null&&(Ye(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="1.0";i!=null&&(Ye(e,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class jue{constructor(e,t,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ye(e,t),Ye(e,s);let l="vec4(0.0)";r!=null&&(Ye(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="vec4(1.0)";i!=null&&(Ye(e,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const Gue=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:o,scale:l}=n;L(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(l==null||r.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);const h=[s,r,i];let d=null;o!=null&&(d=o.shape,h.push(o));let p=null;l!=null&&(p=l.shape,h.push(l));const m=ce().getBool("WEBGL_PACK_NORMALIZATION")?new jue(s.shape,r.shape,i.shape,d,p,c):new Uue(s.shape,r.shape,i.shape,d,p,c);return e.runWebGLProgram(m,h,h[0].dtype)},Wue={kernelName:$g,backendName:"webgl",kernelFunc:Gue};class Hue{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=$t(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=que(this.rank);let r;const i=e.map((o,l)=>`sourceLoc.${aw[l]} = start[${l}] + coords.${aw[l]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const aw=["x","y","z","w","u","v"];function que(n){if(n===1)return"sourceLoc";if(n<=6)return aw.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Kue{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=$t(this.rank),s=ts("coords",this.rank),r=ts("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,l=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,p)=>`start[${p}]`).join()});`:e.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${l}
        ${c}
        setOutput(result);
      }
    `}}function Xue(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let l=AS(e,Oe(n.shape));r.slice&&(l+=r.slice.flatOffset),o.slice={flatOffset:l,origDataId:r.slice&&r.slice.origDataId||n.dataId};const c=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,c+1),i}function ou(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[l,c]=g0(r,i,o);if(ES(r,l,c),pe(c)===0)return t.makeTensorInfo(c,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=t.texData.get(r.dataId),m=Vle(p.values,l,c,r.shape,r.dtype);return t.makeTensorInfo(c,r.dtype,m)}const{isPacked:h}=t.texData.get(r.dataId),d=NS(r.shape,l,c);if(h||!d){const p=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Kue(c):new Hue(c),m=[l];return t.runWebGLProgram(p,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),Xue(r,l,c,t)}const Yue={kernelName:t0,backendName:"webgl",kernelFunc:ou};const Jue=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;L(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((T,k)=>T*k),c=sf(r.shape,i,l),h=rf(c.length,i.length),d=of(r.shape,i,l),p=MS(o,i.length),m=FS(d,o,i.length),y=[],b=ke({inputs:{x:r},backend:t,attrs:{shape:c}}),x=rs({inputs:{x:b},backend:t,attrs:{perm:h}}),w=ke({inputs:{x},backend:t,attrs:{shape:d}}),S=ou({inputs:{x:w},backend:t,attrs:{begin:p,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(T=>t.disposeIntermediateTensorInfo(T)),S},Zue={kernelName:mg,backendName:"webgl",kernelFunc:Jue};function Que(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,l=t.readSync(r.dataId),c=t.readSync(i.dataId),h=SL(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}const ehe={kernelName:u1,backendName:"webgl",kernelFunc:Que};const the=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,nhe=`
  return float(int(a.r) & int(b.r));
`;function she(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=ce().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||o===1){const c=t.texData.get(s.dataId).values,h=t.texData.get(r.dataId).values,[d,p]=hle(s.shape,r.shape,c,h,s.dtype),m=t.makeTensorInfo(p,s.dtype),y=t.texData.get(m.dataId);return y.values=d,m}let l;return i?l=new ru(the,s.shape,r.shape,!1):l=new il(nhe,s.shape,r.shape),t.runWebGLProgram(l,[s,r],s.dtype)}const rhe={kernelName:h1,backendName:"webgl",kernelFunc:she};function ihe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),l=Ye(Array.from(i),Array.from(o));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const ohe={kernelName:IR,backendName:"webgl",kernelFunc:ihe};const ahe="return float(a != b);",FL=Ln({opSnippet:ahe,cpuKernelImpl:Rle,dtype:"bool"}),lhe={kernelName:jg,backendName:"webgl",kernelFunc:FL};function xf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Rs({inputs:{x:r.complexTensorInfos.real},backend:t})}const che={kernelName:F1,backendName:"webgl",kernelFunc:xf};const uhe="return float(int(x));";function hhe(n,e){const t=new ri(n.shape,uhe),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function lw(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Rs({inputs:{x:r},backend:t});const o=In(r.shape),l=lw({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),c=ea({inputs:{real:l,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(l),c}if(r.dtype==="complex64"){const o=xf({inputs:{input:r},backend:t}),l=lw({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),l}if(!CR(r.dtype,i)){const o=Rs({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[l,c,h]=dle(o,r.shape,r.dtype,i);return t.makeTensorInfo(l,c,h)}if(i==="int32")return hhe(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",Hn("bool",1)),c=FL({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),c}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const dhe={kernelName:ld,backendName:"webgl",kernelFunc:lw};const cA="return ceil(x);",fhe=dt({opSnippet:cA,packedOpSnippet:cA,cpuKernelImpl:fle}),phe={kernelName:cd,backendName:"webgl",kernelFunc:fhe};class mhe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class ghe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function yhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let l;ce().getBool("WEBGL_PACK_CLIP")?l=new ghe(r.shape):l=new mhe(r.shape);const c=[[i],[o]];return t.runWebGLProgram(l,[r],r.dtype,c)}const bhe={kernelName:ud,backendName:"webgl",kernelFunc:yhe};class xhe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function uA(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function vhe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new xhe(s.shape),o=[uA(s,r.complexTensorInfos.real),uA(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const whe={kernelName:gg,backendName:"webgl",kernelFunc:vhe};class She{constructor(e){this.outputShape=[],this.outputShape=ci(e,1),this.variableNames=e.map((o,l)=>`T${l}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const l=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${l}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class Che{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ci(e,t);const s=this.outputShape,r=s.length,i=$t(r),o=ts("coords",r),l=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((x,w)=>`T${w}`);const c=new Array(e.length-1);c[0]=e[0][t];for(let x=1;x<c.length;x++)c[x]=c[x-1]+e[x][t];const h=l[t],d=l.slice(-2),p=l.join();let m=`if (${h} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let x=1;x<c.length;x++){const w=c[x-1];m+=`
        if (${h} < ${c[x]}  && ${h} >= ${c[x-1]}) {
          return getChannel(
            getT${x}(${sm(l,h,w)}),
            vec2(${sm(d,h,w)}));
        }`}const y=c.length,b=c[c.length-1];m+=`
        return getChannel(
          getT${y}(${sm(l,h,b)}),
          vec2(${sm(d,h,b)}));`,this.userCode=`
      float getValue(${l.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function sm(n,e,t){const s=n.indexOf(e);return n.map((i,o)=>o===s?`${i} - ${t}`:i).join()}function F0(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Rs({inputs:{x:r.complexTensorInfos.imag},backend:t})}const The={kernelName:I1,backendName:"webgl",kernelFunc:F0};function fh(n,e,t){const s=n[0].dtype;if(s==="complex64"){const y=n.map(T=>xf({inputs:{input:T},backend:t})),b=n.map(T=>F0({inputs:{input:T},backend:t})),x=fh(y,e,t),w=fh(b,e,t),S=ea({inputs:{real:x,imag:w},backend:t});return y.forEach(T=>t.disposeIntermediateTensorInfo(T)),b.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),S}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map($=>{const N=[-1,pe($.shape.slice(e))];return ke({inputs:{x:$},backend:t,attrs:{shape:N}})}),b=y.map($=>({vals:t.readSync($.dataId),shape:$.shape})),x=ci(y.map($=>$.shape),1),w=y[0].shape[0]===1,S=ple(b,x,s,w),T=ci(n.map($=>$.shape),e),k=t.makeTensorInfo(T,s,S);return y.forEach($=>t.disposeIntermediateTensorInfo($)),k}const i=n.filter(y=>pe(y.shape)>0),o=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=o?new ri(n[0].shape,$o):new Ao(n[0].shape,$o);return t.runWebGLProgram(y,n,s)}const l=ce().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const y=[];for(let x=0;x<i.length;x+=l){const w=i.slice(x,x+l);y.push(fh(w,e,t))}const b=fh(y,e,t);for(const x of y)t.disposeIntermediateTensorInfo(x);return b}if(o){const y=new Che(i.map(b=>b.shape),e);return t.runWebGLProgram(y,i,s)}const{tensors2D:c,outShape:h}=khe(i,e,t),d=new She(c.map(y=>y.shape)),p=t.runWebGLProgram(d,c,s);c.forEach(y=>t.disposeIntermediateTensorInfo(y));const m=ke({inputs:{x:p},attrs:{shape:h},backend:t});return t.disposeIntermediateTensorInfo(p),m}function khe(n,e,t){const s=ci(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>ke({inputs:{x:i},attrs:{shape:[-1,pe(i.shape.slice(e))]},backend:t})),outShape:s}}function LL(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=st(r,e[0].shape)[0],o=e.map(h=>h.shape);RS(o,i);const l=ci(e.map(h=>h.shape),i);if(pe(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const c=e.filter(h=>pe(h.shape)>0);return c.length===1?Rs({inputs:{x:c[0]},backend:t}):fh(c,i,t)}const $he={kernelName:yg,backendName:"webgl",kernelFunc:LL};class PL{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",S=w?1:2,T=w?2:3,k=w?3:1;let $="",E="";s&&(r?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:$=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const N=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${c}, ${h});
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${E}
        setOutput(result);
      }
    `}}class Ehe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterDepth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zL{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const S=w*2;if(m+=`
           xC = xCCorner + ${S*c};
           `,l===1){if(S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,c===1&&S>0?m+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const T=o%2===0?Qw(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,c>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:m+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):T===1?m+=`
                     xC${S+1} = xTexelC${S};
                     `:m+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(m+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(m+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(m+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class Ihe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Jn(this.outputShape.length);const{dataFormat:s}=t,r=os(),i=s==="channelsLast",o=i?1:2,l=i?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}function eg(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function BL({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape,h=s.texData.get(n.dataId),d=t.inChannels,p=c[0]*c[1]*c[2],m=t.outChannels,y=t.dataFormat==="channelsLast",b=!1,x=!1;let w;const S=[];if(i!=null){const $=eg(i.shape,y);$!=null&&(i=ke({inputs:{x:i},backend:s,attrs:{shape:$}}),S.push(i))}if(r!=null){const $=eg(r.shape,y);$!=null&&(r=ke({inputs:{x:r},backend:s,attrs:{shape:$}}),S.push(r))}if(!((p===1||m===1)&&d>RL)&&h.isPacked&&y&&h.texture!=null&&c[2]%2!==0&&xt(h.shape.slice(-3),c.slice(-3))){const $=c[0]*c[1]*(c[2]+1),E={dataId:n.dataId,shape:[1,$,t.inChannels],dtype:n.dtype},N=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,L(Zm(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const _=ke({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});S.push(_);const R=Qm({a:E,b:_,backend:s,transposeA:b,transposeB:x,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),D=s.texData.get(R.dataId);L(D.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=N,D.shape=t.outShape,w=Rs({inputs:{x:R},backend:s}),w.shape=t.outShape,S.push(R)}else{const $=t.outHeight*t.outWidth,E=ke({inputs:{x:n},backend:s,attrs:{shape:y?[t.batchSize,$,t.inChannels]:[t.batchSize,t.inChannels,$]}}),N=ke({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),_=Qm({a:y?E:N,b:y?N:E,transposeA:!y,transposeB:x,backend:s,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o});w=ke({inputs:{x:_},backend:s,attrs:{shape:t.outShape}}),S.push(E),S.push(N),S.push(_)}for(const $ of S)s.disposeIntermediateTensorInfo($);return w}function VL({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:c,filterHeight:h,inChannels:d,outWidth:p,outHeight:m,dataFormat:y}=t,b=y==="channelsLast",x=c*h*d,w=m*p,S=[t.batchSize,x,w],T=!0,k=!1,$=[];if(i!=null){const G=eg(i.shape,b);G!=null&&(i=ke({inputs:{x:i},backend:s,attrs:{shape:G}}),$.push(i))}if(r!=null){const G=eg(r.shape,b);G!=null&&(r=ke({inputs:{x:r},backend:s,attrs:{shape:G}}),$.push(r))}const E=ke({inputs:{x:e},backend:s,attrs:{shape:[1,x,pe(e.shape)/x]}});$.push(E);const N=new Ihe(S,t),_=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],R=s.runWebGLProgram(N,[n],"float32",_),D=ke({inputs:{x:R},backend:s,attrs:{shape:S}});$.push(R),$.push(D);const M=r!=null,A=i!=null,z=l==="leakyrelu",W=l?Hh(l,!0):null,Y=new _L(b?D.shape:E.shape,b?E.shape:D.shape,b?[t.batchSize,w,t.outChannels]:[t.batchSize,t.outChannels,w],T,k,M,W,A,z),K=b?[D,E]:[E,D];if(r&&K.push(r),A&&K.push(i),z){const G=s.makeTensorInfo([],"float32",Wo(o,"float32"));K.push(G),$.push(G)}const P=s.runWebGLProgram(Y,K,"float32"),B=ke({inputs:{x:P},backend:s,attrs:{shape:t.outShape}});$.push(P);for(const G of $)s.disposeIntermediateTensorInfo(G);return B}function Nhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s,p=Ji(c),m=Mn(r.shape,i.shape,o,h,l,d,!1,p);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=BL({x:r,filter:i,convInfo:m,backend:t});else if(m.strideWidth<=2&&p==="channelsLast"&&ce().getBool("WEBGL_EXP_CONV")){const x=new zL(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=t.runWebGLProgram(x,[r,i],"float32",w)}else if(ce().getBool("WEBGL_CONV_IM2COL"))y=VL({x:r,filter:i,convInfo:m,backend:t});else{const x=new PL(m);y=t.runWebGLProgram(x,[r,i],"float32")}const b=ke({inputs:{x:y},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(y),b}const Ahe={kernelName:bg,backendName:"webgl",kernelFunc:Nhe};class _he{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Rhe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",l=t-1-e.padInfo.top,c=s-1-e.padInfo.left,h=o?1:2,d=o?2:3,p=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Dhe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,l=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${l};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ohe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,c=t-1-e.padInfo.front,h=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Mhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s,p=Ji(c),m=Mn(r.shape,d,o,1,l,h,!1,p),y=new _he(m);return t.runWebGLProgram(y,[r,i],"float32")}const Fhe={kernelName:f1,backendName:"webgl",kernelFunc:Mhe};class Lhe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Jn(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Phe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s,p=Ji(h),m=Mn(o,i.shape,l,1,c,d,!1,p);if(ce().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new Lhe(m);return t.runWebGLProgram(b,[r,i],"float32",y)}else{const y=new Rhe(m);return t.runWebGLProgram(y,[r,i],"float32")}}const zhe={kernelName:xg,backendName:"webgl",kernelFunc:Phe};function Bhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:c}=s,h=qo(r.shape,i.shape,o,c,l),d=new Ehe(h);return t.runWebGLProgram(d,[r,i],"float32")}const Vhe={kernelName:vg,backendName:"webgl",kernelFunc:Bhe};function Uhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,filterShape:c}=s,h=qo(r.shape,c,o,1,l),d=new Dhe(h);return t.runWebGLProgram(d,[r,i],"float32")}const jhe={kernelName:p1,backendName:"webgl",kernelFunc:Uhe};function Ghe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:l,inputShape:c}=s,h=qo(c,i.shape,l,1,o),d=new Ohe(h);return t.runWebGLProgram(d,[r,i],"float32")}const Whe={kernelName:m1,backendName:"webgl",kernelFunc:Ghe};const Hhe=iu+`
  return cos(x);
`,qhe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${pl}
  return result;
`,Khe=dt({opSnippet:Hhe,packedOpSnippet:qhe}),Xhe={kernelName:hd,backendName:"webgl",kernelFunc:Khe};const Yhe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Jhe=dt({opSnippet:Yhe}),Zhe={kernelName:dd,backendName:"webgl",kernelFunc:Jhe};class Qhe{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,l,c,h]=e,[d]=t,[p,m]=s;this.outputShape=[d,p,m,h];const y=r==="bilinear"?1:0,[b,x]=[`${l-1}.0`,`${c-1}.0`],[w,S,T]=p>1?[`${(l-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[k,$,E]=m>1?[`${(c-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${$};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const ede=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:l,method:c,extrapolationValue:h}=s,d=new Qhe(r.shape,i.shape,l,c,h);return t.runWebGLProgram(d,[r,i,o],"float32")},tde={kernelName:y1,backendName:"webgl",kernelFunc:ede};var Kh;(function(n){n.Prod="*",n.Sum="+"})(Kh||(Kh={}));class hA{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Kh.Prod?"1.0":"0.0",l=s?o:`getX(${dA(i,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${c-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${c}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${$t(i)} coords = getOutputCoords();
        int end = ${fA(i,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${fA(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${dA(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function dA(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function fA(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function UL(n,e,t,s,r,i){const o=e.shape.length,l=Wt([s],o);let c=e;l!=null&&(c=rs({inputs:{x:e},backend:t,attrs:{perm:l}}));const h=nn(1,o)[0];if(h!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=c.shape[h];let p=Rs({inputs:{x:c},backend:t});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new hA(n,c.shape,!1,i),b=[[m]],x=p;p=t.runWebGLProgram(y,[p],p.dtype,b),t.disposeIntermediateTensorInfo(x)}if(r){const m=new hA(n,c.shape,r,i),y=p;p=t.runWebGLProgram(m,[p],p.dtype),t.disposeIntermediateTensorInfo(y)}if(l!=null){const m=Ko(l),y=rs({inputs:{x:p},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),y}return p}function nde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;return UL(Kh.Prod,r,t,i,o,l)}const sde={kernelName:g1,backendName:"webgl",kernelFunc:nde};function rde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;return UL(Kh.Sum,r,t,i,o,l)}const ide={kernelName:wg,backendName:"webgl",kernelFunc:rde};function ode(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const c=t.readSync(r.dataId),h=t.readSync(i.dataId),d=SL(c,h,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,d)}else if(r.shape.length===2){const c=t.bufferSync(r),h=t.bufferSync(i),d=ule(c,h,o,l);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const ade={kernelName:b1,backendName:"webgl",kernelFunc:ode};class lde{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function cde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,l=r.shape[0],c=o==="NHWC"?r.shape[1]:r.shape[2],h=o==="NHWC"?r.shape[2]:r.shape[3],d=o==="NHWC"?r.shape[3]:r.shape[1],p=c*i,m=h*i,y=d/(i*i),b=o==="NHWC"?[l,p,m,y]:[l,y,p,m],x=new lde(b,i,o);return t.runWebGLProgram(x,[r],r.dtype)}const ude={kernelName:x1,backendName:"webgl",kernelFunc:cde};class jL{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=e.filterHeight,l=e.filterWidth,c=e.outChannels/e.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}}class GL{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=e.outChannels/e.inChannels,l=e.padInfo.left,c=e.strideWidth,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,m=p;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<p;S++)y+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<p;S++)y+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const T=S*2;if(y+=`
          xC = xCCorner + ${T*h};
          `,c===1){if(T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,h===1&&T>0?y+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<p)){const k=l%2===0?Qw(h):h;h%2===0&&l%2===1||h%2!==0&&l%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:y+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):k===1?y+=`
                    xC${T+1} = xTexelC${T};
                    `:y+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<p&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<p&&(y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<p&&(y+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<p&&(y+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function hde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;let d=c;d==null&&(d=[1,1]),L(Xn(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Mn(r.shape,i.shape,o,d,l,h,!0);let m;ce().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new GL(p):m=new jL(p);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(m,[r,i],"float32",y)}const dde={kernelName:Sg,backendName:"webgl",kernelFunc:hde};class fde{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pde{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function mde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s,p=Mn(r.shape,d,o,l,c,h,!0),m=new fde(p);return t.runWebGLProgram(m,[r,i],"float32")}const gde={kernelName:v1,backendName:"webgl",kernelFunc:mde};function yde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s,p=Mn(d,i.shape,o,l,c,h,!0),m=new pde(p);return t.runWebGLProgram(m,[r,i],"float32")}const bde={kernelName:w1,backendName:"webgl",kernelFunc:yde};class xde{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function vde(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=pe(s.shape),o=ke({inputs:{x:s},backend:t,attrs:{shape:[i]}}),l=new xde(i),c=t.runWebGLProgram(l,[o],o.dtype),h=ke({inputs:{x:c},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),h}const wde={kernelName:NR,backendName:"webgl",kernelFunc:vde};class Sde{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:l,filterWidth:c,dilationHeight:h,dilationWidth:d}=e,{top:p,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function Cde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:c}=s,h=Zd(r.shape,i.shape,o,l,"NHWC",c);let d;const p=new Sde(h);d=t.runWebGLProgram(p,[r,i],"float32");const m=ke({inputs:{x:d},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(d),m}const Tde={kernelName:Cg,backendName:"webgl",kernelFunc:Cde};function kde(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:l,idDims:c}=GS(r,i.length);HS(o.length,c,i);const{path:h,steps:d}=qS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=WS(y,c[w]);let k;KS(S)?k=i[w]:(k=rs({inputs:{x:i[w]},backend:t,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);xt(k.shape,$)||(k=ke({inputs:{x:k},backend:t,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=OC({inputs:{a:k,b:m},backend:t}),b.push(m))}x<p-1&&(h[x]>=0&&(m=M0({inputs:{x:m},backend:t,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const $de={kernelName:S1,backendName:"webgl",kernelFunc:kde};const Ede="return (x >= 0.0) ? x : (exp(x) - 1.0);",Ide=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Nde=dt({opSnippet:Ede,packedOpSnippet:Ide}),Ade={kernelName:pd,backendName:"webgl",kernelFunc:Nde};const _de="return (b >= 0.0) ? a : a * (b + 1.0);",Rde=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Dde=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(Rde,s.shape,r.shape):new il(_de,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},Ode={kernelName:C1,backendName:"webgl",kernelFunc:Dde};const Mde=`
  return vec4(equal(a, b));
`,Fde="return float(a == b);",Lde=Ln({opSnippet:Fde,packedOpSnippet:Mde,dtype:"bool",cpuKernelImpl:mle}),Pde={kernelName:Tg,backendName:"webgl",kernelFunc:Lde};const zde=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${LS};
  float a1 = ${PS};
  float a2 = ${zS};
  float a3 = ${BS};
  float a4 = ${VS};
  float a5 = ${US};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Bde=dt({opSnippet:zde}),Vde={kernelName:md,backendName:"webgl",kernelFunc:Bde};const Ude=iu+`
  return exp(x);
`,jde=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WL=dt({opSnippet:Ude,packedOpSnippet:jde,cpuKernelImpl:gle,dtype:"float32"}),Gde={kernelName:gd,backendName:"webgl",kernelFunc:WL};function cw(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,l=i.shape.slice();let c=r;return r<0&&(L(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+r+1),l.splice(c,0,1),ke({inputs:{x:i},backend:s,attrs:{shape:l}})}const Wde={kernelName:kg,backendName:"webgl",kernelFunc:cw};const pA="return exp(x) - 1.0;",Hde=dt({opSnippet:pA,packedOpSnippet:pA,cpuKernelImpl:yle}),qde={kernelName:yd,backendName:"webgl",kernelFunc:Hde};class mA{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let l;if(e==="real")l="return real * expR - imag * expI;";else if(e==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function HL(n,e,t){const s=t.texData.get(n.dataId),r=pe(n.shape),i=n.shape[n.shape.length-1],o=r/i,l=ke({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),c=l.shape,h=new mA("real",c,e),d=new mA("imag",c,e),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],m=t.runWebGLProgram(h,p,"float32"),y=t.runWebGLProgram(d,p,"float32"),b=ea({inputs:{real:m,imag:y},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y);const x=ke({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(b),x}function Kde(n){const{inputs:e,backend:t}=n,{input:s}=e;return HL(s,!1,t)}const Xde={kernelName:T1,backendName:"webgl",kernelFunc:Kde};class Yde{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function vf(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||Wc(r),i==="string"){const o=Qt(i,pe(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new Yde(s,r),l=[[r]];return e.runWebGLProgram(o,[],i,l)}}const Jde={kernelName:k1,backendName:"webgl",kernelFunc:vf};class Zde{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const Qde={kernelName:$1,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Zde(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const gA="return floor(x);",efe=dt({opSnippet:gA,packedOpSnippet:gA,cpuKernelImpl:ble}),tfe={kernelName:bd,backendName:"webgl",kernelFunc:efe};const nfe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,sfe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,rfe=Ln({opSnippet:nfe,packedOpSnippet:sfe,dtype:"int32"}),ife={kernelName:xd,backendName:"webgl",kernelFunc:rfe};class ofe{constructor(e){this.variableNames=["A"];const t=os(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class afe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=os(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const lfe={kernelName:Q5,backendName:"webgl",kernelFunc:cfe};let cc,Hx=ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function cfe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[c,h]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,c],p=[h,c,i];if(l||o){const x=ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(cc==null||x!==Hx)&&(Hx=x,cc=document.createElement("canvas").getContext("2d",{willReadFrequently:Hx})),cc.canvas.width=c,cc.canvas.height=h,cc.drawImage(r,0,0,c,h),r=cc.canvas}const m=t.makeTensorInfo(d,"int32");t.texData.get(m.dataId).usage=qs.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const y=ce().getBool("WEBGL_PACK")?new afe(p):new ofe(p),b=t.runWebGLProgram(y,[m],"int32");return t.disposeData(m.dataId),b}function ufe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=Ji(d),w=Mn(r.shape,i.shape,c,p,h,m,!1,x);let S;const T=[],k=o!=null,$=l!=null,E=y==="leakyrelu",N=()=>{const R=[r,i],D=(M,A)=>{if(A==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const z=ke({inputs:{x:M},backend:t,attrs:{shape:[M.shape[0],1,1]}});return T.push(z),z}return M};if(k&&R.push(D(o,d)),$&&R.push(D(l,d)),E){const M=t.makeTensorInfo([],"float32",Wo(b,"float32"));R.push(M),T.push(M)}return R};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=BL({x:r,filter:i,convInfo:w,backend:t,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&ce().getBool("WEBGL_EXP_CONV")){const R=y?Hh(y,!0):null,D=new zL(w,k,R,$,E),M=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=N();S=t.runWebGLProgram(D,A,"float32",M)}else if(ce().getBool("WEBGL_CONV_IM2COL"))S=VL({x:r,filter:i,convInfo:w,backend:t,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else{const R=y?Hh(y,!1):null,D=new PL(w,k,R,$,E),M=N();S=t.runWebGLProgram(D,M,"float32")}const _=ke({inputs:{x:S},backend:t,attrs:{shape:w.outShape}});return T.push(S),T.forEach(R=>t.disposeIntermediateTensorInfo(R)),_}const hfe={kernelName:Im,backendName:"webgl",kernelFunc:ufe};function dfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:c,pad:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),L(Xn(c,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${x}'`);const w=Mn(r.shape,i.shape,c,x,h,p,!0),S=ce().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,T=m?Hh(m,S):null,k=[r,i],$=o!=null,E=l!=null,N=m==="leakyrelu";if($&&k.push(o),E&&k.push(l),N){const M=t.makeTensorInfo([],"float32",Wo(y,"float32"));k.push(M),b.push(M)}let _;S?_=new GL(w,$,T,E,N):_=new jL(w,$,T,E,N);const R=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],D=t.runWebGLProgram(_,k,"float32",R);return b.forEach(M=>t.disposeIntermediateTensorInfo(M)),D}const ffe={kernelName:KR,backendName:"webgl",kernelFunc:dfe};class pfe{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=$t(s.length);let o=`
    int index;`;for(let l=0;l<this.sliceDim;l++)o+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function mfe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],l=pe(s.shape),[c,h,d,p]=$S(s,r),m=ke({inputs:{x:r},backend:t,attrs:{shape:[h,o]}}),y=ke({inputs:{x:s},backend:t,attrs:{shape:[pe(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const S=t.readSync(r.dataId),T=t.bufferSync(s),k=xle(S,T,s.dtype,h,o,d,p,s.shape,l);return t.makeTensorInfo(c,s.dtype,k.values)}const b=new pfe(o,p,[h,d],s.shape),x=t.runWebGLProgram(b,[y,m],y.dtype),w=ke({inputs:{x},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),w}const gfe={kernelName:AR,backendName:"webgl",kernelFunc:mfe};class yfe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=$t(this.rank),r=bfe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function bfe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function qL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:l}=s,c=st(o,r.shape)[0];if(ce().get("DEBUG")){const T=t.readSync(i.dataId),k=r.shape[c];for(let $=0;$<T.length;++$){const E=T[$];L(E<=k-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${k-1}]`)}}const h=YS(r,i,c,l),d=pe(i.shape),p=[],m=ke({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=ke({inputs:{x:i},backend:t,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(m),p.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const T=t.bufferSync(y),k=t.bufferSync(m),$=vle(k,T,b);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(h.outputShape,$.dtype,$.values)}const x=new yfe(m.shape,b),w=t.runWebGLProgram(x,[m,y],m.dtype);p.push(w);const S=ke({inputs:{x:w},backend:t,attrs:{shape:h.outputShape}});return p.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}const xfe={kernelName:Eg,backendName:"webgl",kernelFunc:qL};const vfe="return float(a > b);",wfe=`
  return vec4(greaterThan(a, b));
`,Sfe=Ln({opSnippet:vfe,packedOpSnippet:wfe,cpuKernelImpl:wle,dtype:"bool"}),Cfe={kernelName:Ig,backendName:"webgl",kernelFunc:Sfe};const Tfe="return float(a >= b);",kfe=`
  return vec4(greaterThanEqual(a, b));
`,$fe=Ln({opSnippet:Tfe,packedOpSnippet:kfe,dtype:"bool",cpuKernelImpl:Sle}),Efe={kernelName:vd,backendName:"webgl",kernelFunc:$fe};function Ife(n){const{inputs:e,backend:t}=n,{input:s}=e;return HL(s,!0,t)}const Nfe={kernelName:E1,backendName:"webgl",kernelFunc:Ife};const Afe="return float(!isnan(x) && !isinf(x));",_fe=dt({opSnippet:Afe,dtype:"bool"}),Rfe={kernelName:Sd,backendName:"webgl",kernelFunc:_fe};const Dfe="return float(isinf(x));",Ofe=dt({opSnippet:Dfe,dtype:"bool"}),Mfe={kernelName:Cd,backendName:"webgl",kernelFunc:Ofe};const Ffe="return float(isnan(x));",Lfe=dt({opSnippet:Ffe,dtype:"bool"}),Pfe={kernelName:Td,backendName:"webgl",kernelFunc:Lfe};const zfe="return float(a < b);",Bfe=`
  return vec4(lessThan(a, b));
`,Vfe=Ln({opSnippet:zfe,packedOpSnippet:Bfe,cpuKernelImpl:Cle,dtype:"bool"}),Ufe={kernelName:Ag,backendName:"webgl",kernelFunc:Vfe};const jfe="return float(a <= b);",Gfe=`
  return vec4(lessThanEqual(a, b));
`,Wfe=Ln({opSnippet:jfe,packedOpSnippet:Gfe,cpuKernelImpl:Tle,dtype:"bool"}),Hfe={kernelName:_g,backendName:"webgl",kernelFunc:Wfe};function qfe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=kle(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const Kfe={kernelName:_R,backendName:"webgl",kernelFunc:qfe};const Xfe=iu+`
  return x < 0.0 ? 0./0. : log(x);
`,Yfe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Jfe=dt({opSnippet:Xfe,packedOpSnippet:Yfe,cpuKernelImpl:$le}),Zfe={kernelName:kd,backendName:"webgl",kernelFunc:Jfe};const Qfe=iu+`
  return log(1.0 + x);
`,epe=dt({opSnippet:Qfe}),tpe={kernelName:$d,backendName:"webgl",kernelFunc:epe};const npe="return float(a >= 1.0 && b >= 1.0);",spe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,rpe=Ln({opSnippet:npe,packedOpSnippet:spe,dtype:"bool"}),ipe={kernelName:Rg,backendName:"webgl",kernelFunc:rpe};const ope="return float(!(x >= 1.0));",ape=dt({opSnippet:ope}),lpe={kernelName:Dg,backendName:"webgl",kernelFunc:ape};const cpe="return float(a >= 1.0 || b >= 1.0);",upe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,hpe=Ln({opSnippet:cpe,packedOpSnippet:upe,dtype:"bool"}),dpe={kernelName:Og,backendName:"webgl",kernelFunc:hpe};class fpe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,l=e[3]-1;this.outputShape=e;let c;const h=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}class ppe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,l=e[3]-1;this.outputShape=e;let c;const h=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}const mpe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:l,beta:c}=s,h=ce().getBool("WEBGL_PACK_NORMALIZATION")?new ppe(r.shape,i,o,l,c):new fpe(r.shape,i,o,l,c);return t.runWebGLProgram(h,[r],r.dtype)},gpe={kernelName:Mg,backendName:"webgl",kernelFunc:mpe};class ype{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const bpe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:l,bias:c,alpha:h,beta:d}=s,p=new ype(r.shape,l,c,h,d);return t.runWebGLProgram(p,[r,i,o],r.dtype)},xpe={kernelName:N1,backendName:"webgl",kernelFunc:bpe};function vpe(n,e,t,s){const r=pe(e),o=pe(n.shape)/r,l=ke({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=ml(l,n.dtype,"max",s),h=ke({inputs:{x:c},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}function KL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,l=r.shape.length,c=st(i,r.shape);let h=c;const d=Wt(h,l),p=d!=null,m=t.shouldExecuteOnCPU([r]);let y=r;if(p){if(m){const k=t.texData.get(y.dataId).values,$=new Array(l);for(let _=0;_<$.length;_++)$[_]=r.shape[d[_]];const E=RC(k,r.shape,r.dtype,d,$);y=t.makeTensorInfo($,r.dtype);const N=t.texData.get(y.dataId);N.values=E}else y=O0(r,d,t);h=nn(h.length,l)}Fn("max",h,l);const[b,x]=An(y.shape,h);let w=b;o&&(w=cn(b,c));let S;if(m){const k=t.texData.get(y.dataId).values,$=Ele(k,pe(x),w,r.dtype);S=t.makeTensorInfo(w,r.dtype);const E=t.texData.get(S.dataId);E.values=$}else S=vpe(y,x,w,t);return p&&t.disposeIntermediateTensorInfo(y),S}const wpe={kernelName:Fg,backendName:"webgl",kernelFunc:KL};const Spe=DC+`
  return max(a, b);
`,Cpe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,Tpe=Ln({opSnippet:Spe,packedOpSnippet:Cpe,cpuKernelImpl:Ile}),kpe={kernelName:Ed,backendName:"webgl",kernelFunc:Tpe};function $pe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;yf(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Xn(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=wr(r.shape,i,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))return Rs({inputs:{x:r},backend:t});const p=new qh(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const Epe={kernelName:Lg,backendName:"webgl",kernelFunc:$pe};function Ipe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=[1,1,1],p=Yi(r.shape,i,o,d,l,h,c),m=new MC(p,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const Npe={kernelName:Pg,backendName:"webgl",kernelFunc:Ipe};class Ape{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=o-1-e.padInfo.left,h=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class _pe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=c-1-e.padInfo.front,m=h-1-e.padInfo.top,y=d-1-e.padInfo.left,b=c*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Rpe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Yi(o.shape,l,c,p,h,d),y=new MC(m,"max",!0),b=t.runWebGLProgram(y,[o],o.dtype),x=new _pe(m),w=t.runWebGLProgram(x,[r,b],o.dtype);return t.disposeIntermediateTensorInfo(b),w}const Dpe={kernelName:_1,backendName:"webgl",kernelFunc:Rpe};function Ope(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,l=i;yf([i,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=wr(l.shape,c,h,1,d,p),y=!0,b=new qh(m,"max",y),x=t.runWebGLProgram(b,[l],l.dtype),w=new Ape(m),S=t.runWebGLProgram(w,[r,x],l.dtype);return t.disposeIntermediateTensorInfo(x),S}const Mpe={kernelName:A1,backendName:"webgl",kernelFunc:Ope};function Fpe(n,e,t,s){let r=new qh(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new qh(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}const Lpe={kernelName:RR,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=e,c=t;L(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];L(Xn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=wr(s.shape,r,i,h,o),[p,m]=Fpe(s,l,d,c);return[p,m]}};function Ppe(n,e,t,s){const r=pe(e),o=pe(n.shape)/r,l=ke({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=ml(l,"float32","mean",s),h=ke({inputs:{x:c},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}const zpe={kernelName:zg,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,o=t,l=s.shape.length,c=st(i,s.shape);let h=c;const d=Wt(h,l),p=d!=null,m=o.shouldExecuteOnCPU([s]),y=[];let b=s;if(p){if(m){const $=o.texData.get(b.dataId).values,E=new Array(l);for(let R=0;R<E.length;R++)E[R]=s.shape[d[R]];const N=RC($,s.shape,s.dtype,d,E);b=o.makeTensorInfo(E,s.dtype);const _=o.texData.get(b.dataId);_.values=N}else b=O0(s,d,o);y.push(b),h=nn(h.length,l)}Fn("sum",h,l);const[x,w]=An(b.shape,h);let S=x;r&&(S=cn(x,c));const T=Ppe(b,w,S,o);for(const k of y)o.disposeIntermediateTensorInfo(k);return T}};function Bpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,c=st(i,r.shape);let h=c;const d=Wt(h,l);let p=r;d!=null&&(p=rs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=nn(h.length,r.shape.length)),Fn("min",h,l);const[m,y]=An(p.shape,h),b=pe(y),x=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"min",t);let S;if(o){const T=cn(m,c);S=ke({inputs:{x:w},backend:t,attrs:{shape:T}})}else S=ke({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),S}const Vpe={kernelName:Bg,backendName:"webgl",kernelFunc:Bpe};const Upe=DC+`
  return min(a, b);
`,jpe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,Gpe=Ln({opSnippet:Upe,packedOpSnippet:jpe,cpuKernelImpl:Nle}),Wpe={kernelName:Id,backendName:"webgl",kernelFunc:Gpe};class Hpe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,p)=>d[0]+e[p]+d[1]);const r=e.length,i=$t(r),o=t.map(d=>d[0]).join(","),l=t.map((d,p)=>d[0]+e[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}class qpe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((b,x)=>b[0]+e[x]+b[1]);const r=e.length,i=$t(r),o=t.map(b=>b[0]).join(","),l=t.map((b,x)=>b[0]+e[x]).join(","),c=ts("rc",r),h=ts("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${c[r-2]} += 1;
        if(${c[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${c[r-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const Kpe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,o=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qpe(s.shape,r,i):new Hpe(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},Xpe={kernelName:Vg,backendName:"webgl",kernelFunc:Kpe};const Ype=`if (b == 0.0) return NAN;
  return mod(a, b);`,Jpe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+pl+`
  return result;
`,Zpe=Ln({opSnippet:Ype,packedOpSnippet:Jpe}),Qpe={kernelName:Nd,backendName:"webgl",kernelFunc:Zpe};class eme{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const tme=`
if (a == b) {
  return 1.0;
};
return a / b;`,nme=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,XL=Ln({opSnippet:tme,packedOpSnippet:nme,checkOutOfBounds:!0}),sme={kernelName:fd,backendName:"webgl",kernelFunc:XL};const yA="return a - b;",YL=Ln({opSnippet:yA,packedOpSnippet:yA,supportsComplex:!0,cpuKernelImpl:Yle}),rme={kernelName:Wd,backendName:"webgl",kernelFunc:YL};function JL(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=st([i],r.shape),l=KL({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),c=cn(l.shape,o),h=ke({inputs:{x:l},backend:t,attrs:{shape:c}}),d=YL({inputs:{a:r,b:h},backend:t}),p=WL({inputs:{x:d},backend:t}),m=M0({inputs:{x:p},backend:t,attrs:{axis:o,keepDims:!1}}),y=ke({inputs:{x:m},backend:t,attrs:{shape:c}}),b=XL({inputs:{a:p,b:y},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const ime={kernelName:i0,backendName:"webgl",kernelFunc:JL};function ome(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:l}=s,c=l?r:JL({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),h=c.shape[0],d=c.shape[1],p=new eme(h,d,i),m=[[o]],y=t.runWebGLProgram(p,[c],"int32",m);return l||t.disposeIntermediateTensorInfo(c),y}const ame={kernelName:DR,backendName:"webgl",kernelFunc:ome};const lme=Cr+`
  return -x;
`,cme=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ume(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[o,l]=_le(i.values,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,o)}let r;return ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ao(s.shape,cme):r=new ri(s.shape,lme),t.runWebGLProgram(r,[s],s.dtype)}const hme={kernelName:Ug,backendName:"webgl",kernelFunc:ume};const dme=vS;function fme(n){Hs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:p}=dme(h,d,o,l,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const pme={kernelName:R1,backendName:"webgl",kernelFunc:fme};const mme=wS;function gme(n){Hs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=mme(d,p,o,l,c,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const yme={kernelName:D1,backendName:"webgl",kernelFunc:gme};const bme=SS;function xme(n){Hs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=bme(d,p,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const vme={kernelName:O1,backendName:"webgl",kernelFunc:xme};class wme{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const Sme=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:l,offValue:c}=s,h=pe(r.shape),d=new wme(h,o,l,c),p=ke({inputs:{x:r},backend:t,attrs:{shape:[h]}}),m=t.runWebGLProgram(d,[p],i);t.disposeIntermediateTensorInfo(p);const y=[...r.shape,o],b=ke({inputs:{x:m},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(m),b},Cme={kernelName:Wg,backendName:"webgl",kernelFunc:Sme};function tg(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=xf({inputs:{input:s},backend:t}),i=tg({inputs:{x:r},backend:t}),o=F0({inputs:{input:s},backend:t}),l=tg({inputs:{x:o},backend:t}),c=ea({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}else return vf({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const Tme={kernelName:l0,backendName:"webgl",kernelFunc:tg};function ZL(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=xf({inputs:{input:s},backend:t}),i=ZL({inputs:{x:r},backend:t}),o=F0({inputs:{input:s},backend:t}),l=tg({inputs:{x:o},backend:t}),c=ea({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}else return vf({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const kme={kernelName:Gg,backendName:"webgl",kernelFunc:ZL};function $me(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return cw({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(d=>{e1(i,d.shape,"All tensors passed to stack must have matching shapes"),L(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=e.map(d=>{const p=cw({inputs:{input:d},backend:t,attrs:{dim:r}});return l.push(p),p}),h=LL({inputs:c,backend:t,attrs:{axis:r}});return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const Eme={kernelName:Hg,backendName:"webgl",kernelFunc:$me};class Ime{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,d)=>h[0]+e[d]+h[1]);const r=e.length,i=$t(r),o=t.map(h=>h[0]).join(","),l=t.map((h,d)=>h[0]+e[d]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}class Nme{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,w)=>x[0]+e[w]+x[1]);const r=e.length,i=$t(r),o=t.map(x=>x[0]).join(","),l=t.map((x,w)=>x[0]+e[w]).join(","),c=ts("rc",r),h=ts("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${c[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${c[r-2]} += 1;
       if(${c[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${c[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=r===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const QL=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(pe(r.shape)===0){const h=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return vf({backend:t,attrs:{shape:h,value:o,dtype:r.dtype}})}const l=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Nme(r.shape,i,o):new Ime(r.shape,i,o),c=[[o]];return t.runWebGLProgram(l,[r],r.dtype,c)},Ame={kernelName:qg,backendName:"webgl",kernelFunc:QL};const _me=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Rme=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+pl+`
  return result;
`,Dme=Ln({opSnippet:_me,packedOpSnippet:Rme}),Ome={kernelName:_d,backendName:"webgl",kernelFunc:Dme};function Mme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,c=[],h=st(i,r.shape);let d=h;const p=Wt(d,l);let m=r;p!=null&&(m=rs({inputs:{x:r},backend:t,attrs:{perm:p}}),d=nn(d.length,l),c.push(m)),Fn("prod",d,l);let y;if(t.shouldExecuteOnCPU([m])){const b=t.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:S}=Dle(m.shape,m.dtype,b,d);y=t.makeTensorInfo(w,S,x)}else{const[b,x]=An(m.shape,d),w=pe(x),S=ke({inputs:{x:m},backend:t,attrs:{shape:[-1,w]}}),T=H1(r.dtype),k=ml(S,T,"prod",t);y=ke({inputs:{x:k},backend:t,attrs:{shape:b}}),c.push(S),c.push(k)}if(o){c.push(y);const b=cn(y.shape,h);y=ke({inputs:{x:y},backend:t,attrs:{shape:b}})}return c.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const Fme={kernelName:Xg,backendName:"webgl",kernelFunc:Mme};function Lme(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:l}=s,c=r.map(S=>t.readSync(S.dataId)),h=r.map(S=>S.shape),d=t.readSync(i.dataId),p=t.readSync(o.dataId),[m,y,b]=Ole(c,h,d,i.shape,i.dtype,p,o.shape,l),x=m.map(S=>t.makeTensorInfo([S.length],"int32",S)),w=t.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const Pme={kernelName:OR,backendName:"webgl",kernelFunc:Lme};function zme(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),[h,d]=Mle(o,s.shape,s.dtype,l,r.shape,c,i.shape),p=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Bme={kernelName:MR,backendName:"webgl",kernelFunc:zme};function Vme(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=e,{rowPartitionTypes:c}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),p=t.readSync(o.dataId),m=l.map(w=>t.readSync(w.dataId)),y=l.map(w=>w.shape),[b,x]=Fle(h,r.shape,d,i.shape,i.dtype,p,o.shape,m,y,c);return t.makeTensorInfo(b,i.dtype,x)}const Ume={kernelName:FR,backendName:"webgl",kernelFunc:Vme};const eP=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,l=Lle(s,r,i,o);return e.makeTensorInfo([l.length],o,l)},jme={kernelName:M1,backendName:"webgl",kernelFunc:eP};const Gme="return 1.0 / x;",Wme=dt({opSnippet:Gme}),Hme={kernelName:Rd,backendName:"webgl",kernelFunc:Wme};const qme=Cr+`
  return (x < 0.0) ? 0.0 : x;
`,Kme=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Xme=dt({opSnippet:qme,packedOpSnippet:Kme}),Yme={kernelName:Dd,backendName:"webgl",kernelFunc:Xme};const Jme=Cr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Zme=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qme=dt({opSnippet:Jme,packedOpSnippet:Zme}),ege={kernelName:Od,backendName:"webgl",kernelFunc:Qme};class tge{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=e;this.outputShape=[o,t,s,h];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class nge{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=e;this.outputShape=[o,t,s,h];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function sge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s,[c,h]=l,d=ce().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new nge(r.shape,c,h,i,o):new tge(r.shape,c,h,i,o);return t.runWebGLProgram(d,[r],"float32")}const rge={kernelName:Zg,backendName:"webgl",kernelFunc:sge};class ige{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,l]=e,c=[s&&o>1?r-1:r,s&&l>1?i-1:i],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function oge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,l=new ige(i.shape,r.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const age={kernelName:P1,backendName:"webgl",kernelFunc:oge};class lge{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=e;this.outputShape=[o,t,s,h];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class cge{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=e;this.outputShape=[o,t,s,h];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function uge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s,[c,h]=l,d=ce().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cge(r.shape,c,h,i,o):new lge(r.shape,c,h,i,o);return t.runWebGLProgram(d,[r],r.dtype)}const hge={kernelName:Jg,backendName:"webgl",kernelFunc:uge};class dge{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,l]=e,c=[s&&o>1?r-1:r,s&&l>1?i-1:i],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function fge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,l=new dge(i.shape,r.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const pge={kernelName:L1,backendName:"webgl",kernelFunc:fge};class mge{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=l=>t.indexOf(l)!==-1&&e[l]!==1?`${e[l]} - coords[${l}] - 1`:`coords[${l}]`,i=e.map((l,c)=>r(c)).join(","),o=$t(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class gge{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=ts("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,l=$t(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(r.slice())};
          if(${i}){
            result.g = ${h(r.slice())};
          }
          if(${o}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=e.map((T,k)=>y(k,b)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function y(b,x){return t.indexOf(b)!==-1&&e[b]!==1?`${e[b]} - ${x[b]} - 1`:`${x[b]}`}}}function yge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length,l=st(i,r.shape);if(o===0)return Rs({inputs:{x:r},backend:t});const c=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gge(r.shape,l):new mge(r.shape,l);return t.runWebGLProgram(c,[r],r.dtype)}const bge={kernelName:Qg,backendName:"webgl",kernelFunc:yge};class xge{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const vge={kernelName:W1,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,l=t,c=new xge(s.shape,i),[h,d]=OS(o,s.shape[1],s.shape[2]),p=[[h,d,Math.sin(r),Math.cos(r)]];return l.runWebGLProgram(c,[s],s.dtype,p)}};const wge=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Sge=dt({opSnippet:wge}),Cge={kernelName:Md,backendName:"webgl",kernelFunc:Sge};const Tge="return inversesqrt(x);",kge=dt({opSnippet:Tge,cpuKernelImpl:Ple}),$ge={kernelName:Fd,backendName:"webgl",kernelFunc:kge};class FC{constructor(e,t,s,r,i,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const h=$t(i.length),d=$t(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=t>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class Ege{constructor(e,t,s,r,i,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const h=$t(i.length),d=$t(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=t>1?"strides[j]":"strides",T=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function Ige(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(i,r,o),m=[p/h,h];if(p===0)return t.makeTensorInfo(o,r.dtype);const y=ke({inputs:{x:r},backend:t,attrs:{shape:[c,l]}}),b=ke({inputs:{x:i},backend:t,attrs:{shape:[c,h]}}),x=t.makeTensorInfo([],"float32",new Float32Array([0]));let w;ce().getBool("WEBGL_PACK")?w=new Ege(c,l,y.shape.length,b.shape.length,d,m):w=new FC(c,l,y.shape.length,b.shape.length,d,m);const S=t.runWebGLProgram(w,[b,y,x],b.dtype),T=ke({inputs:{x:S},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(x),T}const Nge={kernelName:LR,backendName:"webgl",kernelFunc:Ige};class Age{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,l=ce().getNumber("WEBGL_VERSION")===2?i:o,c=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function _ge(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,l=new Age(r.shape[0],r.shape[1],i.shape[1],o),c=[[r.shape[1]]];return t.runWebGLProgram(l,[r,i],"int32",c)}const Rge={kernelName:zR,backendName:"webgl",kernelFunc:_ge};class Dge{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],h=[];for(let d=0;d<t.length;d++)h.push(`${l[d]}`),d<e&&c.push(`${l[d]}`);r=c.join(),i=h.join()}const o=$t(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function Oge(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new Dge(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,i],As(r.dtype,i.dtype))}const Mge={kernelName:e0,backendName:"webgl",kernelFunc:Oge};const Fge=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${b0};
  float scale = ${x0};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Lge=dt({opSnippet:Fge}),Pge={kernelName:Ld,backendName:"webgl",kernelFunc:Lge};const zge=iu+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Bge=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Vge=dt({opSnippet:zge,packedOpSnippet:Bge,cpuKernelImpl:Ble}),Uge={kernelName:Vd,backendName:"webgl",kernelFunc:Vge};const jge=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Gge=dt({opSnippet:jge}),Wge={kernelName:Bd,backendName:"webgl",kernelFunc:Gge};const Hge=iu+`
  return sin(x);
`,qge=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${pl}
  return result;
`,Kge=dt({opSnippet:Hge,packedOpSnippet:qge}),Xge={kernelName:Pd,backendName:"webgl",kernelFunc:Kge};const Yge=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Jge=dt({opSnippet:Yge}),Zge={kernelName:zd,backendName:"webgl",kernelFunc:Jge};const Qge=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,e0e=dt({opSnippet:Qge}),t0e={kernelName:Ud,backendName:"webgl",kernelFunc:e0e};const n0e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;L(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((S,T)=>S*T),c=[[0,0]];c.push(...o);for(let S=1+i.length;S<r.shape.length;++S)c.push([0,0]);const h=[],d=QL({inputs:{x:r},backend:t,attrs:{paddings:c,constantValue:0}}),p=sf(d.shape,i,l,!1),m=rf(p.length,i.length,!1),y=of(d.shape,i,l,!1),b=ke({inputs:{x:d},backend:t,attrs:{shape:p}}),x=rs({inputs:{x:b},backend:t,attrs:{perm:m}}),w=ke({inputs:{x},backend:t,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(S=>t.disposeIntermediateTensorInfo(S)),w},s0e={kernelName:s0,backendName:"webgl",kernelFunc:n0e};function r0e(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=t.readSync(s.dataId),c=t.readSync(r.dataId),h=t.readSync(i.dataId),d=t.readSync(o.dataId)[0],[p,m,y,b,x]=Ule(l,s.shape,s.dtype,c,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const i0e={kernelName:BR,backendName:"webgl",kernelFunc:r0e};function o0e(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(r.dataId)),l=t.readSync(s.dataId),c=Array.from(t.readSync(i.dataId)),[h,d,p]=jle(l,s.shape,s.dtype,o,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const a0e={kernelName:VR,backendName:"webgl",kernelFunc:o0e};function l0e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),[h,d]=TL(o,s.shape,s.dtype,l,c,!0);return t.makeTensorInfo(d,s.dtype,h)}const c0e={kernelName:UR,backendName:"webgl",kernelFunc:l0e};function u0e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),[h,d]=TL(o,s.shape,s.dtype,l,c);return t.makeTensorInfo(d,s.dtype,h)}const h0e={kernelName:jR,backendName:"webgl",kernelFunc:u0e};function d0e(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=cl(i,r,l),y=!1;if(i.dtype==="string"){const S=t.bufferSync(r),T=t.bufferSync(i),k=Lo(t.readSync(o.dataId)[0]),$=zle(S,T,l,m,d,h,c,p,k,y);return t.makeTensorInfo(l,$.dtype,$.values)}const b=new FC(h,c,r.shape.length,i.shape.length,p,[m,1],y),x=t.runWebGLProgram(b,[i,r,o],i.dtype),w=ke({inputs:{x},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(x),w}const f0e={kernelName:GR,backendName:"webgl",kernelFunc:d0e};function p0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,l=st(o,r.shape)[0],c=XS(r,i,l),h=r.shape.length,d=new Array(h).fill(0),p=r.shape.slice();return c.map(m=>{const y=[...p];y[l]=m;const b=ou({inputs:{x:r},backend:t,attrs:{begin:d,size:y}});return d[l]+=m,b})}const m0e={kernelName:r0,backendName:"webgl",kernelFunc:p0e};const bA="return sqrt(x);",g0e=dt({opSnippet:bA,packedOpSnippet:bA,cpuKernelImpl:Gle}),y0e={kernelName:jd,backendName:"webgl",kernelFunc:g0e};const b0e="return x * x;",x0e=dt({opSnippet:b0e}),v0e={kernelName:z1,backendName:"webgl",kernelFunc:x0e};const xA="return (a - b) * (a - b);",w0e=Ln({opSnippet:xA,packedOpSnippet:xA}),S0e={kernelName:Gd,backendName:"webgl",kernelFunc:w0e};function C0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),o=qi(i),l=Wle(o,"string",s);return t.makeTensorInfo(r.shape,"string",l)}const T0e={kernelName:B1,backendName:"webgl",kernelFunc:C0e};function k0e({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Cr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new ri(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const $0e={kernelName:Xd,backendName:"webgl",kernelFunc:k0e};class E0e{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=$t(s.length),o=$t(s.length);let l="";if(r===1)l="coords * strides + begin";else{let c=0;l=s.map((h,d)=>(c++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${c-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}function I0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=_S(r.shape,i,o,l,c,h,d,p,m);let E;if(x)E=ke({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||S){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const _=IS(T,k,$),R=ou({inputs:{x:r},backend:t,attrs:{begin:T,size:_}});E=ke({inputs:{x:R},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(R)}else if(t.shouldExecuteOnCPU([r])){const R=t.readSync(r.dataId),D=nt(r.shape,r.dtype,R),M=Hle(y,D,$,T);E=t.makeTensorInfo(b,r.dtype,M.values)}else{const R=new E0e(T,$,y);E=t.runWebGLProgram(R,[r],r.dtype)}const N=ke({inputs:{x:E},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(E),N}const N0e={kernelName:V1,backendName:"webgl",kernelFunc:I0e};function A0e(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=e,m=t.readSync(d.dataId),y=t.readSync(p.dataId),[b,x]=qle(m,y,r,i,o,l,c,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(p.shape,"int32",x)]}const _0e={kernelName:WR,backendName:"webgl",kernelFunc:A0e};function R0e(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=t.readSync(i.dataId),c=t.readSync(o.dataId)[0],[h,d,p]=Kle(l,c,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const D0e={kernelName:HR,backendName:"webgl",kernelFunc:R0e};function O0e(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),l=Xle(o,r);return t.makeTensorInfo(i.shape,"int32",l)}const M0e={kernelName:qR,backendName:"webgl",kernelFunc:O0e};const F0e="return tan(x);",L0e=dt({opSnippet:F0e}),P0e={kernelName:Hd,backendName:"webgl",kernelFunc:L0e};const z0e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,B0e=dt({opSnippet:z0e}),V0e={kernelName:qd,backendName:"webgl",kernelFunc:B0e};function U0e(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:o}=e,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(o,i,r.shape),m=[p/h,h];if(p===0)return t.makeTensorInfo(r.shape,i.dtype);const y=ke({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),b=ke({inputs:{x:o},backend:t,attrs:{shape:[c,h]}}),x=ke({inputs:{x:r},backend:t,attrs:{shape:m}}),w=new FC(c,l,y.shape.length,b.shape.length,d,m,!1,!0),S=t.runWebGLProgram(w,[b,y,x],x.dtype),T=ke({inputs:{x:S},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(S),T}const j0e={kernelName:PR,backendName:"webgl",kernelFunc:U0e};class G0e{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=$t(this.rank),i=W0e(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function W0e(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function tP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const c=t.readSync(r.dataId),h=r.dtype==="string"?c.map(m=>Lo(m)):c,d=nt(r.shape,r.dtype,h),p=Jle(d,i);return t.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new G0e(r.shape,i);return t.runWebGLProgram(o,[r],r.dtype)}const H0e={kernelName:Kd,backendName:"webgl",kernelFunc:tP};class q0e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class K0e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function ka(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function vA(n){let e=1;for(;e<n;)e*=2;return e}function X0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,l=ce().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=ce().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(t.shouldExecuteOnCPU([r])||d<l||i>c){const M=t.readSync(r.dataId),[A,z]=Zle(M,h,r.dtype,i,o);return[t.makeTensorInfo(A.shape,A.dtype,A.values),t.makeTensorInfo(z.shape,z.dtype,z.values)]}if(i===0)return h[h.length-1]=0,[t.makeTensorInfo(h,r.dtype,[]),t.makeTensorInfo(h,"int32",[])];if(d===1)return[r,vf({attrs:{shape:h,dtype:"int32",value:0},backend:t})];const p=t.texData.get(r.dataId),m=p!==null&&p.isPacked,y=m?t.unpackTensor(r):r,x=pe(h)/d,w=ke({inputs:{x:y},attrs:{shape:[x,d]},backend:t});m&&ka(t,y);const S=vA(i),T=vA(d);let k=null;const $=()=>k===null?[w,w]:[w,k],E=(M,A,z)=>{const W=$(),Y=new q0e(z),P=[[d],[k===null?1:0],[Number.NEGATIVE_INFINITY],[M],[A]],B=k;k=t.runWebGLProgram(Y,W,"int32",P),ka(t,B)};for(let M=1;M<S;M*=2){const A=M*2;for(let z=M;z>=1;z/=2)E(A,z,[x,T])}for(let M=T;M>S;M/=2){const A=$(),z=new K0e([x,M/2]),Y=[[d],[k===null?1:0],[S]],K=k;k=t.runWebGLProgram(z,A,"int32",Y),ka(t,K);const P=S/2,B=P*2;for(let G=P;G>=1;G/=2)E(B,G,k.shape)}let N=k;k=ou({inputs:{x:k},backend:t,attrs:{begin:0,size:[x,i]}}),ka(t,N);let _=qL({inputs:{x:w,indices:k},backend:t,attrs:{axis:1,batchDims:1}});ka(t,w);const R=h.slice(0,-1);R.push(i),N=k,k=ke({inputs:{x:k},attrs:{shape:R},backend:t}),ka(t,N);const D=_;return _=ke({inputs:{x:_},attrs:{shape:R},backend:t}),ka(t,D),[_,k]}const Y0e={kernelName:U1,backendName:"webgl",kernelFunc:X0e};class J0e{constructor(e,t,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const l=s==="nearest"?1:2;let c;switch(r){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function Z0e(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=s,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=new J0e(p,m,o,l,c,w);return t.runWebGLProgram(S,[r,i],"float32")}const Q0e={kernelName:j1,backendName:"webgl",kernelFunc:Z0e};function eye(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;yf(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:l,outputShape:c,indices:h}=Qle(o,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const tye={kernelName:G1,backendName:"webgl",kernelFunc:eye};function nye(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,l=o.shape.length,c=r.shape[i],h=new Array(l-1);let d=0;for(let x=0;x<l;x++)x!==i&&(h[d++]=o.shape[x]);const p=[],m=new Array(l).fill(0),y=o.shape.slice();y[i]=1;const b=new Array(c);for(let x=0;x<b.length;x++){m[i]=x;const w=ou({inputs:{x:o},backend:t,attrs:{begin:m,size:y}}),S=ke({inputs:{x:w},backend:t,attrs:{shape:h}});b[x]=S,p.push(w)}return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const sye={kernelName:o0,backendName:"webgl",kernelFunc:nye};class rye{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,l=o*Math.ceil(i/s);this.outputShape=[r,l];const c="0.0",h="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function iye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,l=r.shape.length,c=[];let h=0;const d=Wt([h],l);let p=r;d!=null&&(p=rs({inputs:{x:r},backend:t,attrs:{perm:d}}),c.push(p),h=nn(1,l)[0]);const m=FO(p.shape,h,o),y=pe([p.shape[h]]),b=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}});c.push(b);const x=H1(r.dtype),w=($,E,N,_,R)=>{const D=$.shape[0],M=$.shape[1],A=MO(M,R),z={windowSize:A,inSize:M,batchSize:D,numSegments:R},W=new rye(z,E),Y=t.compileAndRun(W,[$,N],_);if(c.push(Y),Y.shape[1]===R)return Y;const K=eP({backend:t,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),P=tP({inputs:{x:K},backend:t,attrs:{reps:[M/A]}});return c.push(K),c.push(P),w(Y,E,P,_,R)},S=w(b,"unsortedSegmentSum",i,x,o),T=ke({inputs:{x:S},backend:t,attrs:{shape:m}});let k=T;if(d!=null){c.push(T);const $=Ko(d);k=rs({inputs:{x:k},backend:t,attrs:{perm:$}})}return c.forEach($=>t.disposeIntermediateTensorInfo($)),k}const oye={kernelName:a0,backendName:"webgl",kernelFunc:iye};const aye=[Gce,Hce,Xce,Zce,eue,sue,iue,aue,hue,fue,gue,xue,Sue,$ue,Nue,_ue,Due,Lue,zue,Vue,Wue,Zue,ehe,rhe,ohe,dhe,phe,bhe,Ece,whe,$he,Ahe,Fhe,zhe,Vhe,jhe,Whe,Xhe,Zhe,tde,sde,ide,ade,ude,dde,gde,bde,wde,Tde,$de,Ade,Ode,Pde,Vde,Gde,Wde,qde,Xde,Jde,Qde,tfe,ife,lfe,hfe,ffe,gfe,xfe,Cfe,Efe,$ce,Nfe,The,Rfe,Mfe,Pfe,Nce,Ufe,Hfe,Kfe,Zfe,tpe,ipe,lpe,dpe,gpe,xpe,wpe,kpe,Epe,Npe,Dpe,Mpe,Lpe,zpe,Vpe,Wpe,Xpe,Qpe,ame,Rce,hme,pme,yme,vme,lhe,Cme,kme,Eme,Ame,Ome,_ce,Fme,Pme,Bme,Ume,jme,che,sme,Hme,Yme,ege,Oce,rge,age,hge,pge,bge,vge,Cge,$ge,Nge,Rge,Mge,Pge,Uge,Wge,Xge,Zge,Yue,ime,t0e,s0e,i0e,a0e,c0e,h0e,f0e,m0e,y0e,v0e,S0e,T0e,$0e,N0e,_0e,D0e,M0e,rme,Vce,P0e,V0e,j0e,H0e,Y0e,Q0e,Uce,tye,sye,oye,Tme];for(const n of aye)XR(n);const lye=async()=>{try{await jI("webgl"),await E6()}catch{console.warn("WebGL failed, falling back to CPU. Performance will be reduced."),await jI("cpu")}};lye();const wA=3e5,cye=n=>new Promise((e,t)=>{const s=new Worker(new URL(""+new URL("assets/brain.worker-w7z3prtP.js",import.meta.url).href,import.meta.url),{type:"module"});let r=!1;const i=setTimeout(()=>{r||(r=!0,s.terminate(),t(new Error(`Neural Training Timed Out (${wA/1e3}s Limit). Try again or use Fast Mode.`)))},wA);if(s.onmessage=o=>{const{type:l,data:c}=o.data;l==="TRAIN_SUCCESS"?r||(r=!0,clearTimeout(i),s.terminate(),e(c)):l==="ERROR"&&(r||(r=!0,clearTimeout(i),s.terminate(),t(new Error(c))))},s.onerror=o=>{r||(r=!0,clearTimeout(i),s.terminate(),t(o))},n.historicalPrices?.length<fr+20){clearTimeout(i),t(new Error(`Insufficient price history for neural training. Got ${n.historicalPrices?.length||0} bars, need ${fr+20}.`));return}s.postMessage({type:"TRAIN_AND_PREDICT",data:n})}),fr=45,uw=4,qx=(n,e,t)=>(n-e)/(t||1),uye=n=>{const{prices:e,rsi:t,macd:s,atr:r}=n,i=Math.min(e.length,t.length,s.length,r?.length||0),o=e.slice(-i),l=t.slice(-i),c=s.slice(-i),h=r.slice(-i);return[o,l,c,h].map(d=>{const p=d.reduce((y,b)=>y+b,0)/d.length,m=Math.sqrt(d.reduce((y,b)=>y+Math.pow(b-p,2),0)/d.length)||1;return{mean:p,std:m}})},hye=(n,e,t)=>{const s=e.prices[0],r=[];for(let c=0;c<fr;c++)r.push([(e.prices[c]-s)/(s||1),qx(e.rsi[c],t[1].mean,t[1].std),qx(e.macd[c],t[2].mean,t[2].std),qx(e.atr[c],t[3].mean,t[3].std)]);const i=l9([r],[1,fr,uw]),o=n.predict(i),l=o.dataSync()[0];return i.dispose(),o.dispose(),l*s+s},dye=n=>{n&&n.dispose()},fye=async(n,e,t,s)=>{if(n)try{if(e.weightData instanceof ArrayBuffer){const i=new Uint8Array(e.weightData);let o="";for(let l=0;l<i.byteLength;l++)o+=String.fromCharCode(i[l]);e.weightData=btoa(o)}const{error:r}=await us.from("neural_models").upsert([{user_id:n.id,name:t,model_json:e,accuracy:s,created_at:new Date().toISOString()}],{onConflict:"user_id, name"});if(r)throw r;return!0}catch(r){return console.error("Cloud Artifact Save Error:",r),!1}},pye=async(n,e)=>{if(!n)return null;try{const{data:t,error:s}=await us.from("neural_models").select("model_json").eq("name",e).order("created_at",{ascending:!1}).limit(1).maybeSingle();if(s||!t)return null;const r=t.model_json;if(typeof r.weightData=="string"){const l=atob(r.weightData),c=new Uint8Array(l.length);for(let h=0;h<l.length;h++)c[h]=l.charCodeAt(h);r.weightData=c.buffer}else Array.isArray(r.weightData)&&(r.weightData=new Uint8Array(r.weightData).buffer);const i=await CQ(N7(r)),o=i.inputs[0].shape;return o[1]!==fr||o[2]!==uw?(console.warn(`[Brain] Model shape mismatch detected (${o[1]}x${o[2]} vs ${fr}x${uw}). Discarding legacy model.`),i.dispose(),null):i}catch(t){return console.error("Cloud Model Load Error:",t),null}},Th={BTC:"bitcoin",ETH:"ethereum",SOL:"solana",XRP:"ripple",ADA:"cardano",DOGE:"dogecoin",AVAX:"avalanche-2",DOT:"polkadot",MATIC:"matic-network",LINK:"chainlink",LTC:"litecoin",SHIB:"shiba-inu",TRX:"tron",UNI:"uniswap",ATOM:"cosmos",XMR:"monero",ETC:"ethereum-classic",XLM:"stellar",BCH:"bitcoin-cash",FIL:"filecoin",APT:"aptos",QNT:"quant-network",NEAR:"near",ARB:"arbitrum",VET:"vechain",MKR:"maker",AAVE:"aave",GRT:"the-graph",ALGO:"algorand",AXS:"axie-infinity",SAND:"the-sandbox",EOS:"eos",MANA:"decentraland",THETA:"theta-token",EGLD:"elrond-erd-2",FTM:"fantom",XTZ:"tezos",FLOW:"flow",IMX:"immutable-x",SNX:"havven",NEO:"neo",CVX:"convex-finance",CRV:"curve-dao-token",BAT:"basic-attention-token",CHZ:"chiliz",ENJ:"enjincoin",DASH:"dash",COMP:"compound-governance-token",ZEC:"zcash",XEM:"nem",HOT:"holo",IOTX:"iotex",RUNE:"thorchain",KSM:"kusama",ZIL:"zilliqa",RVN:"ravencoin",CELO:"celo",ONE:"harmony",QTUM:"qtum",BNB:"binancecoin"},mye=120*1e3,gye=n=>{try{const e=localStorage.getItem(`cache_${n}`);if(e){const{data:t,timestamp:s}=JSON.parse(e);if(Date.now()-s<mye)return t}}catch(e){console.warn("Cache read compile error",e)}return null},yye=(n,e)=>{try{localStorage.setItem(`cache_${n}`,JSON.stringify({data:e,timestamp:Date.now()}))}catch{try{localStorage.clear()}catch{}}},hw={AAPL:"Apple Inc.",MSFT:"Microsoft Corp.",GOOGL:"Alphabet Inc.",AMZN:"Amazon.com Inc.",NVDA:"NVIDIA Corp.",TSLA:"Tesla Inc.",META:"Meta Platforms Inc.","BRK.B":"Berkshire Hathaway",V:"Visa Inc.",JNJ:"Johnson & Johnson",WMT:"Walmart Inc.",JPM:"JPMorgan Chase & Co.",PG:"Procter & Gamble Co.",MA:"Mastercard Inc.",LLY:"Eli Lilly and Co.",HD:"Home Depot Inc.",CVX:"Chevron Corp.",MRK:"Merck & Co.",KO:"Coca-Cola Co.",PEP:"PepsiCo Inc.",AVGO:"Broadcom Inc.",COST:"Costco Wholesale Corp.",ORCL:"Oracle Corp.",AMD:"Advanced Micro Devices",NFLX:"Netflix Inc.",INTC:"Intel Corp.",IBM:"IBM Corp.",QCOM:"Qualcomm Inc.",TXN:"Texas Instruments",HON:"Honeywell",UNH:"UnitedHealth Group",SPY:"SPDR S&P 500 ETF",QQQ:"Invesco QQQ Trust",IWM:"iShares Russell 2000",DIA:"SPDR Dow Jones"},nP=n=>{if(!n)return null;const e=n.match(/\b\d{1,3}(?:[.,]\d{3})*[.,]\d{1,8}\b/g),t=n.match(/\b\d{1,3}(?:,\d{3})+\b/g),s=n.match(/\b\d{4,7}\b/g),i=[...e||[],...t||[],...s||[]].map(l=>{const c=l.replace(/,/g,""),h=c.split(".");if(h.length>2){const d=h.pop();return parseFloat(h.join("")+"."+d)}return parseFloat(c)}).filter(l=>l>=2e3&&l<=3e3||l===24||l===1||l===7||l===30||l===15||l===60?!1:l>1e-4&&l<2e7);return i.length===0?null:i.sort((l,c)=>{const h=l>.1&&l<15e4,d=c>.1&&c<15e4;if(h&&!d)return-1;if(!h&&d)return 1;const p=l%1!==0,m=c%1!==0;return p&&!m?-1:!p&&m?1:l-c})[0]},bye=n=>{if(!n)return null;const e=n.toUpperCase(),t=["VOL","USD","USDT","UTC","CRYPTO","CRYPTOCURRENCY","PRICE","MARKET","CHANGE","TIME","TOTAL","LOW","HIGH","OPEN","CLOSE","DAILY","WEEKLY"],s=e.split(/[^A-Z0-9]/).filter(l=>l.length>=2);for(const l of Object.keys(Th))if(s.includes(l))return l;const r=e.match(/\b([A-Z0-9]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP|FRAX|DAI)\b/);if(r){const l=r[1];if(Th[l]||hw[l]||l.length>=2&&!t.includes(l))return l}if((e.includes("CRYPTO")||e.includes("O H L"))&&!e.includes("BITCOIN")){const l=nP(n);if(l>4e4&&l<15e4)return"BTC";if(l>1500&&l<1e4)return"ETH"}const i={BITCOIN:"BTC",ETHEREUM:"ETH",SOLANA:"SOL",RIPPLE:"XRP",CARDANO:"ADA",DOGECOIN:"DOGE",AVALANCHE:"AVAX"};for(const[l,c]of Object.entries(i))if(e.includes(l))return c;const o=e.match(/\(([A-Z0-9]{2,6})\)[ -]|^([A-Z0-9]{2,6})\s+\d/);if(o){const l=o[1]||o[2];if(Th[l]||hw[l]||l.length>=2&&!t.includes(l))return l}return null},xye=async n=>{const e=Th[n];if(!e)return null;try{const r=(await(await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${e}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`)).json())[e];return{price:r.usd,change24h:r.usd_24h_change,volume:r.usd_24h_vol,source:"CoinGecko"}}catch(t){return console.error("CoinGecko Fetch Error:",t),null}},vye=async(n,e=90)=>{const t=Th[n];if(!t)return null;const s=gye(`${t}_${e}`);if(s)return s;try{const i=await(await fetch(`https://api.coingecko.com/api/v3/coins/${t}/market_chart?vs_currency=usd&days=${e}`)).json(),o=i.prices.map(h=>h[1]),l=i.total_volumes.map(h=>h[1]),c={closes:o,highs:o.map(h=>h*1.002),lows:o.map(h=>h*.998),volumes:l};return yye(`${t}_${e}`,c),c}catch(r){return console.error("CoinGecko History Error:",r),null}},wye=async n=>{const e=n.includes("-")?n.replace("-",""):n;try{const t=`https://query1.finance.yahoo.com/v8/finance/chart/${e}?interval=1d&range=3mo`,s=[`https://corsproxy.io/?${encodeURIComponent(t)}`,`https://api.allorigins.win/raw?url=${encodeURIComponent(t)}`];let r=null;for(const y of s)try{const b=await fetch(y);if(!b.ok)continue;if(r=await b.json(),r?.chart?.result)break}catch{continue}if(!r)throw new Error("All proxies failed");const i=r.chart.result[0],o=i.indicators.quote[0].close.filter(y=>y!==null),l=i.indicators.quote[0].high.filter(y=>y!==null),c=i.indicators.quote[0].low.filter(y=>y!==null),h=i.indicators.quote[0].volume.filter(y=>y!==null),d=i.meta.regularMarketPrice,p=i.meta.previousClose,m=(d-p)/p*100;return{marketStats:{price:d,change24h:m,volume:h[h.length-1],source:"Yahoo Finance"},historicalData:{closes:o,highs:l,lows:c,volumes:h}}}catch(t){return console.warn("Yahoo data fetch failed for",n,t),null}},SA=async n=>{if(!n||n==="VISUAL-SCAN")return null;const e=n.includes("-")?n.replace("-",""):n;try{const t=`https://query1.finance.yahoo.com/v8/finance/chart/${e}?interval=1d&range=1y`,s=[`https://corsproxy.io/?${encodeURIComponent(t)}`,`https://api.allorigins.win/raw?url=${encodeURIComponent(t)}`];let r=null;for(const o of s)try{const l=await fetch(o);if(!l.ok)continue;if(r=await l.json(),r?.chart?.result)break}catch{continue}return r?.chart?.result?.[0]?.indicators?.quote?.[0]?.close?.filter(o=>o!==null)||null}catch{return null}},Sye=n=>{if(!n||n.length<10)return .5;const e=n[n.length-1],t=n.slice(-50).reduce((o,l)=>o+l,0)/Math.min(n.length,50),s=n.slice(-200).reduce((o,l)=>o+l,0)/Math.min(n.length,200);let r=.5;e>t&&(r+=.1),e>s&&(r+=.15),t>s&&(r+=.1),e>n[0]&&(r+=.1);const i=(e-n[n.length-20])/n[n.length-20];return r+=i*.5,Math.max(.1,Math.min(.9,r))},Cye=(n,e,t,s,r=.95,i=.5,o=.02,l=.5)=>{const h=.15+(o>.04?.05:0),d=.1,p=s.omega+s.alpha+s.gamma+h+d,m=K=>(K-.5)*2,y=m(n),b=s.omega/p,x=r;let w=.5;e==="Bullish"?w=.85:e==="Bearish"&&(w=.15);const S=m(w),T=s.alpha/p,k=t.rsi[t.rsi.length-1];let $=.5;k<30?$=.85:k<40?$=.7:k>70?$=.15:k>60&&($=.3);const E=m($),N=s.gamma/p,_=k<25||k>75?1.3:1,R=m(i),D=h/p,M=m(l),Y=1-[{w:b,p:y,c:x,f:1},{w:T,p:S,c:.9,f:1},{w:N,p:E,c:1,f:_},{w:D,p:R,c:1,f:1},{w:.15,p:M,c:1,f:1},{w:d/p,p:m(s.obBias||.5),c:1,f:1}].reduce((K,P)=>{const B=P.w*P.p*P.c*P.f;return K*(1-Math.max(-.99,Math.min(.99,B)))},1-.5);return Math.min(.995,Math.max(.005,Y))},Tye=async(n,e,t,s,r,i,o=.95,l=!1)=>{const c=Array.isArray(t)?t:t.closes||[],h=t.highs||c,d=t.lows||c;t.volumes;let p=e.price||c[c.length-1];const m=c[c.length-1];if(e.price&&m){const Te=Math.log10(m/e.price);if(Math.abs(Te)>.6){const ze=Math.pow(10,Math.round(Te));console.log(`[ScaleGuardian] Correcting OCR price scale: ${e.price} -> ${e.price*ze} (Factor: ${ze})`),p=e.price*ze}}if(c.length<20)throw new Error("Insufficient historical data for precision analysis");const y=E5(c,14),x=N5(c).histogram,w=t.opens||[],S=A5(c,h,d,w),T=S[0].sentiment,k=_5(h,d,c,14),$=R5(c,h,d);t.volumes&&t.volumes.length>0&&D5(h,d,c,t.volumes);let E=.5;try{i("Aligning Multi-Timeframe Bias (Daily)...");const Te=await SA(n);Te?.prices&&(E=O5(Te.prices))}catch(Te){console.warn("MTF Alignment failed, using neutral bias:",Te)}let N=.5,_=null;const R=k[k.length-1]||p*.02,D=R/p;if(c.length>=fr)if(l){const Te=c[c.length-1],ze=c[c.length-15],Ke=(Te-ze)/ze;N=.5+Math.min(.45,Math.max(-.45,Ke/(D*5))),i("Rapid Precision Heuristic Applied...")}else{let Te=null;try{const ze={prices:c,rsi:y,macd:x,atr:k};if(s&&(Te=await pye(s,`lstm_v4_${n}`)),Te){if(i("Calibrating Cloud Intelligence V4..."),_=uye(ze),Te&&c.length>=fr&&_){i("Running V4 Predictive Inference...");const Ke={prices:c.slice(-fr),rsi:y.slice(-fr),macd:x.slice(-fr),atr:k.slice(-fr)},Qe=hye(Te,Ke,_),We=1/(D*10||1);N=.5+(Qe-p)/p*We,N=Math.max(.02,Math.min(.98,N))}}else{i("Training Deep LSTM V4 (Parallel Core)...");const Ke=await cye({ticker:n,historicalPrices:c,rsi:y,macdHist:x,atr:k});if(Ke){const Qe=1/(D*10||1);N=.5+(Ke.predictedPrice-p)/p*Qe,N=Math.max(.02,Math.min(.98,N)),_=Ke.stats,s&&Ke.modelArtifacts&&(i("Syncing V4 Brain to Cloud..."),await fye(s,Ke.modelArtifacts,`lstm_v4_${n}`,.99))}}}finally{Te&&dye(Te)}}i("Gathering Macro V4 Context...");const M=await SA(n),A=Sye(M?.prices);let z=.5;try{if(n.includes("BTC")||n.includes("ETH")||n.includes("SOL")){let Te=n.replace("/","").toUpperCase();(Te==="BTC"||Te==="ETH"||Te==="SOL")&&(Te+="USDT");const ze=await fetch(`https://api.binance.com/api/v3/depth?symbol=${Te}&limit=20`);if(ze.ok){const Ke=await ze.json(),Qe=Ke.bids.reduce((qe,[wt,pt])=>qe+Number(pt),0),We=Ke.asks.reduce((qe,[wt,pt])=>qe+Number(pt),0);z=Qe/(Qe+We),console.log(`[Analysis] Order Book Bias: ${z.toFixed(2)}`)}}}catch(Te){console.warn("Order Book sync failed:",Te)}let W=Cye(N,T,{rsi:y},{...r,obBias:z},o,A,D,E);const Y=y[y.length-1]<45&&T==="Bullish",K=y[y.length-1]>55&&T==="Bearish";if(N>.75&&Y){const Te=.05+.1*(N-.75);W=Math.min(.99,W+Te)}else if(N<.25&&K){const Te=.05+.1*(.25-N);W=Math.max(.01,W-Te)}const P=[{name:"Neural Net (V5 LSTM)",type:"Deep Intelligence",w:r.omega,p:N,value:l?"Heuristic":"RMSE-Optimized"},{name:`Primary Pattern: ${S[0].name}`,type:"Geometric",w:r.alpha,p:T==="Bullish"?.8:T==="Bearish"?.2:.5,value:S[0].name},{name:"Technical Alpha",type:"Confluence",w:r.gamma,p:y[y.length-1]<45?.8:y[y.length-1]>55?.2:.5,value:"RSI-ATR Sync"},{name:"Macro Sentiment",type:"Ensemble",w:.15,p:A,value:"10Y-Alpha"},{name:"MTF Alignment",type:"V5 Bias",w:.15,p:E,value:E>.6?"Bullish":E<.4?"Bearish":"Neutral"},{name:"Visual Alignment",type:"Sync",w:.1,p:o,value:`${(o*100).toFixed(0)}%`}];let B="Neutral";W>.68?B="Strong Bullish":W>.55?B="Moderate Bullish":W<.32?B="Strong Bearish":W<.45&&(B="Moderate Bearish");const G=B.includes("Bullish"),ee=p<1?5:p<100?3:2,F=1.8-(G?$.strength.s:$.strength.r)*.1,V=Math.max(p*.005,R*F),Q=2+r.iterations*.02;let re,he,ye;G?(re=Math.min(p*.99,p-V),$.support<p&&$.support>re&&(re=$.support*.998),he=p+V*Q,ye=p+V*Q*1.6):(re=Math.max(p*1.01,p+V),$.resistance>p&&$.resistance<re&&(re=$.resistance*1.002),he=Math.max(0,p-V*Q),ye=Math.max(0,p-V*Q*1.6));const we={entry:p.toFixed(ee),sl:re.toFixed(ee),tp1:he.toFixed(ee),tp2:ye.toFixed(ee),rr:Q.toFixed(1)},Ie=((W>.5?W:1-W)*100).toFixed(1),Ce=()=>{y[y.length-1];let Te=`V5 Institutional analysis of **${n}** identified a **${B}** structure with **${Ie}%** mathematical confidence. `;if(S.length>0){const ze=S[0];Te+=`The detection of a **${ze.name}** pattern suggests a dominant ${ze.sentiment.toLowerCase()} sentiment in the current fractal. `}return N>.7?Te+="Deep LSTM detects aggressive institutional accumulation. ":N<.3&&(Te+="Neural inference highlights terminal distribution phases. "),($.strength.s>3||$.strength.r>3)&&(Te+=`Major ${$.strength.s>$.strength.r?"support":"resistance"} detected at $${$.strength.s>$.strength.r?$.support.toFixed(ee):$.resistance.toFixed(ee)} with strength ${Math.max($.strength.s,$.strength.r)}/5. `),D>.05&&(Te+="High implied volatility suggests widened discovery ranges. "),Te},Pe={volatility:(D*100).toFixed(2),sharpeRatio:(((p-c[0])/c[0]*100*(252/c.length)-4.5)/(D*Math.sqrt(252)*100||1)).toFixed(2),maxDrawdown:((Math.min(...c.slice(-90))-Math.max(...c.slice(-90)))/Math.max(...c.slice(-90))*100).toFixed(2),calibration:{rmse:(Math.sqrt(Math.pow(1-W,2))*.08).toFixed(4),brier:Math.pow(W-(G?1:0),2).toFixed(4)}};return{id:Date.now().toString(),date:new Date().toISOString(),p0:r.alpha.toFixed(2),finalProb:Number(W),direction:B,confidence:Ie,patterns:S,factors:P,targets:we,riskMetrics:Pe,macroTrend:{...M,source:M?.source||"Internal V4 Engine"},overview:Ce(),ticker:n||"UNKNOWN",version:`V4-RMSE-PRECISION (Iter: ${r.iterations})`,raw_prices:c}},$a="https://diverai.flisoft.agency",kye=({ticker:n})=>{const[e,t]=Se.useState(null),[s,r]=Se.useState(!1);Se.useEffect(()=>{n&&i()},[n]);const i=async()=>{r(!0);try{let o=n.replace("/","").toUpperCase();(o==="BTC"||o==="ETH"||o==="SOL"||o==="XRP")&&(o+="USDT");const l=await fetch(`https://api.binance.com/api/v3/depth?symbol=${o}&limit=5`);if(l.ok){const c=await l.json();t(c)}}catch{console.warn("Order book fetch skipped for non-compatible ticker.")}finally{r(!1)}};return s?oe.jsx("div",{className:"h-20 bg-slate-900 animate-pulse rounded-xl"}):e?oe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3 space-y-2",children:[oe.jsxs("div",{className:"flex items-center gap-2 text-[10px] font-bold text-slate-500 uppercase",children:[oe.jsx(EG,{className:"w-3 h-3"})," Order Book Depth"]}),oe.jsxs("div",{className:"space-y-1",children:[e.asks.slice(0,3).reverse().map(([o,l],c)=>oe.jsxs("div",{className:"flex justify-between text-[10px] font-mono",children:[oe.jsx("span",{className:"text-rose-500",children:Number(o).toFixed(2)}),oe.jsx("span",{className:"text-slate-600",children:Number(l).toFixed(4)})]},`ask-${c}`)),oe.jsx("div",{className:"h-px bg-slate-800 my-1"}),e.bids.slice(0,3).map(([o,l],c)=>oe.jsxs("div",{className:"flex justify-between text-[10px] font-mono",children:[oe.jsx("span",{className:"text-emerald-500",children:Number(o).toFixed(2)}),oe.jsx("span",{className:"text-slate-600",children:Number(l).toFixed(4)})]},`bid-${c}`))]})]}):null},$ye=()=>{const{user:n,profile:e,refreshProfile:t,neuralState:s}=$5(),[r,i]=Se.useState("idle"),[o,l]=Se.useState(null),[c,h]=Se.useState(null),[d,p]=Se.useState(""),[m,y]=Se.useState(""),[b,x]=Se.useState(!1),[w,S]=Se.useState(""),[T,k]=Se.useState("guest"),[$,E]=Se.useState(null),[N,_]=Se.useState([]),[R,D]=Se.useState("analyze"),[M,A]=Se.useState(!1);Se.useEffect(()=>{z();const Z=async F=>{if(F.type==="AUTH_SYNC"&&F.session){const{access_token:V,refresh_token:Q}=F.session;await us.auth.setSession({access_token:V,refresh_token:Q}),t()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(Z),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(Z)}},[]);const z=async()=>{try{const Z=await fetch("https://api.ipify.org?format=json");if(!Z.ok)throw new Error("Network response was not ok");const F=await Z.json();E(F.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};Se.useEffect(()=>{W()},[n]);const W=async()=>{if(!n){const V=localStorage.getItem("diver_ai_guest_history");_(V?JSON.parse(V):[]);return}const{data:Z,error:F}=await us.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!F&&Z&&_(Z.map(V=>({...V.data,db_id:V.id,created_at:V.created_at})))},Y=async Z=>{if(n){const{data:F}=await us.from("prediction_history").insert([{user_id:n.id,data:Z}]).select();if(F?.[0]){const V={...Z,db_id:F[0].id,created_at:F[0].created_at};_(Q=>[V,...Q].slice(0,10))}}},K=()=>{},P=()=>{if(!n)return S("Authentication Required: Please log in to access the neural analysis terminal."),k("guest"),x(!0),!1;const Z=new Date().toISOString().split("T")[0];return n.email_confirmed_at?e&&e.subscription_tier!=="pro"&&(e.upload_count||0)>=3&&e.last_upload_date===Z?(S("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),k("free"),x(!0),!1):!0:(S("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),k("verify"),x(!0),!1)},B=async()=>{if(P()){i("scanning"),p("Capturing Visual Stream..."),l(null);try{const Z=await new Promise(We=>{chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"},qe=>{chrome.runtime.lastError?We({error:"Connection to extension background lost. Please refresh the page."}):We(qe)})});if(Z.error)throw new Error(Z.error);const F=Z.dataUrl;h(F),i("analyzing"),p("Deep Scan (Cloud OCR)...");const{data:{session:V}}=await us.auth.getSession();let Q=V?.access_token||"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",re=0,he,ye=!1;for(;!ye&&re<3;)try{if(he=await fetch("https://brrjoheinakfhohesogc.supabase.co/functions/v1/detect_ticker",{method:"POST",headers:{"Content-Type":"application/json",apikey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",Authorization:`Bearer ${re===2?"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A":Q}`},body:JSON.stringify({image:F})}),he.ok)ye=!0;else if(he.status===401&&re===0&&V){console.info("[Sidebar] Auth 401. Attempting session refresh...");try{const{data:{session:qe},error:wt}=await us.auth.refreshSession();wt||!qe?(console.warn("[Sidebar] Refresh failed, switching to Anon-Key fallback."),re=2):(Q=qe.access_token,re++)}catch{re=2}}else if(he.status===401&&re<2)console.info("[Sidebar] Auth 401 (No Session/Expired). Using Anon-Key fallback."),re=2,await new Promise(qe=>setTimeout(qe,500));else throw new Error(`Service Error (${he.status})`)}catch(We){if(re>=2)throw We;re++}if(!he||!he.ok)throw new Error("Visualization Service Unavailable");const Ie=(await he.json())?.text||"",Ce=bye(Ie),Pe=nP(Ie);if(console.log("[Sidebar] OCR Detected:",{ticker:Ce,anchorPrice:Pe}),!Ce&&!Pe)throw new Error("Neural Core Rejected: No valid asset or price identified.");p(`Target Locked: ${Ce}. Syncing Data...`);let Te,ze;if(hw[Ce]){const We=await wye(Ce);if(We)Te=We.marketStats,ze=We.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else Te=await xye(Ce),ze=await vye(Ce,90);p("Synchronizing Global Intelligence...");const Qe=await Tye(Ce,Te,ze,n,s,p,.95,!0);if(n&&e){const We=new Date().toISOString().split("T")[0],qe=e.last_upload_date!==We?1:(e.upload_count||0)+1;await us.from("profiles").update({upload_count:qe,last_upload_date:We}).eq("id",n.id),t()}else K();await Y(Qe),l(Qe),i("success")}catch(Z){console.error(Z),y(Z.message),i("error")}}},G=()=>{if(!o){console.warn("[Overlay] No analysis result available to draw overlay.");return}chrome.tabs.query({active:!0,currentWindow:!0},Z=>{const F=Z[0];if(!F){console.warn("[Overlay] No active tab found.");return}if(!F.url){console.warn("[Overlay] Unable to determine current page URL.");return}if(!["tradingview.com","yahoo.com","coingecko.com","coinmarketcap.com","binance.com","google.com/finance"].some(re=>F.url.includes(re))){console.info(`[Overlay] Skipped - Not on a supported trading page. Current URL: ${F.url}`),alert("Please navigate to a trading chart (e.g., TradingView) to draw the R/R overlay.");return}chrome.tabs.sendMessage(F.id,{action:"DRAW_RR_OVERLAY",targets:o.targets,ticker:o.ticker},re=>{chrome.runtime.lastError?(console.error("[Overlay] Failed:",chrome.runtime.lastError.message),alert("Overlay failed: Content script not ready. Try refreshing the trading page.")):re?.success?console.log("[Overlay] Successfully drawn on chart."):console.warn("[Overlay] Message sent, but no confirmation received.")})})},ee=({id:Z,label:F,icon:V})=>oe.jsxs("button",{onClick:()=>D(Z),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${R===Z?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[oe.jsx(V,{className:"w-3.5 h-3.5"}),F,R===Z&&oe.jsx(wa.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return oe.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&oe.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:oe.jsxs("div",{className:"space-y-6 max-w-xs",children:[oe.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:oe.jsx(rI,{className:"text-rose-500"})}),oe.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),oe.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),oe.jsxs("div",{className:"space-y-3",children:[T==="free"?oe.jsx("button",{onClick:()=>window.open(`${$a}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):T==="guest"?oe.jsx("button",{onClick:()=>window.open(`${$a}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):oe.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),oe.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),oe.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[oe.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[oe.jsxs("div",{className:"flex items-center gap-2",children:[oe.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:oe.jsx(bG,{className:"w-3.5 h-3.5 text-white"})}),oe.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",oe.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?oe.jsxs("div",{className:"flex items-center gap-3",children:[oe.jsx("div",{className:"text-right",children:oe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:e?.subscription_tier==="pro"?"PRO":"BASIC"})}),oe.jsx("button",{onClick:()=>us.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:oe.jsx(AG,{className:"w-4 h-4"})})]}):oe.jsx("button",{onClick:()=>window.open(`${$a}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),oe.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[oe.jsx(ee,{id:"analyze",label:"Analysis",icon:aI}),oe.jsx(ee,{id:"history",label:"History",icon:sI}),n&&oe.jsx(ee,{id:"referral",label:"Rewards",icon:UG})]})]}),oe.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:oe.jsxs(MU,{mode:"wait",children:[R==="history"&&oe.jsx(wa.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:N.length===0?oe.jsxs("div",{className:"text-center py-12 text-slate-600",children:[oe.jsx(sI,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),oe.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):N.map((Z,F)=>oe.jsxs("div",{onClick:()=>{l(Z),i("success"),D("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[oe.jsxs("div",{className:"flex items-center gap-3",children:[oe.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${Z.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:Z.direction.includes("Bullish")?oe.jsx(oI,{className:"w-4 h-4"}):oe.jsx(iI,{className:"w-4 h-4"})}),oe.jsxs("div",{children:[oe.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:Z.ticker}),oe.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(Z.created_at).toLocaleDateString()})]})]}),oe.jsxs("span",{className:`text-xs font-mono font-bold ${Z.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(Z.finalProb*100).toFixed(0),"%"]})]},Z.db_id||F))},"history"),R==="referral"&&n&&oe.jsxs(wa.div,{initial:{opacity:0,x:10},animate:{opacity:1,x:0},className:"space-y-4",children:[oe.jsxs("div",{className:"bg-gradient-to-br from-blue-600 to-indigo-700 rounded-2xl p-5 border border-white/10 shadow-xl relative overflow-hidden",children:[oe.jsx("div",{className:"absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 mix-blend-overlay"}),oe.jsxs("div",{className:"relative z-10 space-y-3",children:[oe.jsx("h3",{className:"text-sm font-black uppercase tracking-tight",children:"Earn Pro Status"}),oe.jsx("p",{className:"text-[10px] text-blue-100 font-medium leading-relaxed",children:"Refer a friend. You both get 30 days of Pro analysis upon their signup."}),oe.jsx("div",{className:"pt-2",children:oe.jsxs("div",{className:"flex gap-2",children:[oe.jsx("div",{className:"flex-1 bg-slate-950/40 border border-white/10 rounded-lg px-3 py-2 text-[9px] font-mono text-blue-200 truncate",children:e?.referral_code?`${$a}/signup?ref=${e.referral_code}`:"Generating..."}),oe.jsx("button",{onClick:()=>{navigator.clipboard.writeText(`${$a}/signup?ref=${e?.referral_code}`),A(!0),setTimeout(()=>A(!1),2e3)},className:"bg-white text-slate-950 p-2 rounded-lg hover:bg-blue-100 transition-colors",children:M?oe.jsx(vG,{className:"w-3.5 h-3.5"}):oe.jsx(SG,{className:"w-3.5 h-3.5"})})]})})]})]}),oe.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[oe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[oe.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Total Referrals"}),oe.jsx("p",{className:"text-xl font-black text-white",children:e?.referral_count||0})]}),oe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[oe.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Days Granted"}),oe.jsx("p",{className:"text-xl font-black text-emerald-400",children:(e?.referral_count||0)*30})]})]}),oe.jsxs("button",{onClick:()=>window.open(`${$a}/referral`,"_blank"),className:"w-full py-3 bg-slate-900 border border-slate-800 hover:border-blue-500/50 text-slate-300 hover:text-white text-[10px] font-bold uppercase tracking-widest rounded-xl transition-all flex items-center justify-center gap-2",children:[oe.jsx(FG,{className:"w-3.5 h-3.5"})," View Full Dashboard"]})]},"referral"),R==="analyze"&&r==="idle"&&oe.jsx(wa.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:n?oe.jsxs(oe.Fragment,{children:[oe.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:oe.jsx(OG,{className:"w-8 h-8 text-blue-500"})}),oe.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[oe.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),oe.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]}):oe.jsxs(oe.Fragment,{children:[oe.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:oe.jsx(rI,{className:"w-8 h-8 text-rose-500"})}),oe.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[oe.jsx("h3",{className:"text-lg font-bold text-white",children:"Terminal Locked"}),oe.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Neural analysis requires an active operative session. Please login to continue."})]}),oe.jsx("button",{onClick:()=>window.open(`${$a}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg transition-all uppercase tracking-widest text-[10px]",children:"Initialize Login"})]})},"idle"),(r==="scanning"||r==="analyzing")&&oe.jsxs(wa.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[oe.jsxs("div",{className:"relative w-16 h-16",children:[oe.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),oe.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),oe.jsxs("div",{className:"text-center space-y-2",children:[oe.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),oe.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),r==="success"&&o&&R==="analyze"&&oe.jsxs(wa.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[oe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[oe.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[oe.jsxs("div",{children:[oe.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:o.ticker}),oe.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[oe.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${o.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[o.direction.split(" ")[0]," Signal"]}),oe.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(o.finalProb*100).toFixed(1),"% Conf."]})]})]}),oe.jsx("div",{className:`p-2 rounded-xl ${o.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:o.direction.includes("Bullish")?oe.jsx(oI,{className:"w-5 h-5 text-emerald-500"}):oe.jsx(iI,{className:"w-5 h-5 text-rose-500"})})]}),oe.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${o.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),oe.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[oe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[oe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),oe.jsx("p",{className:"text-lg font-mono font-bold text-white",children:o.targets.entry})]}),oe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[oe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),oe.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",o.targets.rr]})]}),oe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[oe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),oe.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:o.targets.tp1})]}),oe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[oe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),oe.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:o.targets.sl})]})]}),oe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[oe.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[oe.jsx(TG,{className:"w-3 h-3"})," AI Analysis"]}),oe.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:o.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),oe.jsx(kye,{ticker:o.ticker}),oe.jsxs("button",{onClick:G,className:"w-full py-3 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded-xl flex items-center justify-center gap-2 text-[10px] font-bold uppercase tracking-widest transition-all",children:[oe.jsx(RG,{className:"w-3.5 h-3.5 text-blue-400"})," Draw R/R on Chart"]}),oe.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:oe.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",o.version.split(" ")[0],"  Data: ",o.macroTrend?.source||"Institutional Feed"]})}),oe.jsx("button",{onClick:()=>i("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),r==="error"&&oe.jsxs(wa.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[oe.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:oe.jsx(BG,{className:"w-6 h-6 text-rose-500"})}),oe.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),oe.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),oe.jsx("button",{onClick:()=>i("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),R==="analyze"&&r==="idle"&&oe.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:oe.jsxs("button",{onClick:B,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[oe.jsx(aI,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};RB.createRoot(document.getElementById("root")).render(oe.jsx(TB.StrictMode,{children:oe.jsx(k5,{children:oe.jsx($ye,{})})}));
